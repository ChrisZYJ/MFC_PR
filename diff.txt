diff --git a/batch_mfc.sh b/batch_mfc.sh
new file mode 100755
index 00000000..41df3c34
--- /dev/null
+++ b/batch_mfc.sh
@@ -0,0 +1,14 @@
+#!/bin/bash
+
+./mfc.sh run /users/mrodri97/scratch/lungwave/case0/case.py -e batch -N 1 -n 4 -w 00:30:00 -# pre -t pre_process -c oscar
+./mfc.sh run /users/mrodri97/scratch/lungwave/case0/case.py -e batch -N 1 -n 4 -w 00:30:00 -# sim -t simulation -c oscar
+./mfc.sh run /users/mrodri97/scratch/lungwave/case0/case.py -e batch -N 1 -n 4 -w 00:30:00 -# pos -t post_process -c oscar
+
+./mfc.sh run /users/mrodri97/scratch/lungwave/case1/case.py -e batch -N 1 -n 4 -w 00:30:00 -# pre -t pre_process -c oscar
+./mfc.sh run /users/mrodri97/scratch/lungwave/case1/case.py -e batch -N 1 -n 4 -w 00:30:00 -# sim -t simulation -c oscar
+./mfc.sh run /users/mrodri97/scratch/lungwave/case1/case.py -e batch -N 1 -n 4 -w 00:30:00 -# pos -t post_process -c oscar
+
+./mfc.sh run /users/mrodri97/scratch/lungwave/case2/case.py -e batch -N 1 -n 4 -w 00:30:00 -# pre -t pre_process -c oscar
+./mfc.sh run /users/mrodri97/scratch/lungwave/case2/case.py -e batch -N 1 -n 4 -w 00:30:00 -# sim -t simulation -c oscar
+./mfc.sh run /users/mrodri97/scratch/lungwave/case2/case.py -e batch -N 1 -n 4 -w 00:30:00 -# pos -t post_process -c oscar
+
diff --git a/examples/2D_lungwave/case.py b/examples/2D_lungwave/case.py
new file mode 100644
index 00000000..e5888cbe
--- /dev/null
+++ b/examples/2D_lungwave/case.py
@@ -0,0 +1,193 @@
+#!/usr/bin/env python3
+
+import math
+import json
+
+pi = 3.141592653589
+# material parameters
+
+#material1 :: gas
+#patterson 2018
+
+gammag = 1.4    #unitless
+Bg =0           #pascals
+rhog = 1.18     #kg/m^3
+c_g = 347.2     #m/s
+G_g = 0         #pa
+
+    #material2 :: lung
+
+gammal = 5.5
+Bl = 492.E+06
+rhol = 996.0
+c_l = 1648.7
+G_l = 1E3
+
+#primitive vartiables
+patmos = 101325. #pa
+
+#problem specific variable
+lambda_wave = 1E-3
+
+#define pulse
+P_amp = 10.E+6
+P_len = 45                  #length of the impulse
+theta = -math.pi/2          #direction of propagation 
+
+#non-dim
+
+#define characteristic density, length, time, stress material
+rho_char = rhog
+length_char = lambda_wave
+c_char = c_g
+time_char = length_char/c_char
+stress_char = rho_char*c_char*c_char/gammag
+
+#non-dim the properties
+rhog_n  = rhog/rho_char    
+c_g_n = c_g/c_char    
+rhol_n = rhol/rho_char
+c_l_n = c_l/c_char
+Bg_n = Bg/stress_char
+Bl_n = Bl/stress_char
+G_g_n = G_g/stress_char
+G_l_n = G_l/stress_char
+patmos_n = patmos/stress_char
+P_amp_n = P_amp/stress_char
+
+#geometry
+dlengx = 1.
+dlengy = 20.
+Nx = 200
+Ny = dlengy*Nx
+dx = dlengx/Nx
+dy = dlengy/Ny
+alphal_back = 1.0
+alphag_back = 0.0
+alphal_lung = 0.0
+alphag_lung = 1.0
+
+interface_amp = 0.5
+
+# time stepping requirements
+time_end = 2.5
+cfl = 0.5
+
+dt = cfl * dx/c_l 
+Nt = int(time_end/dt)
+Nframes = 50000
+tstart = 0
+tstop = Nt
+tsave = int(Nt/Nframes)
+
+#interface profile
+interface_amp = 0.5      
+
+# Configuring case dictionary
+print(json.dumps({
+    # Logistics ================================================================
+    'run_time_info'                : 'T',
+    # ==========================================================================
+
+    # Computational Domain Parameters ==========================================
+    'x_domain%beg'                 :  0.,
+    'x_domain%end'                 :  dlengx,
+    'y_domain%beg'                 :  -dlengy/2.,
+    'y_domain%end'                 :  dlengy/2.,
+    'm'                            : int(Nx),
+    'n'                            : int(Ny),
+    'p'                            : 0,
+    'dt'                           : dt,
+    't_step_start'                 : tstart,
+    't_step_stop'                  : tstop,
+    't_step_save'                  : tsave,
+    # ==========================================================================
+
+    # Simulation Algorithm Parameters ==========================================
+    'num_patches'                  : 2,
+    'model_eqns'                   : 2,
+    'alt_soundspeed'               : 'F',
+    'num_fluids'                   : 2,
+    'adv_alphan'                   : 'T',
+    'mpp_lim'                      : 'T',
+    'mixture_err'                  : 'T',
+    'time_stepper'                 : 3,
+    'weno_order'                   : 5,
+    'weno_eps'                     : 1.E-16,
+    'weno_Re_flux'                 : 'F',  
+    'weno_avg'                     : 'F',
+    'mapped_weno'                  : 'T',
+    'null_weights'                 : 'F',
+    'mp_weno'                      : 'T',
+    'riemann_solver'               : 2,
+    'wave_speeds'                  : 1,
+    'avg_state'                    : 2,
+    'bc_x%beg'                     : -1,
+    'bc_x%end'                     : -1,
+    'bc_y%beg'                     : -6,
+    'bc_y%end'                     : -6,
+    # ==========================================================================
+
+    # Formatted Database Files Structure Parameters ============================
+    'format'                       : 1,
+    'precision'                    : 2,
+    'prim_vars_wrt'                :'T',
+    'parallel_io'                  :'T',
+    # ==========================================================================
+    
+    # Monopole setting =========================================================
+    'Monopole'                      : 'T',             # creating an acoustic wave
+    'num_mono'                      : 1,               # place in the middle and expand
+    'Mono(1)%pulse'                 : 3,               # sine  wave
+    'Mono(1)%npulse'                : 1,               # 1 pulse
+    'Mono(1)%mag'                   : 10.0*patmos_n,   # magnitude
+    'Mono(1)%length'                : 1*dlengx,        # impulse length
+    'Mono(1)%loc(1)'                : dlengx/2,        # x_center of the domain
+    'Mono(1)%loc(2)'                : 5.0*dlengx,      # upper boundary of the domain
+    'Mono(1)%dir'                   : -math.pi/2,      # direction: -pi/2
+ #==============================================================================
+                                                                
+    # Patch 1: Background ======================================================
+    'patch_icpp(1)%geometry'       : 3,
+    'patch_icpp(1)%x_centroid'     : dlengx/2,
+    'patch_icpp(1)%y_centroid'     : 0.,
+    'patch_icpp(1)%length_x'       : dlengx,
+    'patch_icpp(1)%length_y'       : dlengy,
+    'patch_icpp(1)%vel(1)'         : 0.,
+    'patch_icpp(1)%vel(2)'         : 0.E+00,
+    'patch_icpp(1)%pres'           : patmos_n,
+    'patch_icpp(1)%alpha_rho(1)'   : rhol_n*alphal_back,
+    'patch_icpp(1)%alpha_rho(2)'   : rhog_n*alphag_back,
+    'patch_icpp(1)%alpha(1)'       : alphal_back,
+    'patch_icpp(1)%alpha(2)'       : alphag_back,
+    # ==========================================================================
+
+
+    # Patch 2: Lung ============================================================
+    'patch_icpp(2)%geometry'       : 7,
+    'patch_icpp(2)%hcid'           : 205,
+    'patch_icpp(2)%alter_patch(1)' : 'T',
+    'patch_icpp(2)%x_centroid'     : dlengx/2.,
+    'patch_icpp(2)%y_centroid'     : -dlengy/4.,
+    'patch_icpp(2)%length_x'       : dlengx,
+    'patch_icpp(2)%length_y'       : dlengy/2.+2,
+    'patch_icpp(2)%a2'             : interface_amp,
+    'patch_icpp(2)%vel(1)'         : 0.E+00,
+    'patch_icpp(2)%vel(2)'         : 0.0,
+    'patch_icpp(2)%pres'           : patmos_n,
+    'patch_icpp(2)%alpha_rho(1)'   : rhol_n*alphal_lung,
+    'patch_icpp(2)%alpha_rho(2)'   : rhog_n*alphag_lung,
+    'patch_icpp(2)%alpha(1)'       : alphal_lung,
+    'patch_icpp(2)%alpha(2)'       : alphag_lung,
+    # ==========================================================================
+
+    # Fluids Physical Parameters ===============================================
+    'fluid_pp(1)%gamma'            : 1.E+00/(gammal-1.E+00),
+    'fluid_pp(1)%pi_inf'           : gammal*Bl_n/(gammal-1.E+00),
+    'fluid_pp(2)%gamma'            : 1.E+00/(gammag-1.E+00),
+    'fluid_pp(2)%pi_inf'           : gammag*Bg_n/(gammag-1.E+00),
+    # ========================================================================== 
+    
+}))
+
+# ==============================================================================
diff --git a/examples/2D_lungwave_horizontal/case.py b/examples/2D_lungwave_horizontal/case.py
new file mode 100644
index 00000000..d11aeac2
--- /dev/null
+++ b/examples/2D_lungwave_horizontal/case.py
@@ -0,0 +1,189 @@
+#!/usr/bin/env python3
+
+import math
+import json
+
+pi = 3.141592653589
+# material parameters
+
+#material1 :: gas
+#patterson 2018
+
+gammag = 1.4    #unitless
+Bg =0           #pascals
+rhog = 1.18     #kg/m^3
+c_g = 347.2     #m/s
+G_g = 0         #pa
+
+#material2 :: water
+gammal = 5.5
+Bl = 492.E+06
+rhol = 996.0
+c_l = 1648.7
+G_l = 1E3
+
+#primitive vartiables
+patmos = 101325. #pa
+
+#problem specific variable
+lambda_wave = 1E-3
+
+#define pulse
+P_amp = 10.E+6
+P_len = 45                  #length of the impulse
+theta = -math.pi/2          #direction of propagation 
+
+#non-dim
+
+#define characteristic density, length, time, stress material
+rho_char = rhog
+length_char = lambda_wave
+c_char = c_g
+time_char = length_char/c_char
+stress_char = rho_char*c_char*c_char/gammag
+
+#non-dim the properties
+rhog_n  = rhog/rho_char    
+c_g_n = c_g/c_char    
+rhol_n = rhol/rho_char
+c_l_n = c_l/c_char
+Bg_n = Bg/stress_char
+Bl_n = Bl/stress_char
+G_g_n = G_g/stress_char
+G_l_n = G_l/stress_char
+patmos_n = patmos/stress_char
+P_amp_n = P_amp/stress_char
+
+#geometry
+dlengx = 10.
+dlengy = 2.
+Ny = 500
+Nx = dlengx*Ny
+dx = dlengx/Nx
+dy = dlengy/Ny
+alphal_back = 1.0
+alphag_back = 0.0
+alphal_lung = 0.0
+alphag_lung = 1.0
+
+interface_amp = 0.5
+
+# time stepping requirements
+time_end = 5
+cfl = 8.0
+
+dt = cfl * dx/c_l 
+Nt = int(time_end/dt)
+Nframes = 500
+tstart = 0
+tstop = Nt
+tsave = int(Nt/Nframes)
+
+# Configuring case dictionary
+print(json.dumps({
+    # Logistics ================================================================
+    'run_time_info'                : 'T',
+    # ==========================================================================
+
+    # Computational Domain Parameters ==========================================
+    'x_domain%beg'                 :  -dlengx/2.,
+    'x_domain%end'                 :  dlengx/2.,
+    'y_domain%beg'                 :  0.,
+    'y_domain%end'                 :  dlengy,
+    'm'                            : int(Nx),
+    'n'                            : int(Ny),
+    'p'                            : 0,
+    'dt'                           : dt,
+    't_step_start'                 : tstart,
+    't_step_stop'                  : tstop,
+    't_step_save'                  : tsave,
+    # ==========================================================================
+
+    # Simulation Algorithm Parameters ==========================================
+    'num_patches'                  : 2,
+    'model_eqns'                   : 2,
+    'alt_soundspeed'               : 'F',
+    'num_fluids'                   : 2,
+    'adv_alphan'                   : 'T',
+    'mpp_lim'                      : 'T',
+    'mixture_err'                  : 'T',
+    'time_stepper'                 : 3,
+    'weno_order'                   : 5,
+    'weno_eps'                     : 1.E-16,
+    'weno_Re_flux'                 : 'F',  
+    'weno_avg'                     : 'F',
+    'mapped_weno'                  : 'T',
+    'null_weights'                 : 'F',
+    'mp_weno'                      : 'T',
+    'riemann_solver'               : 2,
+    'wave_speeds'                  : 1,
+    'avg_state'                    : 2,
+    'bc_x%beg'                     : -6,
+    'bc_x%end'                     : -6,
+    'bc_y%beg'                     : -1,
+    'bc_y%end'                     : -1,
+    # ==========================================================================
+
+    # Formatted Database Files Structure Parameters ============================
+    'format'                       : 1,
+    'precision'                    : 2,
+    'prim_vars_wrt'                :'T',
+    'parallel_io'                  :'T',
+    # ==========================================================================
+ 
+    # Monopole setting =========================================================
+    'Monopole'                      : 'T',           # creating an acoustic wave
+    'num_mono'                      : 1,             # place in the middle and expand
+    'Mono(1)%pulse'                 : 3,             # square  wave
+    'Mono(1)%npulse'                : 1,             # 1 pulse
+    'Mono(1)%mag'                   : 100.0*patmos_n,# magnitude
+    'Mono(1)%length'                : 45.0*dlengy,   # pulse length
+    'Mono(1)%support'               : 2,             # 2D semi infinite plane (x: -inf,inf; y:-len/2, len/2)
+    'Mono(1)%support_width'         : 30,             
+    'Mono(1)%loc(1)'                : 0.7*dlengy,    # x_center of the domain
+    'Mono(1)%loc(2)'                : dlengy/2,      # upper boundary of the domain
+    'Mono(1)%dir'                   : -math.pi,      # direction: -pi/2
+   
+    # Patch 1: Background ======================================================
+    'patch_icpp(1)%geometry'       : 3,
+    'patch_icpp(1)%x_centroid'     : 0.,
+    'patch_icpp(1)%y_centroid'     : dlengy/2.,
+    'patch_icpp(1)%length_x'       : dlengx,
+    'patch_icpp(1)%length_y'       : dlengy,
+    'patch_icpp(1)%vel(1)'         : 0.,
+    'patch_icpp(1)%vel(2)'         : 0.E+00,
+    'patch_icpp(1)%pres'           : patmos_n,
+    'patch_icpp(1)%alpha_rho(1)'   : rhol_n*alphal_back,
+    'patch_icpp(1)%alpha_rho(2)'   : rhog_n*alphag_back,
+    'patch_icpp(1)%alpha(1)'       : alphal_back,
+    'patch_icpp(1)%alpha(2)'       : alphag_back,
+    # ==========================================================================
+
+    # Patch 2: Lung ============================================================
+    'patch_icpp(2)%geometry'       : 7,
+    'patch_icpp(2)%hcid'           : 206,
+    'patch_icpp(2)%alter_patch(1)' : 'T',
+    'patch_icpp(2)%x_centroid'     : -dlengx/4.,
+    'patch_icpp(2)%y_centroid'     : dlengy/2.,                  
+    'patch_icpp(2)%length_x'       : dlengx/2.+2,
+    'patch_icpp(2)%length_y'       : dlengy,                 
+    'patch_icpp(2)%a2'             : interface_amp,
+    'patch_icpp(2)%vel(1)'         : 0.E+00,
+    'patch_icpp(2)%vel(2)'         : 0.0,
+    'patch_icpp(2)%pres'           : patmos_n,
+    'patch_icpp(2)%alpha_rho(1)'   : rhol_n*alphal_lung,
+    'patch_icpp(2)%alpha_rho(2)'   : rhog_n*alphag_lung,
+    'patch_icpp(2)%alpha(1)'       : alphal_lung,
+    'patch_icpp(2)%alpha(2)'       : alphag_lung,
+    # ==========================================================================
+
+    # Fluids Physical Parameters ===============================================
+    'fluid_pp(1)%gamma'            : 1.E+00/(gammal-1.E+00),
+    'fluid_pp(1)%pi_inf'           : gammal*Bl_n/(gammal-1.E+00),
+    'fluid_pp(2)%gamma'            : 1.E+00/(gammag-1.E+00),
+    'fluid_pp(2)%pi_inf'           : gammag*Bg_n/(gammag-1.E+00),   
+ 
+ #==============================================================================
+}))
+
+# ==============================================================================
diff --git a/examples/2D_phasechange_bubble/case.py b/examples/2D_phasechange_bubble/case.py
new file mode 100644
index 00000000..5fbe5f83
--- /dev/null
+++ b/examples/2D_phasechange_bubble/case.py
@@ -0,0 +1,286 @@
+#!/usr/bin/env python3
+import math, json
+
+## 1 FOR BACKGROUND, 2 FOR BUBBLE
+# Pressure [Pa]
+p01 = 5E6
+p02 = 3550
+
+# Temperature [K]
+T01 = 298.15
+T02 = 298.15
+#T02 = 7.914
+
+#### FLUID PROPERTIES ####
+
+### liquid water ###
+# pi infty
+piwl = 1.0E+09
+# qv
+qvwl = -1167000
+# qv'
+qvpwl = 0.0E0
+# cv
+cvwl = 1816
+# cp
+cpwl = 4267
+# gamma
+gamwl = cpwl / cvwl
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0wl1 = (p01 + piwl)/((gamwl-1)*cvwl*T01)
+rho0wl2 = (p02 + piwl)/((gamwl-1)*cvwl*T02)
+
+# speed of sound FOR
+c_wl1 = math.sqrt( gamwl * ( p01 + piwl ) / rho0wl1 )
+c_wl2 = math.sqrt( gamwl * ( p02 + piwl ) / rho0wl2 )
+
+# part for Gases - relations from IMR
+Ru = 8.3144598         # Universal gas constant (J/mol-K)
+
+### Vapor water ###
+Rv = Ru/(18.01528e-3)  # Gas constant for vapor (Ru/molecular weight) (J/kg-K)
+# gamma
+gamwv = 1.4
+# cp
+cpwv = Rv * gamwv/(gamwv-1)
+# cv
+cvwv = cpwv/gamwv
+# pi infinity
+piwv = 0.0E0
+# qv
+qvwv = 2030000
+# qv'
+qvpwv = -23400
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0wv1 = (p01 + piwv)/((gamwv-1)*cvwv*T01)
+rho0wv2 = (p02 + piwv)/((gamwv-1)*cvwv*T02)
+
+# speed of sound
+c_wv1 = math.sqrt( gamwv * ( p01 + piwv ) / rho0wv1 )
+c_wv2 = math.sqrt( gamwv * ( p02 + piwv ) / rho0wv2 )
+
+### Air ###
+
+Ra = Ru/(28.966e-3)    # Gas constant for air (Ru/molecular weight) (J/kg-K)
+# gamma
+gama = 1.4
+# cp
+cpa = Ra * gama/(gama-1)
+# cv
+cva = cpa/gama
+# pi infinity
+pia = 0.0E0
+# qv
+qva = 0.0E0
+# qv'
+qvpa = 0.0E0
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0a1 = (p01 + pia)/((gama-1)*cva*T01)
+rho0a2 = (p02 + pia)/((gama-1)*cva*T02)
+
+# Speed of sound
+c_a1 = math.sqrt( gama * ( p01 + pia ) / rho0a1 )
+c_a2 = math.sqrt( gama * ( p02 + pia ) / rho0a2 )
+
+## SHOCK RELATIONS
+p02Op01 = p02 / p01
+
+# Mach number of the shocked region - this should agree with Min, if everything is correct
+Ms = math.sqrt( ( gama + 1. ) / ( 2. * gama ) * ( p02Op01 - 1. ) * ( p02 / ( p02 + pia ) ) + 1.0 )
+
+# shock speed
+ss = Ms * c_a1
+
+### volume fractions for each of the patches ###
+C0 = 0.25 # vapor concentration for IMR
+
+# water liquid
+awl1 = 1.00E00-2.00E-12
+awl2 = 1.00E-12
+# water vapor
+awv1 = 1.00E-12
+awv2 = 1 / ( ( 1 - C0 ) / C0 * rho0wv2 / rho0a2 + 1 )
+# air
+aa1 = 1.0 - awl1 - awv1
+aa2 = 1.0 - awl2 - awv2
+
+## SIMULATION PARAMETERS
+
+# CFL
+cfl = 0.50
+
+# Bubble Initial Radius
+R0 = 30E-06
+
+# number of elements
+Nx0 = 400
+Nx = 1600
+Ny = 1600
+Nz = 1600
+
+# domain boundaries
+xb = 0.00
+xe = 120E-6
+
+yb = 0.00
+ye = 120E-6
+
+zb = 0.00
+ze = 120E-6
+
+# typical cell size
+dx	= ( xe - xb ) / Nx
+dy	= ( ye - yb ) / Ny
+dz	= ( ze - zb ) / Nz
+
+# time step
+
+# save frequency = SF + 1 (because the initial state, 0.dat, is also saved)
+SF = 200
+
+# Critical time-step
+tc = 0.915 * R0 * math.sqrt( rho0wl1 / p01 )
+
+# making Nt divisible by SF
+# tendA = 1.5 * tc
+tend = 1.2 * tc
+
+# 1 - ensure NtA is sufficient to go a little beyond tendA
+# NtA = int( tendA // dt + 1 )
+
+# Array of saves. it is the same as Nt/Sf = t_step_save
+# AS = int( NtA // SF + 1 )
+
+# Nt = total number of steps. Ensure Nt > NtA (so the total tendA is covered)
+# Nt = AS * SF
+Nt = int(18E3 * tend // tc * Nx / Nx0 + 1)
+
+dt = tend / Nt
+
+AS = int( Nt//SF )
+
+# Total physical time
+# tend = Nt * dt
+
+# Configuring case dictionary ==================================================
+print(json.dumps({
+    # Logistics ================================================
+    'run_time_info': 'T',
+    # ==========================================================
+    # Computational Domain Parameters ==========================
+    'x_domain%beg' : xb,        
+    'x_domain%end' : xe,        
+    'y_domain%beg' : yb,        
+    'y_domain%end' : ye,
+    'stretch_x'    : 'T',
+    'loops_x'      : 3,
+    'a_x'          : 4.0E0,
+    'x_a'          : -2.0*R0,
+    'x_b'          :  2.0*R0,
+    'stretch_y'    : 'T',
+    'loops_y'      : 3,
+    'a_y'          : 4.0E0,
+    'y_a'          : -2.0*R0,
+    'y_b'          :  2.0*R0,
+    'cyl_coord'    : 'T',
+    'm'            : Nx,        
+    'n'            : Ny,        
+    'p'            : 0,         
+    'dt'           : dt,        
+    't_step_start' : 0,       
+    't_step_stop'  : Nt,      
+    't_step_save'  : AS,        
+    # ==========================================================
+    # Simulation Algorithm Parameters ==========================
+    'num_patches'  : 2,        
+    'model_eqns'   : 3,        
+    'num_fluids'   : 3,        
+    'adv_alphan'   : 'T',      
+    'mpp_lim'      : 'T',      
+    'mixture_err'  : 'T',      
+    'relax'        : 'T',  
+    'relax_model'  : 6,        
+    'palpha_eps'   : 1.0E-8,   
+    'ptgalpha_eps' : 1.0E-2,   
+    'time_stepper' : 3,        
+    'weno_order'   : 3,        
+    'weno_eps'     : 1.0E-16,
+    'weno_Re_flux' : 'F',  
+    'weno_avg'     : 'F',  
+    'mapped_weno'  : 'T',      
+    'null_weights' : 'F',      
+    'mp_weno'      : 'F',      
+    'riemann_solver' : 2,   
+    'wave_speeds'  : 1,        
+    'avg_state'    : 2,        
+    'bc_x%beg'     : -2,
+    'bc_x%end'     : -6,       
+    'bc_y%beg'     : -2,       
+    'bc_y%end'     : -6,
+    # ==========================================================
+    # Formatted Database Files Structure Parameters ============
+    'format'       : 1,        
+    'precision'    : 2,        
+    'prim_vars_wrt':'T',       
+    'parallel_io'  :'T',       
+    # ==========================================================
+    # Patch 1: High pressured water ============================
+    # Specify the cubic water background grid geometry
+    'patch_icpp(1)%geometry'       : 3,
+    'patch_icpp(1)%x_centroid'     : ( xe + xb ) * 500000 / 100,
+    'patch_icpp(1)%y_centroid'     : ( ye + yb ) * 500000 / 100,
+    'patch_icpp(1)%length_x'       : ( xe - xb ) * 1000000 / 100,
+    'patch_icpp(1)%length_y'       : ( ye - yb ) * 1000000 / 100,
+    'patch_icpp(1)%vel(1)'         : 0.0E+00,
+    'patch_icpp(1)%vel(2)'         : 0.0E+00,
+    'patch_icpp(1)%pres'           : p01,  	
+    'patch_icpp(1)%alpha_rho(1)'   : awl1 * rho0wl1,           	
+    'patch_icpp(1)%alpha_rho(2)'   : awv1 * rho0wv1,            
+    'patch_icpp(1)%alpha_rho(3)'   : aa1 * rho0a1,            
+    'patch_icpp(1)%alpha(1)'       : awl1,   	
+    'patch_icpp(1)%alpha(2)'       : awv1,   	
+    'patch_icpp(1)%alpha(3)'       : aa1,   	
+    # ==========================================================
+    # Patch 2: (Vapor) Bubble ==================================
+    'patch_icpp(2)%geometry'       : 2,     	
+    'patch_icpp(2)%x_centroid'     : xb,
+    'patch_icpp(2)%y_centroid'     : yb,
+    'patch_icpp(2)%radius'         : R0,
+    'patch_icpp(2)%vel(1)'         : 0.0E+00,
+    'patch_icpp(2)%vel(2)'         : 0.0E+00,
+    'patch_icpp(2)%pres'           : p02,    	
+    'patch_icpp(2)%alpha_rho(1)'   : awl2 * rho0wl2,           	
+    'patch_icpp(2)%alpha_rho(2)'   : awv2 * rho0wv2,           	
+    'patch_icpp(2)%alpha_rho(3)'   : aa2 * rho0a2,           	
+    'patch_icpp(2)%alpha(1)'       : awl2,   	
+    'patch_icpp(2)%alpha(2)'       : awv2,   	
+    'patch_icpp(2)%alpha(3)'       : aa2,   	
+    'patch_icpp(2)%alter_patch(1)' : 'T',
+    # ==========================================================
+    # Fluids Physical Parameters ===============================
+    'fluid_pp(1)%gamma'            : 1.0E+00 / ( gamwl - 1 ),       
+    'fluid_pp(1)%pi_inf'           : gamwl * piwl / ( gamwl - 1 ),  
+    'fluid_pp(1)%cv'          	   : cvwl,          
+    'fluid_pp(1)%qv'        	   : qvwl,	
+    'fluid_pp(1)%qvp'          	   : qvpwl,         
+    'fluid_pp(2)%gamma'            : 1.0E+00 / ( gamwv - 1 ),       
+    'fluid_pp(2)%pi_inf'           : gamwv * piwv / ( gamwv - 1 ),  
+    'fluid_pp(2)%cv'          	   : cvwv,          
+    'fluid_pp(2)%qv'        	   : qvwv,  	
+    'fluid_pp(2)%qvp'          	   : qvpwv,			
+    'fluid_pp(3)%gamma'            : 1.0E+00 / ( gama - 1 ),       
+    'fluid_pp(3)%pi_inf'           : gama * pia / ( gama - 1 ),  
+    'fluid_pp(3)%cv'          	   : cva,          
+    'fluid_pp(3)%qv'        	   : qva,  	
+    'fluid_pp(3)%qvp'          	   : qvpa,			
+    # ==========================================================
+}))
diff --git a/examples/2D_phasechange_bubble/casefile.py b/examples/2D_phasechange_bubble/casefile.py
new file mode 100644
index 00000000..722d0049
--- /dev/null
+++ b/examples/2D_phasechange_bubble/casefile.py
@@ -0,0 +1,300 @@
+#!/usr/bin/env python3
+import math, json
+
+## 1 FOR BACKGROUND, 2 FOR BUBBLE
+# Pressure [Pa]
+p01 = 5E6
+p02 = 3550
+
+# Temperature [K]
+T01 = 298.15
+T02 = 298.15
+#T02 = 7.914
+
+#### FLUID PROPERTIES ####
+
+### liquid water ###
+# pi infty
+piwl = 1.0E+09
+# qv
+qvwl = -1167000
+# qv'
+qvpwl = 0.0E0
+# cv
+cvwl = 1816
+# cp
+cpwl = 4267
+# gamma
+gamwl = cpwl / cvwl
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0wl1 = (p01 + piwl)/((gamwl-1)*cvwl*T01)
+rho0wl2 = (p02 + piwl)/((gamwl-1)*cvwl*T02)
+
+# speed of sound FOR
+c_wl1 = math.sqrt( gamwl * ( p01 + piwl ) / rho0wl1 )
+c_wl2 = math.sqrt( gamwl * ( p02 + piwl ) / rho0wl2 )
+
+# part for Gases - relations from IMR
+Ru = 8.3144598         # Universal gas constant (J/mol-K)
+
+### Vapor water ###
+Rv = Ru/(18.01528e-3)  # Gas constant for vapor (Ru/molecular weight) (J/kg-K)
+# gamma
+gamwv = 1.4
+# cp
+cpwv = Rv * gamwv/(gamwv-1)
+# cv
+cvwv = cpwv/gamwv
+# pi infinity
+piwv = 0.0E0
+# qv
+qvwv = 2030000
+# qv'
+qvpwv = -23400
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0wv1 = (p01 + piwv)/((gamwv-1)*cvwv*T01)
+rho0wv2 = (p02 + piwv)/((gamwv-1)*cvwv*T02)
+
+# speed of sound
+c_wv1 = math.sqrt( gamwv * ( p01 + piwv ) / rho0wv1 )
+c_wv2 = math.sqrt( gamwv * ( p02 + piwv ) / rho0wv2 )
+
+### Air ###
+
+Ra = Ru/(28.966e-3)    # Gas constant for air (Ru/molecular weight) (J/kg-K)
+# gamma
+gama = 1.4
+# cp
+cpa = Ra * gama/(gama-1)
+# cv
+cva = cpa/gama
+# pi infinity
+pia = 0.0E0
+# qv
+qva = 0.0E0
+# qv'
+qvpa = 0.0E0
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0a1 = (p01 + pia)/((gama-1)*cva*T01)
+rho0a2 = (p02 + pia)/((gama-1)*cva*T02)
+
+# Speed of sound
+c_a1 = math.sqrt( gama * ( p01 + pia ) / rho0a1 )
+c_a2 = math.sqrt( gama * ( p02 + pia ) / rho0a2 )
+
+## SHOCK RELATIONS
+p02Op01 = p02 / p01
+
+# Mach number of the shocked region - this should agree with Min, if everything is correct
+Ms = math.sqrt( ( gama + 1. ) / ( 2. * gama ) * ( p02Op01 - 1. ) * ( p02 / ( p02 + pia ) ) + 1.0 )
+
+# shock speed
+ss = Ms * c_a1
+
+### volume fractions for each of the patches ###
+C0 = 0.25 # vapor concentration for IMR
+
+# water liquid
+awl1 = 1.00E00-2.00E-12
+awl2 = 1.00E-12
+# water vapor
+awv1 = 1.00E-12
+awv2 = 1 / ( ( 1 - C0 ) / C0 * rho0wv2 / rho0a2 + 1 )
+# air
+aa1 = 1.0 - awl1 - awv1
+aa2 = 1.0 - awl2 - awv2
+
+## SIMULATION PARAMETERS
+
+# CFL
+cfl = 0.50
+
+# Bubble Initial Radius
+R0 = 30E-06
+
+# number of elements
+Nx0 = 400
+Nx = 100
+Ny = 100
+Nz = 100
+
+# domain boundaries
+xb = 0.00
+xe = 120E-6
+
+yb = 0.00
+ye = 120E-6
+
+zb = 0.00
+ze = 120E-6
+
+# typical cell size
+dx	= ( xe - xb ) / Nx
+dy	= ( ye - yb ) / Ny
+dz	= ( ze - zb ) / Nz
+
+# time step
+
+# save frequency = SF + 1 (because the initial state, 0.dat, is also saved)
+SF = 200
+
+# Critical time-step
+tc = 0.915 * R0 * math.sqrt( rho0wl1 / p01 )
+
+# making Nt divisible by SF
+# tendA = 1.5 * tc
+tend = 1.2 * tc
+
+# 1 - ensure NtA is sufficient to go a little beyond tendA
+# NtA = int( tendA // dt + 1 )
+
+# Array of saves. it is the same as Nt/Sf = t_step_save
+# AS = int( NtA // SF + 1 )
+
+# Nt = total number of steps. Ensure Nt > NtA (so the total tendA is covered)
+# Nt = AS * SF
+Nt = int(18E3 * tend // tc * Nx / Nx0 + 1)
+
+dt = tend / Nt
+
+AS = int( Nt//SF )
+
+# Total physical time
+# tend = Nt * dt
+
+# Configuring case dictionary ==================================================
+print(json.dumps({
+    # Logistics ================================================
+    'run_time_info': 'T',
+    # ==========================================================
+    # Computational Domain Parameters ==========================
+    'x_domain%beg' : xb,        
+    'x_domain%end' : xe,        
+    'y_domain%beg' : yb,        
+    'y_domain%end' : ye,
+    'z_domain%beg' : zb,        
+    'z_domain%end' : ze,
+    'stretch_x'    : 'T',
+    'loops_x'      : 3,
+    'a_x'          : 4.0E0,
+    'x_a'          : -2.0*R0,
+    'x_b'          :  2.0*R0,
+    'stretch_y'    : 'T',
+    'loops_y'      : 3,
+    'a_y'          : 4.0E0,
+    'y_a'          : -2.0*R0,
+    'y_b'          :  2.0*R0,
+    'stretch_z'    : 'T',
+    'loops_z'      : 3,
+    'a_z'          : 4.0E0,
+    'z_a'          : -2.0*R0,
+    'z_b'          :  2.0*R0,
+    'cyl_coord'    : 'F',
+    'm'            : Nx,        
+    'n'            : Ny,        
+    'p'            : Nz,         
+    'dt'           : dt,        
+    't_step_start' : 0,       
+    't_step_stop'  : Nt,      
+    't_step_save'  : AS,        
+    # ==========================================================
+    # Simulation Algorithm Parameters ==========================
+    'num_patches'  : 2,        
+    'model_eqns'   : 3,        
+    'num_fluids'   : 3,        
+    'adv_alphan'   : 'T',      
+    'mpp_lim'      : 'T',      
+    'mixture_err'  : 'T',      
+    'relax'        : 'T',  
+    'relax_model'  : 6,        
+    'palpha_eps'   : 1.0E-6,   
+    'ptgalpha_eps' : 1.0E-2,   
+    'time_stepper' : 3,        
+    'weno_order'   : 3,        
+    'weno_eps'     : 1.0E-32,
+    'weno_Re_flux' : 'F',  
+    'weno_avg'     : 'F',  
+    'mapped_weno'  : 'T',      
+    'null_weights' : 'F',      
+    'mp_weno'      : 'F',      
+    'riemann_solver' : 2,   
+    'wave_speeds'  : 1,        
+    'avg_state'    : 2,        
+    'bc_x%beg'     : -2,
+    'bc_x%end'     : -6,       
+    'bc_y%beg'     : -2,       
+    'bc_y%end'     : -6,
+    'bc_z%beg'     : -2,       
+    'bc_z%end'     : -6,
+    # ==========================================================
+    # Formatted Database Files Structure Parameters ============
+    'format'       : 1,        
+    'precision'    : 2,        
+    'prim_vars_wrt':'T',       
+    'parallel_io'  :'T',       
+    # ==========================================================
+    # Patch 1: High pressured water ============================
+    # Specify the cubic water background grid geometry
+    'patch_icpp(1)%geometry'       : 9,
+    'patch_icpp(1)%x_centroid'     : ( xe + xb ) * 500000 / 100,
+    'patch_icpp(1)%y_centroid'     : ( ye + yb ) * 500000 / 100,
+    'patch_icpp(1)%z_centroid'     : ( ze + zb ) * 500000 / 100,
+    'patch_icpp(1)%length_x'       : ( xe - xb ) * 1000000 / 100,
+    'patch_icpp(1)%length_y'       : ( ye - yb ) * 1000000 / 100,
+    'patch_icpp(1)%length_z'       : ( ze - zb ) * 1000000 / 100,
+    'patch_icpp(1)%vel(1)'         : 0.0E+00,
+    'patch_icpp(1)%vel(2)'         : 0.0E+00,
+    'patch_icpp(1)%vel(3)'         : 0.0E+00,
+    'patch_icpp(1)%pres'           : p01,  	
+    'patch_icpp(1)%alpha_rho(1)'   : awl1 * rho0wl1,           	
+    'patch_icpp(1)%alpha_rho(2)'   : awv1 * rho0wv1,            
+    'patch_icpp(1)%alpha_rho(3)'   : aa1 * rho0a1,            
+    'patch_icpp(1)%alpha(1)'       : awl1,   	
+    'patch_icpp(1)%alpha(2)'       : awv1,   	
+    'patch_icpp(1)%alpha(3)'       : aa1,   	
+    # ==========================================================
+    # Patch 2: (Vapor) Bubble ==================================
+    'patch_icpp(2)%geometry'       : 8,     	
+    'patch_icpp(2)%x_centroid'     : xb,
+    'patch_icpp(2)%y_centroid'     : yb,
+    'patch_icpp(2)%z_centroid'     : zb,
+    'patch_icpp(2)%radius'         : R0,
+    'patch_icpp(2)%vel(1)'         : 0.0E+00,
+    'patch_icpp(2)%vel(2)'         : 0.0E+00,
+    'patch_icpp(2)%vel(3)'         : 0.0E+00,
+    'patch_icpp(2)%pres'           : p02,    	
+    'patch_icpp(2)%alpha_rho(1)'   : awl2 * rho0wl2,           	
+    'patch_icpp(2)%alpha_rho(2)'   : awv2 * rho0wv2,           	
+    'patch_icpp(2)%alpha_rho(3)'   : aa2 * rho0a2,           	
+    'patch_icpp(2)%alpha(1)'       : awl2,   	
+    'patch_icpp(2)%alpha(2)'       : awv2,   	
+    'patch_icpp(2)%alpha(3)'       : aa2,   	
+    'patch_icpp(2)%alter_patch(1)' : 'T',
+    # ==========================================================
+    # Fluids Physical Parameters ===============================
+    'fluid_pp(1)%gamma'            : 1.0E+00 / ( gamwl - 1 ),       
+    'fluid_pp(1)%pi_inf'           : gamwl * piwl / ( gamwl - 1 ),  
+    'fluid_pp(1)%cv'          	   : cvwl,          
+    'fluid_pp(1)%qv'        	   : qvwl,	
+    'fluid_pp(1)%qvp'          	   : qvpwl,         
+    'fluid_pp(2)%gamma'            : 1.0E+00 / ( gamwv - 1 ),       
+    'fluid_pp(2)%pi_inf'           : gamwv * piwv / ( gamwv - 1 ),  
+    'fluid_pp(2)%cv'          	   : cvwv,          
+    'fluid_pp(2)%qv'        	   : qvwv,  	
+    'fluid_pp(2)%qvp'          	   : qvpwv,			
+    'fluid_pp(3)%gamma'            : 1.0E+00 / ( gama - 1 ),       
+    'fluid_pp(3)%pi_inf'           : gama * pia / ( gama - 1 ),  
+    'fluid_pp(3)%cv'          	   : cva,          
+    'fluid_pp(3)%qv'        	   : qva,  	
+    'fluid_pp(3)%qvp'          	   : qvpa,			
+    # ==========================================================
+}))
diff --git a/examples/3D_CAV/3D_CAV_sph_col.py b/examples/3D_CAV/3D_CAV_sph_col.py
new file mode 100644
index 00000000..a54df0a5
--- /dev/null
+++ b/examples/3D_CAV/3D_CAV_sph_col.py
@@ -0,0 +1,205 @@
+import math
+import json
+
+
+## Deine characteristic values for the sim
+Ri = 50E-6
+T = 407.9
+rhog = 0.027
+Pb = 3550 
+Pl = 101325
+#mulc = 9E-04
+#mubc = 1.0E-05
+domain_length = 3*Ri
+
+
+## fluid properties
+Pi_inf_l = 1.0E+09
+Pi_inf_b = 0.0E+00
+nl = 2.35
+nb = 1.47
+alpha1 = 1.0E+00
+Cv_l = 1816
+rhol = (Pl+Pi_inf_l)/((nl-1)*Cv_l*T)
+alpha2 = alpha1
+cl = (nl*(Pl+Pi_inf_l)/rhol)**(0.5)
+
+## Defining Characteristic Values 
+Rc = Ri
+rhoc = rhol
+uc = (Pl/rhol)**(0.5E+00)
+tc = Ri/uc
+Pc = rhoc*uc**(2.0E+00)
+
+## Non-Dimensionalizing values using characteristic values
+Rin = Ri/Rc
+rholn = rhol/rhoc
+rhogn = rhog/rhoc
+Pln = Pl/Pc
+Pbn = Pb/Pc
+tcn = tc/tc
+Pi_inf_ln = Pi_inf_l/Pc
+leng = domain_length/Rc
+clc = cl/uc
+
+
+## Non-Dimensional Numbers
+#Rel = rhol*uc*2*Rin/mulc
+#Reb = rhog*uc*2*Rin/mubc
+Ma = uc/cl
+
+## Grid Specifications
+CFL = 0.1	 
+PpBr = 192
+Nx = PpBr*leng
+Ny = Nx
+Nz = Nx
+x_beg = 0.0E+00  
+x_end = leng
+y_beg = 0.0E+00
+y_end = leng
+z_beg = 0.0E+00
+z_end = leng
+delta_x = leng/Nx
+delta_t = CFL*delta_x/clc
+Nt = int(1.1*tcn/delta_t)
+x_centroidl = (x_end+x_beg)/(2.0E+00)
+y_centroidl = (y_end+y_beg)/(2.0E+00)
+z_centroidl = (z_end+z_beg)/(2.0E+00)
+x_centroidb = 0.0E+00
+y_centroidb = 0.0E+00
+z_centroidb = 0.0E+00
+
+
+# Configuring case dictionary
+print(json.dumps({
+    # Logistics ================================================
+    'run_time_info'                : 'T',
+    'sim_data'                     : 'T',
+    # ==========================================================
+
+    # Computational Domain Parameters ==========================
+    'x_domain%beg'                 : x_beg,
+    'x_domain%end'                 : x_end,
+    'y_domain%beg'                 : y_beg,
+    'y_domain%end'                 : y_end,
+    'z_domain%beg'                 : z_beg,
+    'z_domain%end'                 : z_end,
+    'm'                            : int(Nx),
+    'n'                            : int(Ny),
+    'p'                            : int(Nz),
+    'cyl_coord'                    : 'F',
+    'dt'                           : delta_t,
+    't_step_start'                 : 0, 
+    't_step_stop'                  : Nt,
+    't_step_save'                  : int(Nt/360),
+# ==========================================================
+
+    # Simulation Algorithm Parameters ==========================
+    'num_patches'                  : 2,
+    'model_eqns'                   : 2,
+    'alt_soundspeed'               : 'F',
+    'num_fluids'                   : 2,
+    'adv_alphan'                   : 'T',
+    'mpp_lim'                      : 'T',
+    'mixture_err'                  : 'T',
+    'time_stepper'                 : 3,
+    'weno_order'                   : 5,
+    'weno_eps'                     : 1.E-100,
+    'mapped_weno'                  : 'T',
+    'null_weights'                 : 'F',
+    'mp_weno'                      : 'F',
+    'weno_Re_flux'                 : 'F',
+    'weno_avg'                     : 'F',
+    'riemann_solver'               : 2,
+    'wave_speeds'                  : 1,
+    'avg_state'                    : 2,
+    'bc_x%beg'                     : -2,
+    'bc_x%end'                     : -6,
+    'bc_y%beg'                     : -2,
+    'bc_y%end'                     : -6,
+    'bc_z%beg'                     : -2,
+    'bc_z%end'                     : -6,
+    'stretch_x'                    : 'T',
+    'stretch_y'                    : 'T',
+    'stretch_z'                    : 'T',
+    'a_x'                          : 4.0E+00,
+    'x_a'                          : -1.5E+00,                         
+    'x_b'                          : 1.5E+00,
+    'a_y'                          : 4.0E+00,
+    'y_a'                          : -1.5E+00,
+    'y_b'                          : 1.5E+00,
+    'a_z'                          : 4.0E+00,
+    'z_a'                          : -1.5E+00,
+    'z_b'                          : 1.5E+00,
+    # ==========================================================
+
+    # Formatted Database Files Structure Parameters ============
+    'format'                       : 1,
+    'precision'                    : 2,
+    'prim_vars_wrt'                :'T',
+    'parallel_io'                  :'T',
+    'fd_order'			   :'1',
+    'probe_wrt'			   :'T',
+    'num_probes'		   : 1,
+    'probe(1)%x'                   : 0.,
+    'probe(1)%y'		   : 0.,
+    'probe(1)%z'                   : 0.,
+    # ==========================================================
+
+    # Patch 1: Background  ============================
+    'patch_icpp(1)%geometry'       : 9,
+    'patch_icpp(1)%x_centroid'     : 40*x_centroidl,
+    'patch_icpp(1)%y_centroid'     : 40*y_centroidl,
+    'patch_icpp(1)%z_centroid'     : 40*z_centroidl,
+    'patch_icpp(1)%length_x'       : 40*leng,
+    'patch_icpp(1)%length_y'       : 40*leng,
+    'patch_icpp(1)%length_z'       : 40*leng,
+    'patch_icpp(1)%vel(1)'         : 0.E+00,
+    'patch_icpp(1)%vel(2)'         : 0.E+00,
+    'patch_icpp(1)%vel(3)'         : 0.E+00,
+    'patch_icpp(1)%pres'           : Pln,
+    'patch_icpp(1)%alpha_rho(1)'   : alpha1*rholn,
+    'patch_icpp(1)%alpha_rho(2)'   : 0.0E+00,
+    'patch_icpp(1)%alpha(1)'       : alpha1,
+    'patch_icpp(1)%alpha(2)'       : 0.0E+00,
+    # ==========================================================
+    # Patch 2: Bubble  ======================================
+    'patch_icpp(2)%geometry'       : 14,
+    'patch_icpp(2)%x_centroid'     : x_centroidb,
+    'patch_icpp(2)%y_centroid'     : y_centroidb,
+    'patch_icpp(2)%z_centroid'     : z_centroidb, 
+    'patch_icpp(2)%radius'         : Rin,
+    'patch_icpp(2)%smoothen'       : 'T',
+    'patch_icpp(2)%smooth_patch_id': 1,
+    'patch_icpp(2)%smooth_coeff'   : 1.5E+00,
+    'patch_icpp(2)%non_axis_sym'   : 'F',
+    'patch_icpp(2)%a2'             : 0.0E+00,
+    'patch_icpp(2)%a3'             : 0.0E+00,
+    'patch_icpp(2)%a4'             : 0.0E+00,
+    'patch_icpp(2)%a5'             : 0.0E+00,
+    'patch_icpp(2)%a6'             : 0.0E+00,
+    'patch_icpp(2)%a7'             : 0.0E+00,
+    'patch_icpp(2)%alter_patch(1)' : 'T',
+    'patch_icpp(2)%vel(1)'         : 0.E+00,
+    'patch_icpp(2)%vel(2)'         : 0.E+00,
+    'patch_icpp(2)%vel(3)'         : 0.E+00,
+    'patch_icpp(2)%pres'           : Pbn,
+    'patch_icpp(2)%alpha_rho(1)'   : 0.0E+00,
+    'patch_icpp(2)%alpha_rho(2)'   : alpha2*rhogn,
+    'patch_icpp(2)%alpha(1)'       : 0.0E+00,
+    'patch_icpp(2)%alpha(2)'       : alpha2,
+    # ==========================================================
+
+    # Fluids Physical Parameters ===============================
+    'fluid_pp(1)%gamma'            : 1/(nl-1),
+    'fluid_pp(1)%pi_inf'           : nl*Pi_inf_ln/(nl-1),
+    'fluid_pp(2)%gamma'            : 1/(nb-1),
+    'fluid_pp(2)%pi_inf'           : 0.0E+00,
+#    'fluid_pp(1)%Re(1)'            : Rel,
+#    'fluid_pp(2)%Re(1)'            : Reb,
+    # ==========================================================
+}))
+
+# ==============================================================================
+
diff --git a/examples/3D_ctr_test/case.py b/examples/3D_ctr_test/case.py
new file mode 100644
index 00000000..aac9ec36
--- /dev/null
+++ b/examples/3D_ctr_test/case.py
@@ -0,0 +1,399 @@
+#!/usr/bin/env python3
+import math, json
+
+## 1 FOR BACKGROUND, 2 FOR BUBBLE, 3 FOR GEL
+# Pressure [Pa]
+p01 = 5E6
+p02 = 3550
+p03 = p01
+
+# Temperature [K]
+T01 = 298.15
+T02 = 298.15
+T03 = T01
+
+#### FLUID PROPERTIES ####
+
+### liquid water ###
+# pi infty
+piwl = 1.0E+09
+# qv
+qvwl = -1167000
+# qv'
+qvpwl = 0.0E0
+# cv
+cvwl = 1816
+# cp
+cpwl = 4267
+# gamma
+gamwl = cpwl / cvwl
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0wl1 = (p01 + piwl)/((gamwl-1)*cvwl*T01)
+rho0wl2 = (p02 + piwl)/((gamwl-1)*cvwl*T02)
+rho0wl3 = (p03 + piwl)/((gamwl-1)*cvwl*T03)
+
+# speed of sound FOR
+c_wl1 = math.sqrt( gamwl * ( p01 + piwl ) / rho0wl1 )
+c_wl2 = math.sqrt( gamwl * ( p02 + piwl ) / rho0wl2 )
+c_wl3 = math.sqrt( gamwl * ( p03 + piwl ) / rho0wl3 )
+
+# part for Gases - relations from IMR
+Ru = 8.3144598         # Universal gas constant (J/mol-K)
+
+### Vapor water ###
+Rv = Ru/(18.01528e-3)  # Gas constant for vapor (Ru/molecular weight) (J/kg-K)
+# gamma
+gamwv = 1.4
+# cp
+cpwv = Rv * gamwv/(gamwv-1)
+# cv
+cvwv = cpwv/gamwv
+# pi infinity
+piwv = 0.0E0
+# qv
+qvwv = 2030000
+# qv'
+qvpwv = -23400
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0wv1 = (p01 + piwv)/((gamwv-1)*cvwv*T01)
+rho0wv2 = (p02 + piwv)/((gamwv-1)*cvwv*T02)
+rho0wv3 = (p03 + piwv)/((gamwv-1)*cvwv*T03)
+
+# speed of sound
+c_wv1 = math.sqrt( gamwv * ( p01 + piwv ) / rho0wv1 )
+c_wv2 = math.sqrt( gamwv * ( p02 + piwv ) / rho0wv2 )
+c_wv3 = math.sqrt( gamwv * ( p03 + piwv ) / rho0wv3 )
+
+### Air ###
+
+Ra = Ru/(28.966e-3)     # Gas constant for air (Ru/molecular weight) (J/kg-K)
+gamwa = 1.4
+# cp
+cpa = Ra * gamwa/(gamwa-1)
+# cv
+cva = cpa/gamwa
+# pi infinity
+pia = 0.0E0
+# qv
+qvwa = 0.0E0
+# qv'
+qvpwa = 0.0E0
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0wa1 = (p01 + pia)/((gamwa-1)*cva*T01)
+rho0wa2 = (p02 + pia)/((gamwa-1)*cva*T02)
+
+# Speed of sound
+c_a1 = math.sqrt( gamwa * ( p01 + pia ) / rho0wa1 )
+c_a2 = math.sqrt( gamwa * ( p02 + pia ) / rho0wa2 )
+
+### 3% polyacrylamide gel ###
+# gamma
+gamwg = 2.35
+# pi infty
+pig = 1.0E+09
+# qv
+qvwg = -1167000
+# qv'
+qvpwg = 0.0E0
+# cv
+cvg = 1816
+# cp
+cpg = gamwg*cvg
+
+## FOR PATCHES 1 & 2 & 3 ##
+
+# density
+rho0wg1 = (p01 + pig)/((gamwg-1)*cvg*T01)
+rho0wg2 = (p02 + pig)/((gamwg-1)*cvg*T02)
+rho0wg3 = (p03 + pig)/((gamwg-1)*cvg*T03)
+
+# Speed of sound
+c_g1 = math.sqrt( gamwg * ( p01 + pig ) / rho0wg1 )
+c_g2 = math.sqrt( gamwg * ( p02 + pig ) / rho0wg2 )
+c_g3 = math.sqrt( gamwg * ( p03 + pig ) / rho0wg3 )
+
+## SHOCK RELATIONS
+p02Op01 = p02 / p01
+
+# Mach number of the shocked region - this should agree with Min, if everything is correct
+Ms = math.sqrt( ( gamwa + 1. ) / ( 2. * gamwa ) * ( p02Op01 - 1. ) * ( p02 / ( p02 + pia ) ) + 1.0 )
+
+# shock speed
+ss = Ms * c_a1
+
+### volume fractions for each of the patches ###
+C0 = 0.5 # vapor concentration for IMR
+
+# patch 1: liquid water
+liq_wv = 1.00E-15
+liq_wg = 0.
+liq_wa = 1.00E-15
+liq_wl = 1.00E00 - liq_wv - liq_wa - liq_wg
+# water vapor
+vap_wl = 1.00E-15
+vap_wv = 1 / ( ( 1 - C0 ) / C0 * rho0wv2 / rho0wa2 + 1 )
+vap_wg = 0.
+vap_wa = 1.00E-15
+vap_tot = vap_wl + vap_wv + vap_wa + vap_wg
+# bub
+bub_wl = 1.00E-15
+bub_wv = vap_tot
+bub_wg = 0.
+bub_wa = 1.00E00 - bub_wl - bub_wv - bub_wg
+# gel
+gel_wv = 0.
+gel_wl = 0.
+gel_wa = 0.
+gel_wg = 1.00E00 - gel_wl - gel_wv - gel_wa
+
+## SIMULATION PARAMETERS
+
+# CFL
+cfl = 0.50
+
+# Bubble Initial Radius
+R0 = 230.4E-06
+
+# number of elements
+Nx0 = 400
+Nx = 399
+Ny = 199
+Nz = 199
+
+lref = 921.6E-6
+# domain boundaries
+xb = -lref
+xe = lref
+
+yb = 0.00
+ye = lref
+
+zb = 0.00
+ze = lref
+
+lenx = ( xe - xb )
+leny = ( ye - yb )
+lenz = ( ze - zb )
+
+xcenl = (xb + xe)/2.0
+ycenl = (yb + ye)/2.0 
+zcenl = (zb + ze)/2.0
+
+#xdist = 6.51E-10 #2.17E-5
+#sod = xdist/R0
+sod = -2.17
+xcenb = sod*R0 
+ycenb = 0.00
+zcenb = 0.00
+
+xbg = 0
+xeg = xe
+
+lenxg = (xeg - xbg)
+lenyg = leny
+lenzg = lenz
+xceng = (xbg + xeg)/2.0
+yceng = ycenl
+zceng = zcenl
+
+# typical cell size
+dx = ( xe - xb ) / Nx
+dy = ( ye - yb ) / Ny
+dz = ( ze - zb ) / Nz
+#print(dx)
+# time step
+
+# save frequency = SF + 1 (because the initial state, 0.dat, is also saved)
+SF = 60
+
+# Critical time-step
+tc = 0.915 * R0 * math.sqrt( rho0wl1 / p01 )
+
+# making Nt divisible by SF
+# tendA = 1.5 * tc
+tend = 1.2 * tc
+
+# 1 - ensure NtA is sufficient to go a little beyond tendA
+# NtA = int( tendA // dt + 1 )
+
+# Array of saves. it is the same as Nt/Sf = t_step_save
+# AS = int( NtA // SF + 1 )
+
+# Nt = total number of steps. Ensure Nt > NtA (so the total tendA is covered)
+# Nt = AS * SF
+Nt = int(10E3 * tend // tc * Nx / Nx0 + 1)
+#print(Nt)
+dt = tend / Nt
+
+AS = int( Nt//SF )
+
+# Total physical time
+# tend = Nt * dt
+
+# Configuring case dictionary ==================================================
+print(json.dumps({
+    # Logistics ================================================
+    'run_time_info': 'T',
+    # ==========================================================
+    # Computational Domain Parameters ==========================
+    'x_domain%beg' : xb,        
+    'x_domain%end' : xe,        
+    'y_domain%beg' : yb,        
+    'y_domain%end' : ye,
+    'z_domain%beg' : zb,
+    'z_domain%end' : ze,
+    'stretch_x'    : 'F',
+    'loops_x'      : 1,
+    'a_x'          : 4.0E0,
+    'x_a'          : -2.0*R0,
+    'x_b'          :  2.0*R0,
+    'stretch_y'    : 'F',
+    'loops_y'      : 1,
+    'a_y'          : 4.0E0,
+    'y_a'          : -2.0*R0,
+    'y_b'          :  2.0*R0,
+    'stretch_z'    : 'F',
+    'loops_z'      : 1,
+    'a_z'          : 4.0E0,
+    'z_a'          : -2.0*R0,
+    'z_b'          : 2.0*R0,
+    'cyl_coord'    : 'F',
+    'm'            : Nx,        
+    'n'            : Ny,        
+    'p'            : Nz,         
+    'dt'           : dt,        
+    't_step_start' : 0,       
+    't_step_stop'  : Nt,      
+    't_step_save'  : AS,        
+    # ==========================================================
+    # Simulation Algorithm Parameters ==========================
+    'num_patches'  : 3,        
+    'model_eqns'   : 3,        
+    'num_fluids'   : 4,        
+    'adv_alphan'   : 'T',      
+    'mpp_lim'      : 'T',      
+    'mixture_err'  : 'T',      
+    'relax'        : 'T',  
+    'relax_model'  : 6,        
+    'palpha_eps'   : 1.0E-6,   
+    'ptgalpha_eps' : 1.0E-2,   
+    'time_stepper' : 3,        
+    'weno_order'   : 3,        
+    'weno_eps'     : 1.0E-16,
+    'weno_Re_flux' : 'F',  
+    'weno_avg'     : 'F',  
+    'mapped_weno'  : 'T',      
+    'null_weights' : 'F',      
+    'mp_weno'      : 'F',      
+    'riemann_solver' : 2,   
+    'wave_speeds'  : 1,        
+    'avg_state'    : 2,        
+    'bc_x%beg'     : -6, #-2,
+    'bc_x%end'     : -6,       
+    'bc_y%beg'     : -2,       
+    'bc_y%end'     : -6,
+    'bc_z%beg'     : -2,
+    'bc_z%end'     : -6,
+    # ==========================================================
+    # Formatted Database Files Structure Parameters ============
+    'format'       : 1,        
+    'precision'    : 2,        
+    'prim_vars_wrt':'T',       
+    'parallel_io'  :'T',       
+    # ==========================================================
+    # Patch 1: High pressured water ============================
+    # Specify the cubic water background grid geometry
+    'patch_icpp(1)%geometry'       : 9,
+    'patch_icpp(1)%x_centroid'     : xcenl,
+    'patch_icpp(1)%y_centroid'     : ycenl,
+    'patch_icpp(1)%z_centroid'     : zcenl,
+    'patch_icpp(1)%length_x'       : lenx,
+    'patch_icpp(1)%length_y'       : leny,
+    'patch_icpp(1)%length_z'       : lenz,
+    'patch_icpp(1)%vel(1)'         : 0.0E+00,
+    'patch_icpp(1)%vel(2)'         : 0.0E+00,
+    'patch_icpp(1)%vel(3)'         : 0.0E+00,
+    'patch_icpp(1)%pres'           : p01,  	
+    'patch_icpp(1)%alpha_rho(1)'   : liq_wl * rho0wl1,           	
+    'patch_icpp(1)%alpha_rho(2)'   : liq_wv * rho0wv1,            
+    'patch_icpp(1)%alpha_rho(3)'   : liq_wa * rho0wa1,
+    'patch_icpp(1)%alpha_rho(4)'   : liq_wg * rho0wg1,            
+    'patch_icpp(1)%alpha(1)'       : liq_wl,   	
+    'patch_icpp(1)%alpha(2)'       : liq_wv,   	
+    'patch_icpp(1)%alpha(3)'       : liq_wa,
+    'patch_icpp(1)%alpha(4)'       : liq_wg,   	
+    # ==========================================================
+    # Patch 2: (Vapor) Bubble ==================================
+    'patch_icpp(2)%geometry'       : 8,     	
+    'patch_icpp(2)%x_centroid'     : xcenb,
+    'patch_icpp(2)%y_centroid'     : ycenb,
+    'patch_icpp(2)%z_centroid'     : zcenb,
+    'patch_icpp(2)%radius'         : R0,
+    'patch_icpp(2)%vel(1)'         : 0.0E+00,
+    'patch_icpp(2)%vel(2)'         : 0.0E+00,
+    'patch_icpp(2)%vel(3)'         : 0.0E+00,
+    'patch_icpp(2)%pres'           : p02,    	
+    'patch_icpp(2)%alpha_rho(1)'   : bub_wl * rho0wl2,           	
+    'patch_icpp(2)%alpha_rho(2)'   : bub_wv * rho0wv2,           	
+    'patch_icpp(2)%alpha_rho(3)'   : bub_wa * rho0wa2,           
+    'patch_icpp(2)%alpha_rho(4)'   : bub_wg * rho0wg2,
+    'patch_icpp(2)%alpha(1)'       : bub_wl,   	
+    'patch_icpp(2)%alpha(2)'       : bub_wv,   	
+    'patch_icpp(2)%alpha(3)'       : bub_wa,
+    'patch_icpp(2)%alpha(4)'       : bub_wg,
+    'patch_icpp(2)%alter_patch(1)' : 'T',
+    # ==========================================================
+    # Patch 3: Gel Object ======================================
+    'patch_icpp(3)%geometry'       : 9,     	
+    'patch_icpp(3)%x_centroid'     : xceng,
+    'patch_icpp(3)%y_centroid'     : yceng,
+    'patch_icpp(3)%z_centroid'     : zceng,
+    'patch_icpp(3)%length_x'       : lenxg,
+    'patch_icpp(3)%length_y'       : lenyg,
+    'patch_icpp(3)%length_z'       : lenzg,
+    'patch_icpp(3)%vel(1)'         : 0.0E+00,
+    'patch_icpp(3)%vel(2)'         : 0.0E+00,
+    'patch_icpp(3)%vel(3)'         : 0.0E+00,
+    'patch_icpp(3)%pres'           : p03,    	
+    'patch_icpp(3)%alpha_rho(1)'   : gel_wl * rho0wl2,           	
+    'patch_icpp(3)%alpha_rho(2)'   : gel_wv * rho0wv2,           	
+    'patch_icpp(3)%alpha_rho(3)'   : gel_wa * rho0wa2,
+    'patch_icpp(3)%alpha_rho(4)'   : gel_wg * rho0wg2,           	
+    'patch_icpp(3)%alpha(1)'       : gel_wl,   	
+    'patch_icpp(3)%alpha(2)'       : gel_wv,   	
+    'patch_icpp(3)%alpha(3)'       : gel_wa,
+    'patch_icpp(3)%alpha(4)'       : gel_wg,	
+    'patch_icpp(3)%alter_patch(1)' : 'T',
+    # ==========================================================
+    # Fluids Physical Parameters ===============================
+    'fluid_pp(1)%gamma'            : 1.0E+00 / ( gamwl - 1 ),       
+    'fluid_pp(1)%pi_inf'           : gamwl * piwl / ( gamwl - 1 ),  
+    'fluid_pp(1)%cv'          	   : cvwl,          
+    'fluid_pp(1)%qv'        	   : qvwl,	
+    'fluid_pp(1)%qvp'          	   : qvpwl,         
+    'fluid_pp(2)%gamma'            : 1.0E+00 / ( gamwv - 1 ),       
+    'fluid_pp(2)%pi_inf'           : gamwv * piwv / ( gamwv - 1 ),  
+    'fluid_pp(2)%cv'          	   : cvwv,          
+    'fluid_pp(2)%qv'        	   : qvwv,  	
+    'fluid_pp(2)%qvp'          	   : qvpwv,			
+    'fluid_pp(3)%gamma'            : 1.0E+00 / ( gamwa - 1 ),       
+    'fluid_pp(3)%pi_inf'           : gamwa * pia / ( gamwa - 1 ),  
+    'fluid_pp(3)%cv'          	   : cva,          
+    'fluid_pp(3)%qv'        	   : qvwa,  	
+    'fluid_pp(3)%qvp'          	   : qvpwa,
+    'fluid_pp(4)%gamma'            : 1.0E+00 / ( gamwg - 1),
+    'fluid_pp(4)%pi_inf'           : gamwg * pig / ( gamwg - 1),
+    'fluid_pp(4)%cv'               : cvg,
+    'fluid_pp(4)%qv'               : qvwg,
+    'fluid_pp(4)%qvp'              : qvpwg,			
+    # ==========================================================
+}))
diff --git a/examples/3D_ctr_test/old_case.py b/examples/3D_ctr_test/old_case.py
new file mode 100644
index 00000000..092c0213
--- /dev/null
+++ b/examples/3D_ctr_test/old_case.py
@@ -0,0 +1,399 @@
+#!/usr/bin/env python3
+import math, json
+
+## 1 FOR BACKGROUND, 2 FOR BUBBLE, 3 FOR GEL
+# Pressure [Pa]
+p01 = 5E6
+p02 = 3550
+p03 = p01
+
+# Temperature [K]
+T01 = 298.15
+T02 = 298.15
+T03 = T01
+
+#### FLUID PROPERTIES ####
+
+### liquid water ###
+# pi infty
+piwl = 1.0E+09
+# qv
+qvwl = -1167000
+# qv'
+qvpwl = 0.0E0
+# cv
+cvwl = 1816
+# cp
+cpwl = 4267
+# gamma
+gamwl = cpwl / cvwl
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0wl1 = (p01 + piwl)/((gamwl-1)*cvwl*T01)
+rho0wl2 = (p02 + piwl)/((gamwl-1)*cvwl*T02)
+rho0wl3 = (p03 + piwl)/((gamwl-1)*cvwl*T03)
+
+# speed of sound FOR
+c_wl1 = math.sqrt( gamwl * ( p01 + piwl ) / rho0wl1 )
+c_wl2 = math.sqrt( gamwl * ( p02 + piwl ) / rho0wl2 )
+c_wl3 = math.sqrt( gamwl * ( p03 + piwl ) / rho0wl3 )
+
+# part for Gases - relations from IMR
+Ru = 8.3144598         # Universal gas constant (J/mol-K)
+
+### Vapor water ###
+Rv = Ru/(18.01528e-3)  # Gas constant for vapor (Ru/molecular weight) (J/kg-K)
+# gamma
+gamwv = 1.4
+# cp
+cpwv = Rv * gamwv/(gamwv-1)
+# cv
+cvwv = cpwv/gamwv
+# pi infinity
+piwv = 0.0E0
+# qv
+qvwv = 2030000
+# qv'
+qvpwv = -23400
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0wv1 = (p01 + piwv)/((gamwv-1)*cvwv*T01)
+rho0wv2 = (p02 + piwv)/((gamwv-1)*cvwv*T02)
+rho0wv3 = (p03 + piwv)/((gamwv-1)*cvwv*T03)
+
+# speed of sound
+c_wv1 = math.sqrt( gamwv * ( p01 + piwv ) / rho0wv1 )
+c_wv2 = math.sqrt( gamwv * ( p02 + piwv ) / rho0wv2 )
+c_wv3 = math.sqrt( gamwv * ( p03 + piwv ) / rho0wv3 )
+
+### Air ###
+
+Ra = Ru/(28.966e-3)     # Gas constant for air (Ru/molecular weight) (J/kg-K)
+gamwa = 1.4
+# cp
+cpa = Ra * gamwa/(gamwa-1)
+# cv
+cva = cpa/gamwa
+# pi infinity
+pia = 0.0E0
+# qv
+qvwa = 0.0E0
+# qv'
+qvpwa = 0.0E0
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0wa1 = (p01 + pia)/((gamwa-1)*cva*T01)
+rho0wa2 = (p02 + pia)/((gamwa-1)*cva*T02)
+
+# Speed of sound
+c_a1 = math.sqrt( gamwa * ( p01 + pia ) / rho0wa1 )
+c_a2 = math.sqrt( gamwa * ( p02 + pia ) / rho0wa2 )
+
+### 3% polyacrylamide gel ###
+# gamma
+gamwg = 2.35
+# pi infty
+pig = 1.0E+09
+# qv
+qvwg = -1167000
+# qv'
+qvpwg = 0.0E0
+# cv
+cvg = 1816
+# cp
+cpg = gamwg*cvg
+
+## FOR PATCHES 1 & 2 & 3 ##
+
+# density
+rho0wg1 = (p01 + pig)/((gamwg-1)*cvg*T01)
+rho0wg2 = (p02 + pig)/((gamwg-1)*cvg*T02)
+rho0wg3 = (p03 + pig)/((gamwg-1)*cvg*T03)
+
+# Speed of sound
+c_g1 = math.sqrt( gamwg * ( p01 + pig ) / rho0wg1 )
+c_g2 = math.sqrt( gamwg * ( p02 + pig ) / rho0wg2 )
+c_g3 = math.sqrt( gamwg * ( p03 + pig ) / rho0wg3 )
+
+## SHOCK RELATIONS
+p02Op01 = p02 / p01
+
+# Mach number of the shocked region - this should agree with Min, if everything is correct
+Ms = math.sqrt( ( gamwa + 1. ) / ( 2. * gamwa ) * ( p02Op01 - 1. ) * ( p02 / ( p02 + pia ) ) + 1.0 )
+
+# shock speed
+ss = Ms * c_a1
+
+### volume fractions for each of the patches ###
+C0 = 0.1 # vapor concentration for IMR
+
+# patch 1: liquid water
+liq_wv = 1.00E-15
+liq_wg = 1.00E-15
+liq_wa = 1.00E-15
+liq_wl = 1.00E00 - liq_wv - liq_wa - liq_wg
+# water vapor
+vap_wl = 1.00E-15
+vap_wv = 1 / ( ( 1 - C0 ) / C0 * rho0wv2 / rho0wa2 + 1 )
+vap_wg = 1.00E-15
+vap_wa = 1.00E-15
+vap_tot = vap_wl + vap_wv + vap_wa + vap_wg
+# bub
+bub_wl = 1.00E-15
+bub_wv = vap_tot
+bub_wg = 1.00E-15
+bub_wa = 1.00E00 - bub_wl - bub_wv - bub_wg
+# gel
+gel_wv = 1.00E-15
+gel_wl = 1.00E-15
+gel_wa = 1.00E-15
+gel_wg = 1.00E00 - gel_wl - gel_wv - gel_wa
+
+## SIMULATION PARAMETERS
+
+# CFL
+cfl = 0.50
+
+# Bubble Initial Radius
+R0 = 230.4E-06
+
+# number of elements
+Nx0 = 400
+Nx = 199*2
+Ny = 199
+Nz = 199
+
+lref = 921.6E-6
+# domain boundaries
+xb = -lref
+xe = lref
+
+yb = 0.00
+ye = lref
+
+zb = 0.00
+ze = lref
+
+lenx = ( xe - xb )
+leny = ( ye - yb )
+lenz = ( ze - zb )
+
+xcenl = (xb + xe)/2.0
+ycenl = (yb + ye)/2.0 
+zcenl = (zb + ze)/2.0
+
+#xdist = 6.51E-10 #2.17E-5
+#sod = xdist/R0
+sod = -2.17
+xcenb = sod*R0 
+ycenb = 0.00
+zcenb = 0.00
+
+xbg = 0
+xeg = xe
+
+lenxg = (xeg - xbg)
+lenyg = leny
+lenzg = lenz
+xceng = (xbg + xeg)/2.0
+yceng = ycenl
+zceng = zcenl
+
+# typical cell size
+dx = ( xe - xb ) / Nx
+dy = ( ye - yb ) / Ny
+dz = ( ze - zb ) / Nz
+#print(dx)
+# time step
+
+# save frequency = SF + 1 (because the initial state, 0.dat, is also saved)
+SF = 60
+
+# Critical time-step
+tc = 0.915 * R0 * math.sqrt( rho0wl1 / p01 )
+
+# making Nt divisible by SF
+# tendA = 1.5 * tc
+tend = 1.2 * tc
+
+# 1 - ensure NtA is sufficient to go a little beyond tendA
+# NtA = int( tendA // dt + 1 )
+
+# Array of saves. it is the same as Nt/Sf = t_step_save
+# AS = int( NtA // SF + 1 )
+
+# Nt = total number of steps. Ensure Nt > NtA (so the total tendA is covered)
+# Nt = AS * SF
+Nt = int(10E3 * tend // tc * Nx / Nx0 + 1)
+#print(Nt)
+dt = tend / Nt
+
+AS = int( Nt//SF )
+
+# Total physical time
+# tend = Nt * dt
+
+# Configuring case dictionary ==================================================
+print(json.dumps({
+    # Logistics ================================================
+    'run_time_info': 'T',
+    # ==========================================================
+    # Computational Domain Parameters ==========================
+    'x_domain%beg' : xb,        
+    'x_domain%end' : xe,        
+    'y_domain%beg' : yb,        
+    'y_domain%end' : ye,
+    'z_domain%beg' : zb,
+    'z_domain%end' : ze,
+    'stretch_x'    : 'F',
+    'loops_x'      : 1,
+    'a_x'          : 4.0E0,
+    'x_a'          : -2.0*R0,
+    'x_b'          :  2.0*R0,
+    'stretch_y'    : 'F',
+    'loops_y'      : 1,
+    'a_y'          : 4.0E0,
+    'y_a'          : -2.0*R0,
+    'y_b'          :  2.0*R0,
+    'stretch_z'    : 'F',
+    'loops_z'      : 1,
+    'a_z'          : 4.0E0,
+    'z_a'          : -2.0*R0,
+    'z_b'          : 2.0*R0,
+    'cyl_coord'    : 'F',
+    'm'            : Nx,        
+    'n'            : Ny,        
+    'p'            : Nz,         
+    'dt'           : dt,        
+    't_step_start' : 0,       
+    't_step_stop'  : Nt,      
+    't_step_save'  : AS,        
+    # ==========================================================
+    # Simulation Algorithm Parameters ==========================
+    'num_patches'  : 3,        
+    'model_eqns'   : 3,        
+    'num_fluids'   : 4,        
+    'adv_alphan'   : 'T',      
+    'mpp_lim'      : 'T',      
+    'mixture_err'  : 'T',      
+    'relax'        : 'T',  
+    'relax_model'  : 6,        
+    'palpha_eps'   : 1.0E-6,   
+    'ptgalpha_eps' : 1.0E-2,   
+    'time_stepper' : 3,        
+    'weno_order'   : 3,        
+    'weno_eps'     : 1.0E-16,
+    'weno_Re_flux' : 'F',  
+    'weno_avg'     : 'F',  
+    'mapped_weno'  : 'T',      
+    'null_weights' : 'F',      
+    'mp_weno'      : 'F',      
+    'riemann_solver' : 2,   
+    'wave_speeds'  : 1,        
+    'avg_state'    : 2,        
+    'bc_x%beg'     : -6, #-2,
+    'bc_x%end'     : -6,       
+    'bc_y%beg'     : -2,       
+    'bc_y%end'     : -6,
+    'bc_z%beg'     : -2,
+    'bc_z%end'     : -6,
+    # ==========================================================
+    # Formatted Database Files Structure Parameters ============
+    'format'       : 1,        
+    'precision'    : 2,        
+    'prim_vars_wrt':'T',       
+    'parallel_io'  :'T',       
+    # ==========================================================
+    # Patch 1: High pressured water ============================
+    # Specify the cubic water background grid geometry
+    'patch_icpp(1)%geometry'       : 9,
+    'patch_icpp(1)%x_centroid'     : xcenl,
+    'patch_icpp(1)%y_centroid'     : ycenl,
+    'patch_icpp(1)%z_centroid'     : zcenl,
+    'patch_icpp(1)%length_x'       : lenx,
+    'patch_icpp(1)%length_y'       : leny,
+    'patch_icpp(1)%length_z'       : lenz,
+    'patch_icpp(1)%vel(1)'         : 0.0E+00,
+    'patch_icpp(1)%vel(2)'         : 0.0E+00,
+    'patch_icpp(1)%vel(3)'         : 0.0E+00,
+    'patch_icpp(1)%pres'           : p01,  	
+    'patch_icpp(1)%alpha_rho(1)'   : liq_wl * rho0wl1,           	
+    'patch_icpp(1)%alpha_rho(2)'   : liq_wv * rho0wv1,            
+    'patch_icpp(1)%alpha_rho(3)'   : liq_wa * rho0wa1,
+    'patch_icpp(1)%alpha_rho(4)'   : liq_wg * rho0wg1,            
+    'patch_icpp(1)%alpha(1)'       : liq_wl,   	
+    'patch_icpp(1)%alpha(2)'       : liq_wv,   	
+    'patch_icpp(1)%alpha(3)'       : liq_wa,
+    'patch_icpp(1)%alpha(4)'       : liq_wg,   	
+    # ==========================================================
+    # Patch 2: (Vapor) Bubble ==================================
+    'patch_icpp(2)%geometry'       : 8,     	
+    'patch_icpp(2)%x_centroid'     : xcenb,
+    'patch_icpp(2)%y_centroid'     : ycenb,
+    'patch_icpp(2)%z_centroid'     : zcenb,
+    'patch_icpp(2)%radius'         : R0,
+    'patch_icpp(2)%vel(1)'         : 0.0E+00,
+    'patch_icpp(2)%vel(2)'         : 0.0E+00,
+    'patch_icpp(2)%vel(3)'         : 0.0E+00,
+    'patch_icpp(2)%pres'           : p02,    	
+    'patch_icpp(2)%alpha_rho(1)'   : bub_wl * rho0wl2,           	
+    'patch_icpp(2)%alpha_rho(2)'   : bub_wv * rho0wv2,           	
+    'patch_icpp(2)%alpha_rho(3)'   : bub_wa * rho0wa2,           
+    'patch_icpp(2)%alpha_rho(4)'   : bub_wg * rho0wg2,
+    'patch_icpp(2)%alpha(1)'       : bub_wl,   	
+    'patch_icpp(2)%alpha(2)'       : bub_wv,   	
+    'patch_icpp(2)%alpha(3)'       : bub_wa,
+    'patch_icpp(2)%alpha(4)'       : bub_wg,
+    'patch_icpp(2)%alter_patch(1)' : 'T',
+    # ==========================================================
+    # Patch 3: Gel Object ======================================
+    'patch_icpp(3)%geometry'       : 9,     	
+    'patch_icpp(3)%x_centroid'     : xceng,
+    'patch_icpp(3)%y_centroid'     : yceng,
+    'patch_icpp(3)%z_centroid'     : zceng,
+    'patch_icpp(3)%length_x'       : lenxg,
+    'patch_icpp(3)%length_y'       : lenyg,
+    'patch_icpp(3)%length_z'       : lenzg,
+    'patch_icpp(3)%vel(1)'         : 0.0E+00,
+    'patch_icpp(3)%vel(2)'         : 0.0E+00,
+    'patch_icpp(3)%vel(3)'         : 0.0E+00,
+    'patch_icpp(3)%pres'           : p03,    	
+    'patch_icpp(3)%alpha_rho(1)'   : gel_wl * rho0wl2,           	
+    'patch_icpp(3)%alpha_rho(2)'   : gel_wv * rho0wv2,           	
+    'patch_icpp(3)%alpha_rho(3)'   : gel_wa * rho0wa2,
+    'patch_icpp(3)%alpha_rho(4)'   : gel_wg * rho0wg2,           	
+    'patch_icpp(3)%alpha(1)'       : gel_wl,   	
+    'patch_icpp(3)%alpha(2)'       : gel_wv,   	
+    'patch_icpp(3)%alpha(3)'       : gel_wa,
+    'patch_icpp(3)%alpha(4)'       : gel_wg,	
+    'patch_icpp(3)%alter_patch(1)' : 'T',
+    # ==========================================================
+    # Fluids Physical Parameters ===============================
+    'fluid_pp(1)%gamma'            : 1.0E+00 / ( gamwl - 1 ),       
+    'fluid_pp(1)%pi_inf'           : gamwl * piwl / ( gamwl - 1 ),  
+    'fluid_pp(1)%cv'          	   : cvwl,          
+    'fluid_pp(1)%qv'        	   : qvwl,	
+    'fluid_pp(1)%qvp'          	   : qvpwl,         
+    'fluid_pp(2)%gamma'            : 1.0E+00 / ( gamwv - 1 ),       
+    'fluid_pp(2)%pi_inf'           : gamwv * piwv / ( gamwv - 1 ),  
+    'fluid_pp(2)%cv'          	   : cvwv,          
+    'fluid_pp(2)%qv'        	   : qvwv,  	
+    'fluid_pp(2)%qvp'          	   : qvpwv,			
+    'fluid_pp(3)%gamma'            : 1.0E+00 / ( gamwa - 1 ),       
+    'fluid_pp(3)%pi_inf'           : gamwa * pia / ( gamwa - 1 ),  
+    'fluid_pp(3)%cv'          	   : cva,          
+    'fluid_pp(3)%qv'        	   : qvwa,  	
+    'fluid_pp(3)%qvp'          	   : qvpwa,
+    'fluid_pp(4)%gamma'            : 1.0E+00 / ( gamwg - 1),
+    'fluid_pp(4)%pi_inf'           : gamwg * pig / ( gamwg - 1),
+    'fluid_pp(4)%cv'               : cvg,
+    'fluid_pp(4)%qv'               : qvwg,
+    'fluid_pp(4)%qvp'              : qvpwg,			
+    # ==========================================================
+}))
diff --git a/examples/3D_hyperelasticity/hyper_gel.py b/examples/3D_hyperelasticity/hyper_gel.py
new file mode 100644
index 00000000..09782de4
--- /dev/null
+++ b/examples/3D_hyperelasticity/hyper_gel.py
@@ -0,0 +1,312 @@
+import math
+import json
+#need quadrant and collapse near hypoelastic wall
+
+## Define characteristic values for the sim
+Ri = 230.4E-6
+# temperature
+T = (10*101325+1.0E+09)/(1000*(2.35-1)*1816)
+# print("T :: ",T)
+rhog = 1
+Pb = 3550 #Pb = 101325 
+Pl = 101325 #Pl = 20*101325
+Po = Pl 
+Pi_inf_l = 1.0E+09
+Pi_inf_b = 0.0E+00
+Pi_inf_o = 1.1754E+09
+
+## fluid properties
+# liquid 
+nl = 2.35E+00
+cv_l = 1816
+rhol = (Pl+Pi_inf_l)/((nl-1)*cv_l*T)
+# object 
+obj_rhol = rhol
+cv_o = cv_l
+rhoo = 1060
+no = 2.35
+#no = 1.19E+00
+muo = 0.060E+00
+# gas 
+ng = 1.47E+00
+
+# alpha seeding fractions
+bub_wl = 1.0E-12
+bub_wo = 1.0E-12
+bub_wg = 1 - bub_wl - bub_wo
+liq_wo = 1.0E-12
+liq_wg = 1.0E-12
+liq_wl = 1 - liq_wo - liq_wg
+obj_wl = 1.0E-12
+obj_wg = 1.0E-12
+obj_wo = 1 - obj_wl - obj_wg
+
+Gl = 0.
+Gg = 0.
+Go = 0.57E+03 #1.0933E+04
+
+## mixture values in the liquid
+#rhoml = (alpha1-alph_eps)*rhol+alph_eps*rhog
+#pi_inf_m = (alpha1-alph_eps)*Pi_inf_l
+#nml = (alpha1-alph_eps)*nl+alph_eps*ng
+cl = (nl*(Pl+Pi_inf_l)/rhol)**(0.5)
+rhoml = liq_wl*rhol + liq_wg*rhog + liq_wo*rhoo 
+
+## Defining Characteristic Values 
+Rc = Ri
+rhoc = rhol
+uc = (Pl/rhol)**(0.5E+00)
+ucc = (Pl/rhoml)**(0.5E+00)
+# characteristic collapse time, change later to prevent horrific confusion
+tc = Ri/uc
+Pc = rhoc*uc**(2.0E+00)
+
+## Non-Dimensionalizing values using characteristic values
+Rin = Ri/Rc
+rholn = rhol/rhoc
+rhogn = rhog/rhoc
+rhoon = rhoo/rhoc
+Pln = Pl/Pc
+Pbn = Pb/Pc
+Pon = Po/Pc
+tcn = tc/tc
+Pi_inf_ln = Pi_inf_l/Pc
+clc = cl/uc
+sod_nd = 2.17
+#clmc = clm/ucc
+Pi_inf_on = Pi_inf_o/Pc
+
+# Un comment if dimensional
+#Rin = Ri
+#rholn = rhol
+#rhogn = rhog
+#rhoon = rhoo
+#Pln = Pl
+#Pbn = Pb/rhoo
+#Pon = Po
+#tcn = tc
+#Pi_inf_ln = Pi_inf_l
+#leng = domain_length
+#clc = cl
+#sod_nd = sod
+
+## Non-Dimensional Numbers
+#Rel = rhol*uc*2*Rin/mulc
+#Reb = rhog*uc*2*Rin/mubc
+Rel = 0
+Reb = 0
+Reo = rhoo*uc*2/muo
+Ma = uc/cl
+Co = Pl/Go
+iCo = 1/Co 
+
+## GEOMETRY:: Grid Specifications
+lengx = 8.0E+00
+lengy = 3.0E+00
+lengz = 3.0E+00
+CFL = 0.3
+PPBR = 16 #92
+x_beg = -5.0E+00
+x_end = 3.0E+00
+y_beg = 0.0E+00
+y_end = lengy
+z_beg = 0.0E+00
+z_end = lengz
+Nx = PPBR*lengx
+Ny = PPBR*lengy
+Nz = PPBR*lengz
+delta_x = lengx/Nx
+delta_t = CFL*delta_x/clc
+
+#print("NX :: ",Nx,", NY :: ",Ny,", NZ :: ",Nz)
+
+#delta_t_c = 0.185*delta_x/clmc
+#print(delta_t_c)
+
+Nt = int(1.7*tcn/delta_t)
+# liquid centroid, patch 1
+x_centroidl = x_beg/(2.0E+00)
+y_centroidl = (y_end+y_beg)/(2.0E+00)
+z_centroidl = (z_end+z_beg)/(2.0E+00)
+# bubble centroid, patch 2
+x_centroidb = -sod_nd
+y_centroidb = 0.0
+z_centroidb = 0.0
+# objective centroid, patch 3
+x_centroido = x_end/2
+y_centroido = (y_end+y_beg)/(2.0E+00)
+z_centroido = (z_end+z_beg)/(2.0E+00)
+
+# Configuring case dictionary
+print(json.dumps({
+    # Logistics ================================================
+    'run_time_info'                : 'T',
+    'sim_data'                     : 'T',
+    # ==========================================================
+
+    # Computational Domain Parameters ==========================
+    'x_domain%beg'                 : x_beg,
+    'x_domain%end'                 : x_end,
+    'y_domain%beg'                 : y_beg,
+    'y_domain%end'                 : y_end,
+    'z_domain%beg'                 : z_beg,
+    'z_domain%end'                 : z_end,
+    'm'                            : int(Nx),
+    'n'                            : int(Ny),
+    'p'                            : int(Nz),
+    'cyl_coord'                    : 'F',
+    'dt'                           : delta_t,
+    't_step_start'                 : 0, 
+    't_step_stop'                  : Nt,
+    't_step_save'                  : int(5),#int(Nt/150),
+# ==========================================================
+
+    # Simulation Algorithm Parameters ==========================
+    'num_patches'                  : 3,
+    'model_eqns'                   : 2,
+    'hypoelasticity'               : 'F', 
+    'hyperelasticity'              : 'T',
+    'pre_stress'                   : 'F',
+    'alt_soundspeed'               : 'F',
+    'num_fluids'                   : 3,
+    'adv_alphan'                   : 'T',
+    'mpp_lim'                      : 'F',
+    'mixture_err'                  : 'T',
+    'time_stepper'                 : 3,
+    'weno_order'                   : 5,
+    'weno_eps'                     : 1.E-16,
+    'mapped_weno'                  : 'T',
+    'null_weights'                 : 'F',
+    'mp_weno'                      : 'T',
+    'weno_Re_flux'                 : 'F',
+    'weno_avg'                     : 'F',
+    'riemann_solver'               : 1,
+    'wave_speeds'                  : 1,
+    'avg_state'                    : 2,
+    'bc_x%beg'                     : -6, #-16,#-2
+    'bc_x%end'                     : -6,
+    'bc_y%beg'                     : -2,
+    'bc_y%end'                     : -6,
+    'bc_z%beg'                     : -2,
+    'bc_z%end'                     : -6,
+    'stretch_x'                    : 'F',
+    'stretch_y'                    : 'F',
+    'stretch_z'                    : 'F',
+    'a_x'                          : 4.0E+00,
+    'x_a'                          : -1.5E+00-sod_nd,                   
+    'x_b'                          : 2.5E+00,
+    #'loops_x'                      : 0, 
+    'a_y'                          : 4.0E+00,
+    'y_a'                          : -1.5E+00,
+    'y_b'                          : 1.5E+00,
+    #'loops_y'                      : 0, 
+    'a_z'                          : 4.0E+00,
+    'z_a'                          : -1.5E+00,
+    'z_b'                          : 1.5E+00,
+    #'loops_z'                      : 0,
+    # ==========================================================
+
+    # Formatted Database Files Structure Parameters ============
+    'format'                       : 1,
+    'precision'                    : 2,
+    'prim_vars_wrt'                :'T',
+    'parallel_io'                  :'T',
+    'probe_wrt'                    :'T',
+    'fd_order'                     : 1,
+    'num_probes'                   : 1,
+    'probe(1)%x'  		   : 0., 		       
+    'probe(1)%y'		   : 0., 	    	       
+    'probe(1)%z'		   : 0., 	    	       
+    # ==========================================================
+
+    # Patch 1: Background  ============================
+    'patch_icpp(1)%geometry'       : 9,# for 3D
+    'patch_icpp(1)%x_centroid'     : x_centroidl, #100*x_centroidl,
+    'patch_icpp(1)%y_centroid'     : y_centroidl, #100*y_centroidl,
+    'patch_icpp(1)%z_centroid'     : z_centroidl, #100*z_centroidl,
+    'patch_icpp(1)%length_x'       : lengx, #200*lengx,
+    'patch_icpp(1)%length_y'       : lengy, #200*lengy,
+    'patch_icpp(1)%length_z'       : lengz, #200*lengz,
+    'patch_icpp(1)%vel(1)'         : 0.E+00,
+    'patch_icpp(1)%vel(2)'         : 0.E+00,
+    'patch_icpp(1)%vel(3)'         : 0.E+00,
+    'patch_icpp(1)%pres'           : Pln,
+    'patch_icpp(1)%alpha_rho(1)'   : liq_wl*rholn,
+    'patch_icpp(1)%alpha_rho(2)'   : liq_wg*rhogn,
+    'patch_icpp(1)%alpha_rho(3)'   : liq_wo*rhoon,
+    'patch_icpp(1)%alpha(1)'       : liq_wl,
+    'patch_icpp(1)%alpha(2)'       : liq_wg,
+    'patch_icpp(1)%alpha(3)'       : liq_wo,
+    # ==========================================================
+    # Patch 2: Bubble  ======================================
+     # Specify the spherical gas bubble grid geometry
+    'patch_icpp(2)%geometry'       : 8,# for 3D
+    'patch_icpp(2)%smoothen'       : 'T',
+    'patch_icpp(2)%smooth_patch_id' : 1,
+    'patch_icpp(2)%smooth_coeff'   : 4.0E+00,
+    'patch_icpp(2)%x_centroid'     : x_centroidb,
+    'patch_icpp(2)%y_centroid'     : y_centroidb,
+    'patch_icpp(2)%z_centroid'     : z_centroidb,
+    'patch_icpp(2)%radius'         : Rin,
+    'patch_icpp(2)%alter_patch(1)' : 'T',
+    # Specify the patch primitive variables 
+    'patch_icpp(2)%vel(1)'         : 0.E+00,
+    'patch_icpp(2)%vel(2)'         : 0.E+00,
+    'patch_icpp(2)%vel(3)'         : 0.E+00,
+    'patch_icpp(2)%pres'           : Pbn,
+    'patch_icpp(2)%alpha_rho(1)'   : bub_wl*rholn,
+    'patch_icpp(2)%alpha_rho(2)'   : bub_wg*rhogn,
+    'patch_icpp(2)%alpha_rho(3)'   : bub_wo*rhoon,
+    'patch_icpp(2)%alpha(1)'       : bub_wl,
+    'patch_icpp(2)%alpha(2)'       : bub_wg,
+    'patch_icpp(2)%alpha(3)'       : bub_wo,
+    # ==========================================================
+     # Patch 3: Gel  ===========================================
+     # Specify the gel grid geometry
+    'patch_icpp(3)%geometry'       : 9,# for 3D
+    'patch_icpp(3)%x_centroid'     : x_centroido, #100*x_centroido,
+    'patch_icpp(3)%y_centroid'     : y_centroido, #100*y_centroido,
+    'patch_icpp(3)%z_centroid'     : z_centroido, #100*z_centroido,
+    'patch_icpp(3)%length_x'       : 3.0E+00, #100*lengx,
+    'patch_icpp(3)%length_y'       : lengy, #200*lengy,
+    'patch_icpp(3)%length_z'       : lengz, #200*lengz,
+    'patch_icpp(3)%alter_patch(1)' : 'T',
+    # Specify the patch primitive variables 
+    'patch_icpp(3)%vel(1)'         : 0.E+00,
+    'patch_icpp(3)%vel(2)'         : 0.E+00,
+    'patch_icpp(3)%vel(3)'         : 0.E+00,
+    'patch_icpp(3)%pres'           : Pon,
+    'patch_icpp(3)%alpha_rho(1)'   : obj_wl*rholn,
+    'patch_icpp(3)%alpha_rho(2)'   : obj_wg*rhogn,
+    'patch_icpp(3)%alpha_rho(3)'   : obj_wo*rhoon,
+    'patch_icpp(3)%alpha(1)'       : obj_wl,
+    'patch_icpp(3)%alpha(2)'       : obj_wg,
+    'patch_icpp(3)%alpha(3)'       : obj_wo,
+    # ==========================================================
+
+
+    # Fluids Physical Parameters ===============================
+    'fluid_pp(1)%gamma'            : 1./(nl-1.),
+    'fluid_pp(1)%pi_inf'           : nl*Pi_inf_ln/(nl-1.),
+    'fluid_pp(1)%G'                : Gl,
+    'fluid_pp(2)%gamma'            : 1./(ng-1.),
+    'fluid_pp(2)%pi_inf'           : 0.0E+00,
+    'fluid_pp(2)%G'                : Gg,
+    'fluid_pp(3)%gamma'            : 1./(no-1.),
+    'fluid_pp(3)%pi_inf'           : no*Pi_inf_on/(no-1.),
+    'fluid_pp(3)%G'                : iCo,
+    'fluid_pp(1)%qv'               : 0.0E+00,
+    'fluid_pp(1)%qvp'              : 0.0E+00,
+    'fluid_pp(2)%qv'               : 0.0E+00,
+    'fluid_pp(2)%qvp'              : 0.0E+00,
+    'fluid_pp(3)%qv'               : 0.0E+00,
+    'fluid_pp(3)%qvp'              : 0.0E+00,
+#    'fluid_pp(1)%Re(1)'            : Rel,
+#    'fluid_pp(2)%Re(1)'            : Reb,
+#    'fluid_pp(3)%Re(1)'            : Reo,
+    # ===========++=============================================
+}))
+
+# ==============================================================================
+
+
diff --git a/examples/3D_phasechange_bubble/case.py b/examples/3D_phasechange_bubble/case.py
new file mode 100644
index 00000000..047c8655
--- /dev/null
+++ b/examples/3D_phasechange_bubble/case.py
@@ -0,0 +1,300 @@
+#!/usr/bin/env python3
+import math, json
+
+## 1 FOR BACKGROUND, 2 FOR BUBBLE
+# Pressure [Pa]
+p01 = 5E6
+p02 = 3550
+
+# Temperature [K]
+T01 = 298.15
+T02 = 298.15
+#T02 = 7.914
+
+#### FLUID PROPERTIES ####
+
+### liquid water ###
+# pi infty
+piwl = 1.0E+09
+# qv
+qvwl = -1167000
+# qv'
+qvpwl = 0.0E0
+# cv
+cvwl = 1816
+# cp
+cpwl = 4267
+# gamma
+gamwl = cpwl / cvwl
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0wl1 = (p01 + piwl)/((gamwl-1)*cvwl*T01)
+rho0wl2 = (p02 + piwl)/((gamwl-1)*cvwl*T02)
+
+# speed of sound FOR
+c_wl1 = math.sqrt( gamwl * ( p01 + piwl ) / rho0wl1 )
+c_wl2 = math.sqrt( gamwl * ( p02 + piwl ) / rho0wl2 )
+
+# part for Gases - relations from IMR
+Ru = 8.3144598         # Universal gas constant (J/mol-K)
+
+### Vapor water ###
+Rv = Ru/(18.01528e-3)  # Gas constant for vapor (Ru/molecular weight) (J/kg-K)
+# gamma
+gamwv = 1.4
+# cp
+cpwv = Rv * gamwv/(gamwv-1)
+# cv
+cvwv = cpwv/gamwv
+# pi infinity
+piwv = 0.0E0
+# qv
+qvwv = 2030000
+# qv'
+qvpwv = -23400
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0wv1 = (p01 + piwv)/((gamwv-1)*cvwv*T01)
+rho0wv2 = (p02 + piwv)/((gamwv-1)*cvwv*T02)
+
+# speed of sound
+c_wv1 = math.sqrt( gamwv * ( p01 + piwv ) / rho0wv1 )
+c_wv2 = math.sqrt( gamwv * ( p02 + piwv ) / rho0wv2 )
+
+### Air ###
+
+Ra = Ru/(28.966e-3)    # Gas constant for air (Ru/molecular weight) (J/kg-K)
+# gamma
+gama = 1.4
+# cp
+cpa = Ra * gama/(gama-1)
+# cv
+cva = cpa/gama
+# pi infinity
+pia = 0.0E0
+# qv
+qva = 0.0E0
+# qv'
+qvpa = 0.0E0
+
+## FOR PATCHES 1 & 2 ##
+
+# density
+rho0a1 = (p01 + pia)/((gama-1)*cva*T01)
+rho0a2 = (p02 + pia)/((gama-1)*cva*T02)
+
+# Speed of sound
+c_a1 = math.sqrt( gama * ( p01 + pia ) / rho0a1 )
+c_a2 = math.sqrt( gama * ( p02 + pia ) / rho0a2 )
+
+## SHOCK RELATIONS
+p02Op01 = p02 / p01
+
+# Mach number of the shocked region - this should agree with Min, if everything is correct
+Ms = math.sqrt( ( gama + 1. ) / ( 2. * gama ) * ( p02Op01 - 1. ) * ( p02 / ( p02 + pia ) ) + 1.0 )
+
+# shock speed
+ss = Ms * c_a1
+
+### volume fractions for each of the patches ###
+C0 = 0.25 # vapor concentration for IMR
+
+# water liquid
+awl1 = 1.00E00-2.00E-12
+awl2 = 1.00E-12
+# water vapor
+awv1 = 1.00E-12
+awv2 = 1 / ( ( 1 - C0 ) / C0 * rho0wv2 / rho0a2 + 1 )
+# air
+aa1 = 1.0 - awl1 - awv1
+aa2 = 1.0 - awl2 - awv2
+
+## SIMULATION PARAMETERS
+
+# CFL
+cfl = 0.50
+
+# Bubble Initial Radius
+R0 = 30E-06
+
+# number of elements
+Nx0 = 400
+Nx = 199
+Ny = 199
+Nz = 199
+
+# domain boundaries
+xb = 0.00
+xe = 120E-6
+
+yb = 0.00
+ye = 120E-6
+
+zb = 0.00
+ze = 120E-6
+
+# typical cell size
+dx	= ( xe - xb ) / Nx
+dy	= ( ye - yb ) / Ny
+dz	= ( ze - zb ) / Nz
+
+# time step
+
+# save frequency = SF + 1 (because the initial state, 0.dat, is also saved)
+SF = 200
+
+# Critical time-step
+tc = 0.915 * R0 * math.sqrt( rho0wl1 / p01 )
+
+# making Nt divisible by SF
+# tendA = 1.5 * tc
+tend = 1.2 * tc
+
+# 1 - ensure NtA is sufficient to go a little beyond tendA
+# NtA = int( tendA // dt + 1 )
+
+# Array of saves. it is the same as Nt/Sf = t_step_save
+# AS = int( NtA // SF + 1 )
+
+# Nt = total number of steps. Ensure Nt > NtA (so the total tendA is covered)
+# Nt = AS * SF
+Nt = int(18E3 * tend // tc * Nx / Nx0 + 1)
+
+dt = tend / Nt
+
+AS = int( Nt//SF )
+
+# Total physical time
+# tend = Nt * dt
+
+# Configuring case dictionary ==================================================
+print(json.dumps({
+    # Logistics ================================================
+    'run_time_info': 'T',
+    # ==========================================================
+    # Computational Domain Parameters ==========================
+    'x_domain%beg' : xb,        
+    'x_domain%end' : xe,        
+    'y_domain%beg' : yb,        
+    'y_domain%end' : ye,
+    'z_domain%beg' : zb,        
+    'z_domain%end' : ze,
+    'stretch_x'    : 'T',
+    'loops_x'      : 3,
+    'a_x'          : 4.0E0,
+    'x_a'          : -2.0*R0,
+    'x_b'          :  2.0*R0,
+    'stretch_y'    : 'T',
+    'loops_y'      : 3,
+    'a_y'          : 4.0E0,
+    'y_a'          : -2.0*R0,
+    'y_b'          :  2.0*R0,
+    'stretch_z'    : 'T',
+    'loops_z'      : 3,
+    'a_z'          : 4.0E0,
+    'z_a'          : -2.0*R0,
+    'z_b'          :  2.0*R0,
+    'cyl_coord'    : 'F',
+    'm'            : Nx,        
+    'n'            : Ny,        
+    'p'            : Nz,         
+    'dt'           : dt,        
+    't_step_start' : 0,       
+    't_step_stop'  : Nt,      
+    't_step_save'  : AS,        
+    # ==========================================================
+    # Simulation Algorithm Parameters ==========================
+    'num_patches'  : 2,        
+    'model_eqns'   : 3,        
+    'num_fluids'   : 3,        
+    'adv_alphan'   : 'T',      
+    'mpp_lim'      : 'T',      
+    'mixture_err'  : 'T',      
+    'relax'        : 'T',  
+    'relax_model'  : 6,        
+    'palpha_eps'   : 1.0E-6,   
+    'ptgalpha_eps' : 1.0E-2,   
+    'time_stepper' : 3,        
+    'weno_order'   : 3,        
+    'weno_eps'     : 1.0E-32,
+    'weno_Re_flux' : 'F',  
+    'weno_avg'     : 'F',  
+    'mapped_weno'  : 'T',      
+    'null_weights' : 'F',      
+    'mp_weno'      : 'F',      
+    'riemann_solver' : 2,   
+    'wave_speeds'  : 1,        
+    'avg_state'    : 2,        
+    'bc_x%beg'     : -2,
+    'bc_x%end'     : -6,       
+    'bc_y%beg'     : -2,       
+    'bc_y%end'     : -6,
+    'bc_z%beg'     : -2,
+    'bc_z%end'     : -6,       
+    # ==========================================================
+    # Formatted Database Files Structure Parameters ============
+    'format'       : 1,        
+    'precision'    : 2,        
+    'prim_vars_wrt':'T',       
+    'parallel_io'  :'T',       
+    # ==========================================================
+    # Patch 1: High pressured water ============================
+    # Specify the cubic water background grid geometry
+    'patch_icpp(1)%geometry'       : 9,
+    'patch_icpp(1)%x_centroid'     : ( xe + xb ) * 500000 / 100,
+    'patch_icpp(1)%y_centroid'     : ( ye + yb ) * 500000 / 100,
+    'patch_icpp(1)%z_centroid'     : ( ze + zb ) * 500000 / 100,
+    'patch_icpp(1)%length_x'       : ( xe - xb ) * 1000000 / 100,
+    'patch_icpp(1)%length_y'       : ( ye - yb ) * 1000000 / 100,
+    'patch_icpp(1)%length_z'       : ( ze - zb ) * 1000000 / 100,
+    'patch_icpp(1)%vel(1)'         : 0.0E+00,
+    'patch_icpp(1)%vel(2)'         : 0.0E+00,
+    'patch_icpp(1)%vel(3)'         : 0.0E+00,
+    'patch_icpp(1)%pres'           : p01,  	
+    'patch_icpp(1)%alpha_rho(1)'   : awl1 * rho0wl1,           	
+    'patch_icpp(1)%alpha_rho(2)'   : awv1 * rho0wv1,            
+    'patch_icpp(1)%alpha_rho(3)'   : aa1 * rho0a1,            
+    'patch_icpp(1)%alpha(1)'       : awl1,   	
+    'patch_icpp(1)%alpha(2)'       : awv1,   	
+    'patch_icpp(1)%alpha(3)'       : aa1,   	
+    # ==========================================================
+    # Patch 2: (Vapor) Bubble ==================================
+    'patch_icpp(2)%geometry'       : 8,     	
+    'patch_icpp(2)%x_centroid'     : xb,
+    'patch_icpp(2)%y_centroid'     : yb,
+    'patch_icpp(2)%z_centroid'     : zb,
+    'patch_icpp(2)%radius'         : R0,
+    'patch_icpp(2)%vel(1)'         : 0.0E+00,
+    'patch_icpp(2)%vel(2)'         : 0.0E+00,
+    'patch_icpp(2)%vel(3)'         : 0.0E+00,
+    'patch_icpp(2)%pres'           : p02,    	
+    'patch_icpp(2)%alpha_rho(1)'   : awl2 * rho0wl2,           	
+    'patch_icpp(2)%alpha_rho(2)'   : awv2 * rho0wv2,           	
+    'patch_icpp(2)%alpha_rho(3)'   : aa2 * rho0a2,           	
+    'patch_icpp(2)%alpha(1)'       : awl2,   	
+    'patch_icpp(2)%alpha(2)'       : awv2,   	
+    'patch_icpp(2)%alpha(3)'       : aa2,   	
+    'patch_icpp(2)%alter_patch(1)' : 'T',
+    # ==========================================================
+    # Fluids Physical Parameters ===============================
+    'fluid_pp(1)%gamma'            : 1.0E+00 / ( gamwl - 1 ),       
+    'fluid_pp(1)%pi_inf'           : gamwl * piwl / ( gamwl - 1 ),  
+    'fluid_pp(1)%cv'          	   : cvwl,          
+    'fluid_pp(1)%qv'        	   : qvwl,	
+    'fluid_pp(1)%qvp'          	   : qvpwl,         
+    'fluid_pp(2)%gamma'            : 1.0E+00 / ( gamwv - 1 ),       
+    'fluid_pp(2)%pi_inf'           : gamwv * piwv / ( gamwv - 1 ),  
+    'fluid_pp(2)%cv'          	   : cvwv,          
+    'fluid_pp(2)%qv'        	   : qvwv,  	
+    'fluid_pp(2)%qvp'          	   : qvpwv,			
+    'fluid_pp(3)%gamma'            : 1.0E+00 / ( gama - 1 ),       
+    'fluid_pp(3)%pi_inf'           : gama * pia / ( gama - 1 ),  
+    'fluid_pp(3)%cv'          	   : cva,          
+    'fluid_pp(3)%qv'        	   : qva,  	
+    'fluid_pp(3)%qvp'          	   : qvpa,			
+    # ==========================================================
+}))
diff --git a/run_mfc.sh b/run_mfc.sh
new file mode 100755
index 00000000..fc734bea
--- /dev/null
+++ b/run_mfc.sh
@@ -0,0 +1,14 @@
+#!/bin/bash
+
+./mfc.sh run /users/mrodri97/scratch/lungwave/case0/case.py -e interactive -N 1 -n 4 -w 00:30:00 -# pre -t pre_process -c oscar
+./mfc.sh run /users/mrodri97/scratch/lungwave/case0/case.py -e interactive -N 1 -n 4 -w 00:30:00 -# sim -t simulation -c oscar
+./mfc.sh run /users/mrodri97/scratch/lungwave/case0/case.py -e interactive -N 1 -n 4 -w 00:30:00 -# pos -t post_process -c oscar
+
+./mfc.sh run /users/mrodri97/scratch/lungwave/case1/case.py -e interactive -N 1 -n 4 -w 00:30:00 -# pre -t pre_process -c oscar
+./mfc.sh run /users/mrodri97/scratch/lungwave/case1/case.py -e interactive -N 1 -n 4 -w 00:30:00 -# sim -t simulation -c oscar
+./mfc.sh run /users/mrodri97/scratch/lungwave/case1/case.py -e interactive -N 1 -n 4 -w 00:30:00 -# pos -t post_process -c oscar
+
+./mfc.sh run /users/mrodri97/scratch/lungwave/case2/case.py -e interactive -N 1 -n 4 -w 00:30:00 -# pre -t pre_process -c oscar
+./mfc.sh run /users/mrodri97/scratch/lungwave/case2/case.py -e interactive -N 1 -n 4 -w 00:30:00 -# sim -t simulation -c oscar
+./mfc.sh run /users/mrodri97/scratch/lungwave/case2/case.py -e interactive -N 1 -n 4 -w 00:30:00 -# pos -t post_process -c oscar
+
diff --git a/src/common/include/inline_conversions.fpp b/src/common/include/inline_conversions.fpp
index a63af61e..c2f0263e 100644
--- a/src/common/include/inline_conversions.fpp
+++ b/src/common/include/inline_conversions.fpp
@@ -1,17 +1,17 @@
 #:def s_compute_speed_of_sound()
-    subroutine s_compute_speed_of_sound(pres, rho, gamma, pi_inf, H, adv, vel_sum, c)
+    subroutine s_compute_speed_of_sound(pres, rho, gamma, pi_inf, H, adv, vel_sum, c, G)
 #ifdef CRAY_ACC_WAR
         !DIR$ INLINEALWAYS s_compute_speed_of_sound
 #else
         !$acc routine seq
 #endif
-        real(kind(0d0)), intent(in) :: pres
-        real(kind(0d0)), intent(in) :: rho, gamma, pi_inf
-        real(kind(0d0)), intent(in) :: H
-        real(kind(0d0)), dimension(num_fluids), intent(in) :: adv
-        real(kind(0d0)), intent(in) :: vel_sum
-        real(kind(0d0)), intent(out) :: c
-
+        real(kind(0d0)), intent(IN) :: pres
+        real(kind(0d0)), intent(IN) :: rho, gamma, pi_inf
+        real(kind(0d0)), intent(IN) :: H
+        real(kind(0d0)), dimension(num_fluids), intent(IN) :: adv
+        real(kind(0d0)), intent(IN) :: vel_sum
+        real(kind(0d0)), optional, dimension(num_fluids), intent(IN) :: G
+        real(kind(0d0)), intent(OUT) :: c
         real(kind(0d0)) :: blkmod1, blkmod2
 
         integer :: q
@@ -22,6 +22,7 @@
             blkmod2 = ((gammas(2) + 1d0)*pres + &
                        pi_infs(2))/gammas(2)
             c = (1d0/(rho*(adv(1)/blkmod1 + adv(2)/blkmod2)))
+
         elseif (model_eqns == 3) then
             c = 0d0
             !$acc loop seq
@@ -43,6 +44,7 @@
                     (pres + pi_inf/(gamma + 1d0))/ &
                     (rho*(1d0 - adv(num_fluids)))
             end if
+
         else
             c = ((H - 5d-1*vel_sum)/gamma)
         end if
diff --git a/src/common/m_checker_common.fpp b/src/common/m_checker_common.fpp
index 2a15083c..386a844c 100644
--- a/src/common/m_checker_common.fpp
+++ b/src/common/m_checker_common.fpp
@@ -38,6 +38,7 @@ contains
         call s_check_inputs_qbmm_and_polydisperse
         if (adv_n) call s_check_inputs_adv_n
         if (hypoelasticity) call s_check_inputs_hypoelasticity
+        if (hyperelasticity) call s_check_inputs_hyperelasticity
         call s_check_inputs_phase_change
         call s_check_inputs_ibm
 #endif
@@ -173,12 +174,27 @@ contains
     !> Checks constraints on the hypoelasticity parameters.
         !! Called by s_check_inputs_common for pre-processing and simulation
     subroutine s_check_inputs_hypoelasticity
-        if (model_eqns /= 2) then
-            call s_mpi_abort('hypoelasticity requires 5-equation model'// &
-                             '(model_eqns = 2). Exiting ...')
+        !if ((model_eqns /= 2) .or. (model_eqns /= 3)) then
+        if ((model_eqns == 1) .or. (model_eqns == 4)) then
+            call s_mpi_abort('hypoelasticity requires either '// &
+                             '5-equation (model_eqns = 2) or '// &
+                             '6-equation model (model_eqns = 3). Exiting ...')
+        end if
+        if (hyperelasticity) then
+            call s_mpi_abort('hyperelasticity cannot be true with hypoelasticity. '// &
+                             'Exiting ...')
         end if
     end subroutine s_check_inputs_hypoelasticity
 
+    !> Checks constraints on the hyperelasticity parameters. 
+        !! Called by s_check_inputs_common for pre-processing and simulation
+    subroutine s_check_inputs_hyperelasticity
+        if (model_eqns /= 3) then
+           call s_mpi_abort('hyperelasticity requires '// &
+                            '6-equation model (model_eqns = 3). Exiting ...')
+        end if
+    end subroutine s_check_inputs_hyperelasticity
+
     !> Checks constraints on the phase change parameters.
         !! Called by s_check_inputs_common for pre-processing and simulation
     subroutine s_check_inputs_phase_change
diff --git a/src/common/m_constants.fpp b/src/common/m_constants.fpp
index a506acb9..6f9ab2ff 100644
--- a/src/common/m_constants.fpp
+++ b/src/common/m_constants.fpp
@@ -7,18 +7,18 @@ module m_constants
     character, parameter :: dflt_char = ' ' !< Default string value
 
     real(kind(0d0)), parameter :: dflt_real = -1d6                !< Default real value
-    real(kind(0d0)), parameter :: sgm_eps = 1d-16               !< Segmentation tolerance
-    real(kind(0d0)), parameter :: small_alf = 1d-11                !< Small alf tolerance
-    real(kind(0d0)), parameter :: pi = 3.141592653589793d0 !< Pi
+    real(kind(0d0)), parameter :: sgm_eps = 1d-16                 !< Segmentation tolerance
+    real(kind(0d0)), parameter :: small_alf = 1d-11               !< Small alf tolerance
+    real(kind(0d0)), parameter :: pi = 3.141592653589793d0        !< Pi
     real(kind(0d0)), parameter :: verysmall = 1.d-12              !< Very small number
 
-    integer, parameter :: num_stcls_min = 5    !< Minimum # of stencils
-    integer, parameter :: path_len = 400  !< Maximum path length
-    integer, parameter :: name_len = 50   !< Maximum name length
-    integer, parameter :: dflt_int = -100 !< Default integer value
-    integer, parameter :: fourier_rings = 5    !< Fourier filter ring limit
-    integer, parameter :: num_fluids_max = 10   !< Maximum number of fluids in the simulation
-    integer, parameter :: num_probes_max = 10   !< Maximum number of flow probes in the simulation
+    integer, parameter :: num_stcls_min = 5                       !< Minimum # of stencils
+    integer, parameter :: path_len = 400                          !< Maximum path length
+    integer, parameter :: name_len = 50                           !< Maximum name length
+    integer, parameter :: dflt_int = -100                         !< Default integer value
+    integer, parameter :: fourier_rings = 5                       !< Fourier filter ring limit
+    integer, parameter :: num_fluids_max = 10                     !< Maximum number of fluids in the simulation
+    integer, parameter :: num_probes_max = 10                     !< Maximum number of flow probes in the simulation
     integer, parameter :: num_patches_max = 10
     integer, parameter :: pathlen_max = 400
     integer, parameter :: nnode = 4    !< Number of QBMM nodes
diff --git a/src/common/m_derived_types.fpp b/src/common/m_derived_types.fpp
index 9ad172cc..cea5f90d 100644
--- a/src/common/m_derived_types.fpp
+++ b/src/common/m_derived_types.fpp
@@ -142,7 +142,13 @@ module m_derived_types
         type(ic_model_parameters) :: model !< Model parameters
 
         real(kind(0d0)) :: epsilon, beta !<
-        !! The spherical harmonics eccentricity parameters.
+        !! The isentropic vortex parameters administrating, respectively, both
+        !! the amplitude of the disturbance as well as its domain of influence.
+
+        real(kind(0d0)) :: a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 !<
+        !! The parameters needed for the spherical harmonic patch
+
+        logical :: non_axis_sym
 
         real(kind(0d0)), dimension(3) :: normal !<
         !! Normal vector indicating the orientation of the patch. It is specified
diff --git a/src/common/m_helper.fpp b/src/common/m_helper.fpp
index b6d48729..a2b77082 100644
--- a/src/common/m_helper.fpp
+++ b/src/common/m_helper.fpp
@@ -73,8 +73,8 @@ contains
             lE = q
         end if
 
-        if (allocated(fd_coeff_s)) deallocate (fd_coeff_s)
-        allocate (fd_coeff_s(-fd_number_in:fd_number_in, lb:lE))
+        if (allocated(fd_coeff_s)) deallocate(fd_coeff_s)
+        allocate(fd_coeff_s(-fd_number_in:fd_number_in, lb:lE))
 
         ! Computing the 1st order finite-difference coefficients
         if (fd_order_in == 1) then
@@ -83,7 +83,6 @@ contains
                 fd_coeff_s(0, i) = -1d0/(s_cc(i + 1) - s_cc(i))
                 fd_coeff_s(1, i) = -fd_coeff_s(0, i)
             end do
-
             ! Computing the 2nd order finite-difference coefficients
         elseif (fd_order_in == 2) then
             do i = lB, lE
@@ -91,7 +90,6 @@ contains
                 fd_coeff_s(0, i) = 0d0
                 fd_coeff_s(1, i) = -fd_coeff_s(-1, i)
             end do
-
             ! Computing the 4th order finite-difference coefficients
         else
             do i = lB, lE
@@ -101,7 +99,6 @@ contains
                 fd_coeff_s(1, i) = -fd_coeff_s(-1, i)
                 fd_coeff_s(2, i) = -fd_coeff_s(-2, i)
             end do
-
         end if
 
     end subroutine s_compute_finite_difference_coefficients
diff --git a/src/common/m_phase_change.fpp b/src/common/m_phase_change.fpp
index f6372322..c13fa233 100644
--- a/src/common/m_phase_change.fpp
+++ b/src/common/m_phase_change.fpp
@@ -1,11 +1,3 @@
-!>
-!! @file m_phase_change.fpp
-!! @brief Contains module m_phasechange
-
-#:include 'macros.fpp'
-
-!> @brief This module is used to relax the model equations (6-eqn model)
-!> towards pressure and temperature (6-eqn to 4-eqn), and (if wanted) Gibbs free
 !> energies (6-eqn to 4-eqn) equilibrium through an infinitely fast (algebraic)
 !> procedure.
 module m_phase_change
@@ -356,8 +348,9 @@ contains
 
         ! Newton Solver for the pT-equilibrium
         ns = 0
-        ! change this relative error metric. 1E4 is just arbitrary
-        do while ((DABS(pS - pO) > palpha_eps) .and. (DABS((pS - pO)/pO) > palpha_eps/1e4) .or. (ns == 0))
+        ! change this relative error metric. 1E4 is arbitrary
+        do while ((DABS(pS - pO) > palpha_eps) .and. &
+                  (DABS((pS - pO)/pO) > palpha_eps/1d4) .or. (ns == 0))
 
             ! increasing counter
             ns = ns + 1
diff --git a/src/common/m_variables_conversion.fpp b/src/common/m_variables_conversion.fpp
index 46436cb8..5652470a 100644
--- a/src/common/m_variables_conversion.fpp
+++ b/src/common/m_variables_conversion.fpp
@@ -22,6 +22,7 @@ module m_variables_conversion
     use m_helper_basic         !< Functions to compare floating point numbers
 
     use m_helper
+
     ! ==========================================================================
 
     implicit none
@@ -145,8 +146,8 @@ contains
         else
             pres = (pref + pi_inf)* &
                    (energy/ &
-                    (rhoref*(1 - alf)) &
-                    )**(1/gamma + 1) - pi_inf
+                    (rhoref*(1.d0 - alf)) &
+                    )**(1.d0/gamma + 1.d0) - pi_inf
         end if
 
         if (hypoelasticity .and. present(G)) then
@@ -164,11 +165,7 @@ contains
                 end if
             end do
 
-            pres = ( &
-                   energy - &
-                   0.5d0*(mom**2.d0)/rho - &
-                   pi_inf - qv - E_e &
-                   )/gamma
+            pres = (energy - 0.5d0*(mom**2.d0)/rho - pi_inf - qv - E_e)/gamma
 
         end if
 
@@ -409,7 +406,6 @@ contains
             pi_inf = pi_inf + alpha_K(i)*pi_infs(i)
             qv = qv + alpha_rho_K(i)*qvs(i)
         end do
-
 #ifdef MFC_SIMULATION
         ! Computing the shear and bulk Reynolds numbers from species analogs
         do i = 1, 2
@@ -427,6 +423,7 @@ contains
 #endif
 
         if (present(G_K)) then
+            !TODO Check our mixture rule? Replace with Cauchy numbers, make code nondimensional
             G_K = 0d0
             do i = 1, num_fluids
                 G_K = G_K + alpha_K(i)*G(i)
@@ -502,6 +499,7 @@ contains
             G_K = 0d0
             do i = 1, num_fluids
                 !TODO: change to use Gs directly here?
+                !TODO: Make this changes as well for GPUs
                 G_K = G_K + alpha_K(i)*G(i)
             end do
             G_K = max(0d0, G_K)
@@ -679,7 +677,6 @@ contains
             do i = 1, nb
                 bubrs(i) = bub_idx%rs(i)
             end do
-
             !$acc update device(bubrs)
         end if
 
@@ -862,7 +859,7 @@ contains
 
         integer :: i, j, k, l, q !< Generic loop iterators
 
-        real(kind(0.d0)) :: ntmp
+        real(kind(0d0)) :: ntmp
 
         #:if MFC_CASE_OPTIMIZATION
 #ifndef MFC_SIMULATION
@@ -880,7 +877,7 @@ contains
             end if
         #:endif
 
-        !$acc parallel loop collapse(3) gang vector default(present) private(alpha_K, alpha_rho_K, Re_K, nRtmp, rho_K, gamma_K, pi_inf_K, qv_K, dyn_pres_K, R3tmp)
+        !$acc parallel loop collapse(3) gang vector default(present) private(alpha_K, alpha_rho_K, Re_K, nRtmp, rho_K, gamma_K, pi_inf_K, qv_K, dyn_pres_K, R3tmp, G_K)
         do l = izb, ize
             do k = iyb, iye
                 do j = ixb, ixe
@@ -900,7 +897,7 @@ contains
                     if (model_eqns /= 4) then
 #ifdef MFC_SIMULATION
                         ! If in simulation, use acc mixture subroutines
-                        if (hypoelasticity) then
+                        if (elasticity) then
                             call s_convert_species_to_mixture_variables_acc(rho_K, gamma_K, pi_inf_K, qv_K, alpha_K, &
                                                                             alpha_rho_K, Re_K, j, k, l, G_K, Gs)
                         else if (bubbles) then
@@ -912,7 +909,7 @@ contains
                         end if
 #else
                         ! If pre-processing, use non acc mixture subroutines
-                        if (hypoelasticity) then
+                        if (elasticity) then
                             call s_convert_to_mixture_variables(qK_cons_vf, j, k, l, &
                                                                 rho_K, gamma_K, pi_inf_K, qv_K, Re_K, G_K, fluid_pp(:)%G)
                         else
@@ -988,7 +985,7 @@ contains
                             qK_prim_vf(i)%sf(j, k, l) = qK_cons_vf(i)%sf(j, k, l) &
                                                         /rho_K
                             ! subtracting elastic contribution for pressure calculation
-                            if (G_K > 1000) then !TODO: check if stable for >0
+                            if (G_K .gt. verysmall) then !TODO: check if stable for >0
                                 qK_prim_vf(E_idx)%sf(j, k, l) = qK_prim_vf(E_idx)%sf(j, k, l) - &
                                                                 ((qK_prim_vf(i)%sf(j, k, l)**2d0)/(4d0*G_K))/gamma_K
                                 ! extra terms in 2 and 3D
@@ -1002,6 +999,17 @@ contains
                         end do
                     end if
 
+                    if (hyperelasticity) then
+                       !$acc loop seq
+                       do i = strxb, strxe
+                            qK_prim_vf(i)%sf(j, k, l) = qK_cons_vf(i)%sf(j, k, l)/rho_K
+                       end do
+                       !$acc loop seq
+                       do i = xibeg, xiend
+                          qK_prim_vf(i)%sf(j, k, l) = qK_cons_vf(i)%sf(j, k, l)/rho_K
+                       end do
+                    end if
+
                     !$acc loop seq
                     do i = advxb, advxe
                         qK_prim_vf(i)%sf(j, k, l) = qK_cons_vf(i)%sf(j, k, l)
@@ -1016,7 +1024,9 @@ contains
         end do
         !$acc end parallel loop
 
-    end subroutine s_convert_conservative_to_primitive_variables
+        !print *, 'I got here AA'
+
+    end subroutine s_convert_conservative_to_primitive_variables ! ---------
 
     !>  The following procedure handles the conversion between
         !!      the primitive variables and the conservative variables.
@@ -1029,13 +1039,8 @@ contains
     subroutine s_convert_primitive_to_conservative_variables(q_prim_vf, &
                                                              q_cons_vf)
 
-        type(scalar_field), &
-            dimension(sys_size), &
-            intent(in) :: q_prim_vf
-
-        type(scalar_field), &
-            dimension(sys_size), &
-            intent(inout) :: q_cons_vf
+        type(scalar_field), dimension(sys_size), intent(in) :: q_prim_vf
+        type(scalar_field), dimension(sys_size), intent(inout) :: q_cons_vf
 
         ! Density, specific heat ratio function, liquid stiffness function
         ! and dynamic pressure, as defined in the incompressible flow sense,
@@ -1144,10 +1149,10 @@ contains
                     end if
 
                     if (hypoelasticity) then
-                        do i = stress_idx%beg, stress_idx%end
+                        do i = strxb, strxe
                             q_cons_vf(i)%sf(j, k, l) = rho*q_prim_vf(i)%sf(j, k, l)
                             ! adding elastic contribution
-                            if (G > 1000) then
+                            if (G .gt. verysmall) then
                                 q_cons_vf(E_idx)%sf(j, k, l) = q_cons_vf(E_idx)%sf(j, k, l) + &
                                                                (q_prim_vf(i)%sf(j, k, l)**2d0)/(4d0*G)
                                 ! extra terms in 2 and 3D
@@ -1161,6 +1166,19 @@ contains
                         end do
                     end if
 
+                    ! using \rho xi as the conservative formulation stated in Kamrin et al. JFM 2022
+                    if (hyperelasticity) then
+                       ! adding the elastic contribution
+                       ! Multiply \tau to \rho \tau
+                       do i = strxb, strxe
+                          q_cons_vf(i)%sf(j, k, l) = rho*q_prim_vf(i)%sf(j, k, l)
+                       end do
+                       ! Multiply \xi to \rho \xi
+                       do i = xibeg, xiend
+                          q_cons_vf(i)%sf(j, k, l) = rho*q_prim_vf(i)%sf(j, k, l)
+                       end do
+                    end if
+
                     if (.not. f_is_default(sigma)) then
                         q_cons_vf(c_idx)%sf(j, k, l) = q_prim_vf(c_idx)%sf(j, k, l)
                     end if
@@ -1168,7 +1186,6 @@ contains
                 end do
             end do
         end do
-
 #else
         if (proc_rank == 0) then
             call s_mpi_abort('Conversion from primitive to '// &
@@ -1176,7 +1193,6 @@ contains
                              'implemented. Exiting ...')
         end if
 #endif
-
     end subroutine s_convert_primitive_to_conservative_variables
 
     !>  The following subroutine handles the conversion between
@@ -1252,7 +1268,7 @@ contains
                     end do
 
                     pres_K = qK_prim_vf(j, k, l, E_idx)
-                    if (hypoelasticity) then
+                    if (elasticity) then
                         call s_convert_species_to_mixture_variables_acc(rho_K, gamma_K, pi_inf_K, qv_K, &
                                                                         alpha_K, alpha_rho_K, Re_K, &
                                                                         j, k, l, G_K, Gs)
@@ -1310,10 +1326,11 @@ contains
             end do
         end do
 #endif
-
     end subroutine s_convert_primitive_to_flux_variables
 
-    subroutine s_finalize_variables_conversion_module
+    subroutine s_finalize_variables_conversion_module() ! ------------------
+
+        integer :: i !< Generic loop iterators
 
         ! Deallocating the density, the specific heat ratio function and the
         ! liquid stiffness function
diff --git a/src/post_process/m_data_input.f90 b/src/post_process/m_data_input.f90
index 567816f7..bbd063df 100644
--- a/src/post_process/m_data_input.f90
+++ b/src/post_process/m_data_input.f90
@@ -370,7 +370,7 @@ contains
                 NVARS_MOK = int(sys_size, MPI_OFFSET_KIND)
 
                 ! Read the data for each variable
-                if (bubbles .or. hypoelasticity) then
+                if (bubbles .or. elasticity) then
                     do i = 1, sys_size
                         var_MOK = int(i, MPI_OFFSET_KIND)
 
@@ -444,7 +444,7 @@ contains
                 NVARS_MOK = int(sys_size, MPI_OFFSET_KIND)
 
                 ! Read the data for each variable
-                if (bubbles .or. hypoelasticity) then
+                if (bubbles .or. elasticity) then
                     do i = 1, sys_size
                         var_MOK = int(i, MPI_OFFSET_KIND)
 
diff --git a/src/post_process/m_data_output.fpp b/src/post_process/m_data_output.fpp
index 7aa7e873..e68c021b 100644
--- a/src/post_process/m_data_output.fpp
+++ b/src/post_process/m_data_output.fpp
@@ -16,6 +16,8 @@ module m_data_output
 
     use m_global_parameters     ! Global parameters for the code
 
+    use m_derived_variables     !< Procedures used to compute quantities derived
+
     use m_mpi_proxy             ! Message passing interface (MPI) module proxy
 
     use m_compile_specific
@@ -27,9 +29,15 @@ module m_data_output
 
     private; public :: s_initialize_data_output_module, &
  s_open_formatted_database_file, &
+ s_open_intf_data_file, &
+ s_open_energy_data_file, &
  s_write_grid_to_formatted_database_file, &
  s_write_variable_to_formatted_database_file, &
+ s_write_intf_data_file, &
+ s_write_energy_data_file, &
  s_close_formatted_database_file, &
+ s_close_intf_data_file, &
+ s_close_energy_data_file, &
  s_finalize_data_output_module
 
     ! Including the Silo Fortran interface library that features the subroutines
@@ -531,7 +539,40 @@ contains
 
     end subroutine s_open_formatted_database_file
 
-    subroutine s_write_grid_to_formatted_database_file(t_step)
+    subroutine s_open_intf_data_file() ! ------------------------
+
+        character(LEN=path_len + 3*name_len) :: file_path !<
+              !! Relative path to a file in the case directory
+
+        write (file_path, '(A)') '/intf_data.dat'
+        file_path = trim(case_dir)//trim(file_path)
+
+        ! Opening the simulation data file
+        open (211, FILE=trim(file_path), &
+              FORM='formatted', &
+              POSITION='append', &
+              STATUS='unknown')
+
+    end subroutine s_open_intf_data_file ! ---------------------------------------
+
+    subroutine s_open_energy_data_file() ! ------------------------
+
+        character(LEN=path_len + 3*name_len) :: file_path !<
+              !! Relative path to a file in the case directory
+
+        write (file_path, '(A)') '/eng_data.dat'
+        file_path = trim(case_dir)//trim(file_path)
+
+        ! Opening the simulation data file
+        open (251, FILE=trim(file_path), &
+              FORM='formatted', &
+              POSITION='append', &
+              STATUS='unknown')
+
+    end subroutine s_open_energy_data_file ! ----------------------------------------
+
+    subroutine s_write_grid_to_formatted_database_file(t_step) ! -----------
+
         ! Description: The general objective of this subroutine is to write the
         !              necessary grid data to the formatted database file, for
         !              the current time-step, t_step. The local processor will
@@ -939,7 +980,196 @@ contains
 
     end subroutine s_write_variable_to_formatted_database_file
 
-    subroutine s_close_formatted_database_file
+    subroutine s_write_intf_data_file(q_prim_vf)
+
+        type(scalar_field), dimension(sys_size), intent(IN) :: q_prim_vf
+        integer :: i, j, k, l, w, cent !< Generic loop iterators
+        integer :: ierr, counter, root !< number of data points extracted to fit shape to SH perturbations
+        real(kind(0d0)), dimension(num_fluids) :: alpha, vol_fluid, xcom, ycom, zcom
+        real(kind=8), parameter :: pi = 4.d0*datan(1.d0)
+        real(kind(0d0)), allocatable :: x_td(:), y_td(:), x_d1(:), y_d1(:), y_d(:), x_d(:)
+        real(kind(0d0)) :: axp, axm, ayp, aym, azm, azp, tgp, euc_d, thres, maxalph_loc, maxalph_glb
+
+        allocate (x_d1(m*n))
+        allocate (y_d1(m*n))
+        counter = 0
+        maxalph_loc = 0d0
+        do k = 0, p
+            do j = 0, n
+                do i = 0, m
+                    if (q_prim_vf(E_idx + 2)%sf(i, j, k) > maxalph_loc) then
+                        maxalph_loc = q_prim_vf(E_idx + 2)%sf(i, j, k)
+                    end if
+                end do
+            end do
+        end do
+
+        call s_mpi_allreduce_max(maxalph_loc, maxalph_glb)
+        if (p > 0) then
+                do l = 0, p
+                    if (z_cc(l) < dz(l) .and. z_cc(l) > 0) then
+                        cent = l
+                    end if
+                end do
+        else
+                cent = 0
+        end if
+
+        thres = 0.9d0*maxalph_glb
+        do k = 0, n
+            OLoop: do j = 0, m
+                axp = q_prim_vf(E_idx + 2)%sf(j + 1, k, cent)
+                axm = q_prim_vf(E_idx + 2)%sf(j, k, cent)
+                ayp = q_prim_vf(E_idx + 2)%sf(j, k + 1, cent)
+                aym = q_prim_vf(E_idx + 2)%sf(j, k, cent)
+                if ((axp > thres .and. axm < thres) .or. (axp < thres .and. axm > thres) &
+                    .or. (ayp > thres .and. aym < thres) .or. (ayp < thres .and. aym > thres)) then
+                    if (counter == 0) then
+                        counter = counter + 1
+                        x_d1(counter) = x_cc(j)
+                        y_d1(counter) = y_cc(k)
+                        euc_d = sqrt((x_cc(j) - x_d1(i))**2 + (y_cc(k) - y_d1(i))**2)
+                        tgp = sqrt(dx(j)**2 + dy(k)**2)
+                    else
+                        euc_d = dsqrt((x_cc(j) - x_d1(i))**2 + (y_cc(k) - y_d1(i))**2)
+                        tgp = dsqrt(dx(j)**2 + dy(k)**2)
+                        do i = 1, counter
+                            if (euc_d < tgp) then
+                                cycle OLoop
+                            elseif (euc_d > tgp .and. i == counter) then
+                                counter = counter + 1
+                                x_d1(counter) = x_cc(j)
+                                y_d1(counter) = y_cc(k)
+
+                            end if
+                        end do
+                    end if
+                end if
+            end do OLoop
+        end do
+
+        allocate (y_d(counter))
+        allocate (x_d(counter))
+        do i = 1, counter
+            y_d(i) = y_d1(i)
+            x_d(i) = x_d1(i)
+        end do
+        root = 0
+
+        call s_mpi_gather_data(x_d, counter, x_td, root)
+        call s_mpi_gather_data(y_d, counter, y_td, root)
+        if (proc_rank == 0) then
+            do i = 1, size(x_td)
+                if (i == size(x_td)) then
+                    write (211, '(F12.9,1X,F12.9,1X,I4)') &
+                        x_td(i), y_td(i), size(x_td)
+                else
+                    write (211, '(F12.9,1X,F12.9,1X,F3.1)') &
+                        x_td(i), y_td(i), 0d0
+                end if
+            end do
+        end if
+
+    end subroutine s_write_intf_data_file ! -----------------------------------
+
+    subroutine s_write_energy_data_file(q_prim_vf, q_cons_vf)
+        type(scalar_field), dimension(sys_size), intent(IN) :: q_prim_vf, q_cons_vf
+        real(kind(0d0)) :: Elk, Egk, Elp, Egint, Vb, Vl, pres_av, Et
+        real(kind(0d0)) :: rho, pres, dV, tmp, gamma, pi_inf, MaxMa, MaxMa_glb, maxvel, c, Ma, H
+        real(kind(0d0)), dimension(num_dims) :: vel
+        real(kind(0d0)), dimension(num_fluids) :: gammas, pi_infs, adv
+        integer :: i, j, k, l, s !looping indicies
+        integer :: ierr, counter, root !< number of data points extracted to fit shape to SH perturbations
+
+        Egk = 0d0
+        Elp = 0d0
+        Egint = 0d0
+        Vb = 0d0
+        maxvel = 0d0
+        MaxMa = 0d0
+        Vl = 0d0
+        Elk = 0d0
+        Et = 0d0
+        Vb = 0d0
+        dV = 0d0
+        pres_av = 0d0
+        pres = 0d0
+        do k = 0, p
+            do j = 0, n
+                do i = 0, m
+                    pres = 0d0
+                    dV = dx(i)*dy(j)*dz(k)
+                    rho = 0d0
+                    gamma = 0d0
+                    pi_inf = 0d0
+                    pres = q_prim_vf(E_idx)%sf(i, j, k)
+                    Egint = Egint + q_prim_vf(E_idx + 2)%sf(i, j, k)*(fluid_pp(2)%gamma*pres)*dV
+                    do s = 1, num_dims
+                        vel(s) = q_prim_vf(num_fluids + s)%sf(i, j, k)
+                        Egk = Egk + 0.5d0*q_prim_vf(E_idx + 2)%sf(i, j, k)*q_prim_vf(2)%sf(i, j, k)*vel(s)*vel(s)*dV
+                        Elk = Elk + 0.5d0*q_prim_vf(E_idx + 1)%sf(i, j, k)*q_prim_vf(1)%sf(i, j, k)*vel(s)*vel(s)*dV
+                        if (dabs(vel(s)) > maxvel) then
+                            maxvel = dabs(vel(s))
+                        end if
+                    end do
+                    do l = 1, adv_idx%end - E_idx
+                        adv(l) = q_prim_vf(E_idx + l)%sf(i, j, k)
+                        gamma = gamma + adv(l)*fluid_pp(l)%gamma
+                        pi_inf = pi_inf + adv(l)*fluid_pp(l)%pi_inf
+                        rho = rho + adv(l)*q_prim_vf(l)%sf(i, j, k)
+                    end do
+
+                    H = ((gamma + 1d0)*pres + pi_inf)/rho
+
+                    call s_compute_speed_of_sound(pres, rho, &
+                                                  gamma, pi_inf, &
+                                                  H, adv, 0d0, c)
+
+                    Ma = maxvel/c
+                    if (Ma > MaxMa .and. adv(1) > 1.0d0 - 1.0d-10) then
+                        MaxMa = Ma
+                    end if
+                    Vl = Vl + adv(1)*dV
+                    Vb = Vb + adv(2)*dV
+                    pres_av = pres_av + adv(1)*pres*dV
+                    Et = Et + q_cons_vf(E_idx)%sf(i, j, k)*dV
+                end do
+            end do
+        end do
+
+        tmp = pres_av
+        call s_mpi_allreduce_sum(tmp, pres_av)
+        tmp = Vl
+        call s_mpi_allreduce_sum(tmp, Vl)
+
+        call s_mpi_allreduce_max(MaxMa, MaxMa_glb)
+        tmp = Elk
+        call s_mpi_allreduce_sum(tmp, Elk)
+        tmp = Egint
+        call s_mpi_allreduce_sum(tmp, Egint)
+        tmp = Egk
+        call s_mpi_allreduce_sum(tmp, Egk)
+        tmp = Vb
+        call s_mpi_allreduce_sum(tmp, Vb)
+        tmp = Et
+        call s_mpi_allreduce_sum(tmp, Et)
+
+        Elp = pres_av/Vl*Vb
+        if (proc_rank == 0) then
+            write (251, '(10X, 8F24.8)') &
+                Elp, &
+                Egint, &
+                Elk, &
+                Egk, &
+                Et, &
+                Vb, &
+                Vl, &
+                MaxMa_glb
+        end if
+
+    end subroutine s_write_energy_data_file
+
+    subroutine s_close_formatted_database_file() ! -------------------------
         ! Description: The purpose of this subroutine is to close any formatted
         !              database file(s) that may be opened at the time-step that
         !              is currently being post-processed. The root process must
@@ -966,7 +1196,19 @@ contains
 
     end subroutine s_close_formatted_database_file
 
-    subroutine s_finalize_data_output_module
+    subroutine s_close_intf_data_file() ! -----------------------
+
+        close (211)
+
+    end subroutine s_close_intf_data_file !---------------------
+
+    subroutine s_close_energy_data_file() ! -----------------------
+
+        close (251)
+
+    end subroutine s_close_energy_data_file !---------------------
+
+    subroutine s_finalize_data_output_module() ! -------------------------
         ! Description: Deallocation procedures for the module
 
         ! Deallocating the generic storage employed for the flow variable(s)
diff --git a/src/post_process/m_global_parameters.fpp b/src/post_process/m_global_parameters.fpp
index 0e5401f1..fa6941cb 100644
--- a/src/post_process/m_global_parameters.fpp
+++ b/src/post_process/m_global_parameters.fpp
@@ -94,6 +94,10 @@ module m_global_parameters
     logical :: mixture_err     !< Mixture error limiter
     logical :: alt_soundspeed  !< Alternate sound speed
     logical :: hypoelasticity  !< Turn hypoelasticity on
+    logical :: hyperelasticity !< Turn hyperelasticity on
+    logical :: elasticity      !< elasticity modeling, true for hyper or hypo
+    integer :: b_size          !< Number of components in the b tensor
+    integer :: tensor_size     !< Number of components in the nonsymmetric tensor
     !> @}
 
     !> @name Annotations of the structure, i.e. the organization, of the state vectors
@@ -109,6 +113,7 @@ module m_global_parameters
     integer :: alf_idx                             !< Index of specific heat ratio func. eqn.
     integer :: pi_inf_idx                          !< Index of liquid stiffness func. eqn.
     type(int_bounds_info) :: stress_idx            !< Indices of elastic stresses
+    type(int_bounds_info) :: xi_idx                !< Indexes of first and last reference map eqns.
     integer :: c_idx                               !< Index of color function
     !> @}
 
@@ -118,6 +123,7 @@ module m_global_parameters
     !> @}
 
     logical :: parallel_io    !< Format of the data files
+    logical :: sim_data
     logical :: file_per_process !< output format
 
     integer, allocatable, dimension(:) :: proc_coords !<
@@ -255,6 +261,7 @@ module m_global_parameters
     integer :: intxb, intxe
     integer :: bubxb, bubxe
     integer :: strxb, strxe
+    integer :: xibeg, xiend
     !> @}
 
 contains
@@ -286,7 +293,10 @@ contains
         alt_soundspeed = .false.
         relax = .false.
         relax_model = dflt_int
+
         hypoelasticity = .false.
+        hyperelasticity = .false.
+        elasticity = .false.
 
         bc_x%beg = dflt_int; bc_x%end = dflt_int
         bc_y%beg = dflt_int; bc_y%end = dflt_int
@@ -335,6 +345,7 @@ contains
         omega_wrt = .false.
         qm_wrt = .false.
         schlieren_wrt = .false.
+        sim_data = .false.
         cf_wrt = .false.
         ib = .false.
 
@@ -486,12 +497,24 @@ contains
 
             end if
 
-            if (hypoelasticity) then
+            if (hypoelasticity .or. hyperelasticity) then
+                elasticity = .true.
                 stress_idx%beg = sys_size + 1
                 stress_idx%end = sys_size + (num_dims*(num_dims + 1))/2
+                ! number of distinct stresses is 1 in 1D, 3 in 2D, 6 in 3D
                 sys_size = stress_idx%end
             end if
 
+            if (hyperelasticity) then
+                xi_idx%beg = sys_size + 1
+                xi_idx%end = sys_size + num_dims
+                ! adding three more equations for the \xi field and the elastic energy
+                sys_size = xi_idx%end + 1
+                ! number of entries in the symmetric btensor plus the jacobian
+                b_size = (num_dims*(num_dims + 1))/2 + 1
+                tensor_size = num_dims**2 + 1
+            end if
+
             if (.not. f_is_default(sigma)) then
                 c_idx = sys_size + 1
                 sys_size = c_idx
@@ -517,6 +540,24 @@ contains
             sys_size = internalEnergies_idx%end
             alf_idx = 1 ! dummy, cannot actually have a void fraction
 
+            if (hypoelasticity .or. hyperelasticity) then
+              elasticity = .true.
+              stress_idx%beg = sys_size + 1
+              stress_idx%end = sys_size + (num_dims*(num_dims + 1))/2
+              ! number of stresses is 1 in 1D, 3 in 2D, 6 in 3D
+              sys_size = stress_idx%end
+            end if
+
+            if (hyperelasticity) then
+                xi_idx%beg = sys_size + 1
+                xi_idx%end = sys_size + num_dims
+                ! adding three more equations for the \xi field and the elastic energy
+                sys_size = xi_idx%end + 1
+                ! number of entries in the symmetric btensor plus the jacobian
+                b_size = (num_dims*(num_dims + 1))/2 + 1
+                tensor_size = num_dims**2 + 1
+            end if
+
             if (.not. f_is_default(sigma)) then
                 c_idx = sys_size + 1
                 sys_size = c_idx
@@ -590,6 +631,8 @@ contains
         strxe = stress_idx%end
         intxb = internalEnergies_idx%beg
         intxe = internalEnergies_idx%end
+        xibeg = xi_idx%beg
+        xiend = xi_idx%end
         ! ==================================================================
 
 #ifdef MFC_MPI
diff --git a/src/post_process/m_mpi_proxy.fpp b/src/post_process/m_mpi_proxy.fpp
index a5dffdb4..5da4c74e 100644
--- a/src/post_process/m_mpi_proxy.fpp
+++ b/src/post_process/m_mpi_proxy.fpp
@@ -141,6 +141,38 @@ contains
 
     end subroutine s_initialize_mpi_proxy_module
 
+    subroutine s_mpi_gather_data(my_vector, counts, gathered_vector, root)
+
+#ifdef MFC_MPI
+
+        implicit none
+        integer, intent(in) :: counts          ! Array of vector lengths for each process
+        real(kind(0d0)), intent(in), dimension(counts) :: my_vector   ! Input vector on each process
+        integer, intent(in) :: root               ! Rank of the root process
+        real(kind(0d0)), allocatable, intent(out) :: gathered_vector(:) ! Gathered vector on the root process
+
+        integer :: i, offset, ierr
+        integer, allocatable :: recounts(:), displs(:)
+
+        allocate (recounts(num_procs))
+
+        call MPI_GATHER(counts, 1, MPI_INTEGER, recounts, 1, MPI_INTEGER, root, &
+                        MPI_COMM_WORLD, ierr)
+
+        allocate (displs(size(recounts)))
+
+        displs(1) = 0
+
+        do i = 2, size(recounts)
+            displs(i) = displs(i - 1) + recounts(i - 1)
+        end do
+
+        allocate (gathered_vector(sum(recounts)))
+        call MPI_GATHERV(my_vector, counts, MPI_DOUBLE_PRECISION, gathered_vector, recounts, displs, MPI_DOUBLE_PRECISION, &
+                         root, MPI_COMM_WORLD, ierr)
+#endif
+    end subroutine s_mpi_gather_data
+
     !>  Since only processor with rank 0 is in charge of reading
         !!      and checking the consistency of the user provided inputs,
         !!      these are not available to the remaining processors. This
@@ -164,11 +196,11 @@ contains
 
         #:for VAR in [ 'cyl_coord', 'mpp_lim', 'mixture_err',                  &
             & 'alt_soundspeed', 'hypoelasticity', 'parallel_io', 'rho_wrt',    &
-            & 'E_wrt', 'pres_wrt', 'gamma_wrt',                                &
+            & 'E_wrt', 'pres_wrt', 'gamma_wrt', 'sim_data',                    &
             & 'heat_ratio_wrt', 'pi_inf_wrt', 'pres_inf_wrt', 'cons_vars_wrt', &
             & 'prim_vars_wrt', 'c_wrt', 'qm_wrt','schlieren_wrt', 'bubbles', 'qbmm',   &
             & 'polytropic', 'polydisperse', 'file_per_process', 'relax', 'cf_wrt',     &
-            & 'adv_n', 'ib' ]
+            & 'adv_n', 'ib', 'hyperelasticity' ]
             call MPI_BCAST(${VAR}$, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
         #:endfor
 
diff --git a/src/post_process/m_start_up.f90 b/src/post_process/m_start_up.f90
index ed1003ff..60d3d094 100644
--- a/src/post_process/m_start_up.f90
+++ b/src/post_process/m_start_up.f90
@@ -74,7 +74,8 @@ contains
             parallel_io, rhoref, pref, bubbles, qbmm, sigR, &
             R0ref, nb, polytropic, thermal, Ca, Web, Re_inv, &
             polydisperse, poly_sigma, file_per_process, relax, &
-            relax_model, cf_wrt, sigma, adv_n, ib
+            relax_model, cf_wrt, sigma, adv_n, ib, sim_data, &
+            hyperelasticity
 
         ! Inquiring the status of the post_process.inp file
         file_loc = 'post_process.inp'
@@ -148,9 +149,9 @@ contains
                 (t_step_stop - t_step_start)/t_step_save + 1, &
                 t_step
         end if
-
         ! Populating the grid and conservative variables
         call s_read_data_files(t_step)
+
         ! Populating the buffer regions of the grid variables
         if (buff_size > 0) then
             call s_populate_grid_variables_buffer_regions()
@@ -163,6 +164,7 @@ contains
 
         ! Converting the conservative variables to the primitive ones
         call s_convert_conservative_to_primitive_variables(q_cons_vf, q_prim_vf)
+
     end subroutine s_perform_time_step
 
     subroutine s_save_data(t_step, varname, pres, c, H)
@@ -176,6 +178,16 @@ contains
         ! Opening a new formatted database file
         call s_open_formatted_database_file(t_step)
 
+        if (sim_data .and. proc_rank == 0) then
+            call s_open_intf_data_file()
+            call s_open_energy_data_file()
+        end if
+
+        if (sim_data) then
+            call s_write_intf_data_file(q_prim_vf)
+            call s_write_energy_data_file(q_prim_vf, q_cons_vf)
+        end if
+
         ! Adding the grid to the formatted database file
         call s_write_grid_to_formatted_database_file(t_step)
 
@@ -304,22 +316,34 @@ contains
 
         end if
         ! ----------------------------------------------------------------------
-
         ! Adding the elastic shear stresses to the formatted database file -----
-        if (hypoelasticity) then
+        if (elasticity) then
             do i = 1, stress_idx%end - stress_idx%beg + 1
                 if (prim_vars_wrt) then
                     q_sf = q_prim_vf(i - 1 + stress_idx%beg)%sf( &
                            -offset_x%beg:m + offset_x%end, &
                            -offset_y%beg:n + offset_y%end, &
                            -offset_z%beg:p + offset_z%end)
-
                     write (varname, '(A,I0)') 'tau', i
                     call s_write_variable_to_formatted_database_file(varname, t_step)
                 end if
                 varname(:) = ' '
             end do
         end if
+        if (hyperelasticity) then
+            do i = 1, xiend - xibeg + 1
+                if (prim_vars_wrt) then
+                    q_sf = q_prim_vf(i - 1 + xibeg)%sf( &
+                           -offset_x%beg:m + offset_x%end, &
+                           -offset_y%beg:n + offset_y%end, &
+                           -offset_z%beg:p + offset_z%end)
+                    write (varname, '(A,I0)') 'xi', i
+                    call s_write_variable_to_formatted_database_file(varname, t_step)
+                end if
+                varname(:) = ' '
+            end do
+        end if
+
         ! ----------------------------------------------------------------------
 
         ! Adding the pressure to the formatted database file -------------------
@@ -625,8 +649,19 @@ contains
             end if
         end if
 
+!        if (proc_rank == 0 .and. sim_data) then
+!            close (211)
+!            close (251)
+!        end if
+
+        if (sim_data .and. proc_rank == 0) then
+            call s_close_intf_data_file()
+            call s_close_energy_data_file()
+        end if
+
         ! Closing the formatted database file
         call s_close_formatted_database_file()
+
     end subroutine s_save_data
 
     subroutine s_initialize_modules
@@ -682,6 +717,11 @@ contains
         ! Disassociate pointers for serial and parallel I/O
         s_read_data_files => null()
 
+!        if (sim_data .and. proc_rank == 0) then
+!            call s_close_intf_data_file()
+!            call s_close_energy_data_file()
+!        end if
+
         ! Deallocation procedures for the modules
         call s_finalize_data_output_module()
         call s_finalize_derived_variables_module()
diff --git a/src/post_process/p_main.fpp b/src/post_process/p_main.fpp
index c780ce9a..ede32ed7 100644
--- a/src/post_process/p_main.fpp
+++ b/src/post_process/p_main.fpp
@@ -39,6 +39,7 @@ program p_main
 
     ! Time-Marching Loop =======================================================
     do
+
         call s_perform_time_step(t_step)
 
         call s_save_data(t_step, varname, pres, c, H)
diff --git a/src/pre_process/include/2dHardcodedIC.fpp b/src/pre_process/include/2dHardcodedIC.fpp
index 7d6ee960..394f560b 100644
--- a/src/pre_process/include/2dHardcodedIC.fpp
+++ b/src/pre_process/include/2dHardcodedIC.fpp
@@ -2,8 +2,7 @@
 
     real(kind(0d0)) :: eps
     real(kind(0d0)) :: r, rmax, gam, umax, p0
-
-    real(kind(0d0)) :: rhoH, rhoL, pRef, pInt, h, lam, wl, amp, intH, alph
+    real(kind(0d0)) :: rhoH, rhoL, pRef, pInt, h, lam, wl, amp, intH, intL, alph
 
     eps = 1e-9
 
@@ -12,6 +11,7 @@
 #:def Hardcoded2D()
 
     select case (patch_icpp(patch_id)%hcid) ! 2D_hardcoded_ic example case
+
     case (200)
         if (y_cc(j) <= (-x_cc(i)**3 + 1)**(1d0/3d0)) then
             ! Volume Fractions
@@ -68,7 +68,7 @@
 
         q_prim_vf(contxb)%sf(i, j, 0) = q_prim_vf(E_idx)%sf(i, j, 0)**(1d0/gam)
 
-    case (204) ! Rayleigh-Taylor instability
+    case (204) ! Rayleigh-taylor problem
         rhoH = 3
         rhoL = 1
         pRef = 1e5
@@ -100,11 +100,42 @@
             q_prim_vf(E_idx)%sf(i, j, 0) = pInt + rhoL*9.81*(intH - y_cc(j))
         end if
 
+    case (205) ! 2D lung wave interaction problem
+        h = 0.0           !non dim origin y
+        lam = 1.0         !non dim lambda
+        amp = patch_icpp(patch_id)%a2         !to be changed later!       !non dim amplitude
+
+        intH = amp*sin(2*pi*x_cc(i)/lam - pi/2) + h
+
+        if (y_cc(j) > intH) then
+            q_prim_vf(contxb)%sf(i, j, 0) = patch_icpp(1)%alpha_rho(1)
+            q_prim_vf(contxe)%sf(i, j, 0) = patch_icpp(1)%alpha_rho(2)
+            q_prim_vf(E_idx)%sf(i, j, 0) = patch_icpp(1)%pres
+            q_prim_vf(advxb)%sf(i, j, 0) = patch_icpp(1)%alpha(1)
+            q_prim_vf(advxe)%sf(i, j, 0) = patch_icpp(1)%alpha(2)
+        end if
+
+    case (206) ! 2D lung wave interaction problem - horizontal domain
+        h = 0.0           !non dim origin y
+        lam = 1.0         !non dim lambda
+        amp = patch_icpp(patch_id)%a2
+
+        intL = amp*sin(2*pi*y_cc(j)/lam - pi/2) + h
+
+        if (x_cc(i) > intL) then        !this is the liquid
+            q_prim_vf(contxb)%sf(i, j, 0) = patch_icpp(1)%alpha_rho(1)
+            q_prim_vf(contxe)%sf(i, j, 0) = patch_icpp(1)%alpha_rho(2)
+            q_prim_vf(E_idx)%sf(i, j, 0) = patch_icpp(1)%pres
+            q_prim_vf(advxb)%sf(i, j, 0) = patch_icpp(1)%alpha(1)
+            q_prim_vf(advxe)%sf(i, j, 0) = patch_icpp(1)%alpha(2)
+        end if
+
     case default
         if (proc_rank == 0) then
             call s_int_to_str(patch_id, iStr)
             call s_mpi_abort("Invalid hcid specified for patch "//trim(iStr))
         end if
+
     end select
 
 #:enddef
diff --git a/src/pre_process/include/3dHardcodedIC.fpp b/src/pre_process/include/3dHardcodedIC.fpp
index 3d9a4e2f..4088fcc2 100644
--- a/src/pre_process/include/3dHardcodedIC.fpp
+++ b/src/pre_process/include/3dHardcodedIC.fpp
@@ -42,7 +42,20 @@
             pInt = pref + rhoH*9.81*(1.2 - intH)
             q_prim_vf(E_idx)%sf(i, j, k) = pInt + rhoL*9.81*(intH - y_cc(j))
         end if
-
+    
+    case (301) ! (3D lung geometry in X direction, |sin(*)+sin(*)|)
+        h = 0.0
+        lam = 1.0
+        amp = patch_icpp(patch_id)%a2
+        intH = amp*ABS((sin(2*pi*y_cc(j)/lam - pi/2) + sin(2*pi*z_cc(k)/lam - pi/2)) + h)
+        if (x_cc(i) > intH) then
+            q_prim_vf(contxb)%sf(i, j, k) = patch_icpp(1)%alpha_rho(1)
+            q_prim_vf(contxe)%sf(i, j, k) = patch_icpp(1)%alpha_rho(2)
+            q_prim_vf(E_idx)%sf(i, j, k) = patch_icpp(1)%pres
+            q_prim_vf(advxb)%sf(i, j, k) = patch_icpp(1)%alpha(1)
+            q_prim_vf(advxe)%sf(i, j, k) = patch_icpp(1)%alpha(2)
+        end if
+    
         ! Put your variable assignments here
     case default
         call s_int_to_str(patch_id, iStr)
diff --git a/src/pre_process/m_assign_variables.f90 b/src/pre_process/m_assign_variables.f90
index 9ff468a3..4a49c46a 100644
--- a/src/pre_process/m_assign_variables.f90
+++ b/src/pre_process/m_assign_variables.f90
@@ -276,6 +276,8 @@ contains
         real(kind(0d0)) :: orig_qv
         real(kind(0d0)) :: muR, muV
         real(kind(0d0)) :: R3bar
+        real(kind(0d0)) :: rcoord, theta, phi, xi_sph
+        real(kind(0d0)), dimension(3) :: xi_cart
 
         real(kind(0d0)), dimension(int(E_idx - mom_idx%beg)) :: vel    !< velocity
         real(kind(0d0)) :: pres   !< pressure
@@ -448,7 +450,7 @@ contains
         end do
 
         ! Elastic Shear Stress
-        if (hypoelasticity) then
+        if (elasticity) then
             do i = 1, (stress_idx%end - stress_idx%beg) + 1
                 q_prim_vf(i + stress_idx%beg - 1)%sf(j, k, l) = &
                     (eta*patch_icpp(patch_id)%tau_e(i) &
@@ -456,6 +458,32 @@ contains
             end do
         end if
 
+        ! Elastic Shear Stress
+        if (hyperelasticity) then
+
+            if (pre_stress) then ! pre stressed initial condition in spatial domain
+                rcoord = sqrt((x_cc(j)**2 + y_cc(k)**2 + z_cc(l)**2))
+                theta = atan2(y_cc(k), x_cc(j))
+                phi = atan2(sqrt(x_cc(j)**2 + y_cc(k)**2), z_cc(l))
+                !spherical coord, assuming Rmax=1
+                xi_sph = (rcoord**3 - R0ref**3 + 1d0)**(1d0/3d0)
+                xi_cart(1) = xi_sph*sin(phi)*cos(theta)
+                xi_cart(2) = xi_sph*sin(phi)*sin(theta)
+                xi_cart(3) = xi_sph*cos(phi)
+            else
+                xi_cart(1) = x_cc(j)
+                xi_cart(2) = y_cc(k)
+                xi_cart(3) = z_cc(l)
+            end if
+
+            ! assigning the reference map to the q_prim vector field
+            do i = 1, num_dims
+                q_prim_vf(i + xibeg - 1)%sf(j, k, l) = eta*xi_cart(i) + &
+                          (1d0 - eta)*orig_prim_vf(i + xibeg - 1)
+            end do
+
+        end if
+
         if (mpp_lim .and. bubbles) then
             !adjust volume fractions, according to modeled gas void fraction
             alf_sum%sf = 0d0
diff --git a/src/pre_process/m_check_patches.fpp b/src/pre_process/m_check_patches.fpp
index 4579f5bd..bda4418e 100644
--- a/src/pre_process/m_check_patches.fpp
+++ b/src/pre_process/m_check_patches.fpp
@@ -119,7 +119,8 @@ contains
                              patch_icpp(i)%geometry == 9 .or. &
                              patch_icpp(i)%geometry == 10 .or. &
                              patch_icpp(i)%geometry == 11 .or. &
-                             patch_icpp(i)%geometry == 12)) then
+                             patch_icpp(i)%geometry == 12 .or. &
+                             patch_icpp(i)%geometry == 14)) then
                 call s_check_supported_patch_smoothing(i)
             else
                 call s_check_unsupported_patch_smoothing(i)
diff --git a/src/pre_process/m_data_output.fpp b/src/pre_process/m_data_output.fpp
index 94d5d8fb..c0049095 100644
--- a/src/pre_process/m_data_output.fpp
+++ b/src/pre_process/m_data_output.fpp
@@ -638,6 +638,7 @@ contains
                     call MPI_FILE_WRITE_ALL(ifile, MPI_IO_DATA%var(i)%sf, data_size, &
                                             MPI_DOUBLE_PRECISION, status, ierr)
                 end do
+
             end if
 
             call MPI_FILE_CLOSE(ifile, ierr)
diff --git a/src/pre_process/m_global_parameters.fpp b/src/pre_process/m_global_parameters.fpp
index 57dcda37..78e8c293 100644
--- a/src/pre_process/m_global_parameters.fpp
+++ b/src/pre_process/m_global_parameters.fpp
@@ -20,11 +20,11 @@ module m_global_parameters
     implicit none
 
     ! Logistics ================================================================
-    integer :: num_procs                 !< Number of processors
-    character(LEN=path_len) :: case_dir  !< Case folder location
-    logical :: old_grid                  !< Use existing grid data
-    logical :: old_ic                    !< Use existing IC data
-    integer :: t_step_old, t_step_start  !< Existing IC/grid folder
+    integer :: num_procs            !< Number of processors
+    character(LEN=path_len) :: case_dir             !< Case folder location
+    logical :: old_grid             !< Use existing grid data
+    logical :: old_ic, non_axis_sym               !< Use existing IC data
+    integer :: t_step_old, t_step_start           !< Existing IC/grid folder
     ! ==========================================================================
 
     ! Computational Domain Parameters ==========================================
@@ -72,16 +72,21 @@ module m_global_parameters
     ! ==========================================================================
 
     ! Simulation Algorithm Parameters ==========================================
-    integer :: model_eqns            !< Multicomponent flow model
-    logical :: relax                 !< activate phase change
-    integer :: relax_model           !< Relax Model
-    real(kind(0d0)) :: palpha_eps    !< trigger parameter for the p relaxation procedure, phase change model
-    real(kind(0d0)) :: ptgalpha_eps  !< trigger parameter for the pTg relaxation procedure, phase change model
-    integer :: num_fluids            !< Number of different fluids present in the flow
-    logical :: mpp_lim               !< Alpha limiter
-    integer :: sys_size              !< Number of unknowns in the system of equations
-    integer :: weno_order            !< Order of accuracy for the WENO reconstruction
-    logical :: hypoelasticity        !< activate hypoelasticity
+    integer :: model_eqns      !< Multicomponent flow model
+    logical :: relax           !< activate phase change
+    integer :: relax_model     !< Relax Model
+    real(kind(0d0)) :: palpha_eps     !< trigger parameter for the p relaxation procedure, phase change model
+    real(kind(0d0)) :: ptgalpha_eps   !< trigger parameter for the pTg relaxation procedure, phase change model
+    integer :: num_fluids      !< Number of different fluids present in the flow
+    logical :: mpp_lim         !< Alpha limiter
+    integer :: sys_size        !< Number of unknowns in the system of equations
+    integer :: weno_order      !< Order of accuracy for the WENO reconstruction
+    logical :: hypoelasticity  !< activate hypoelasticity
+    logical :: hyperelasticity !< activate hyperelasticity
+    logical :: elasticity      !< elasticity modeling, true for hyper or hypo
+    integer :: b_size          !< Number of components in the b tensor
+    integer :: tensor_size     !< Number of components in the nonsymmetric tensor
+    logical :: pre_stress      !< activate pre_stressed domain
 
     ! Annotations of the structure, i.e. the organization, of the state vectors
     type(int_bounds_info) :: cont_idx              !< Indexes of first & last continuity eqns.
@@ -95,6 +100,7 @@ module m_global_parameters
     integer :: gamma_idx                           !< Index of specific heat ratio func. eqn.
     integer :: pi_inf_idx                          !< Index of liquid stiffness func. eqn.
     type(int_bounds_info) :: stress_idx            !< Indexes of elastic shear stress eqns.
+    type(int_bounds_info) :: xi_idx                !< Indexes of first and last reference map eqns.
     integer :: c_idx                               !< Index of the color function
 
     type(int_bounds_info) :: bc_x, bc_y, bc_z !<
@@ -216,6 +222,7 @@ module m_global_parameters
     integer :: intxb, intxe
     integer :: bubxb, bubxe
     integer :: strxb, strxe
+    integer :: xibeg, xiend
     !> @}
 
     integer, allocatable, dimension(:, :, :) :: logic_grid
@@ -278,6 +285,9 @@ contains
         weno_order = dflt_int
 
         hypoelasticity = .false.
+        hyperelasticity = .false.
+        elasticity = .false.
+        pre_stress = .false.
 
         bc_x%beg = dflt_int; bc_x%end = dflt_int
         bc_y%beg = dflt_int; bc_y%end = dflt_int
@@ -339,6 +349,18 @@ contains
             patch_icpp(i)%qv = 0d0
             patch_icpp(i)%qvp = 0d0
             patch_icpp(i)%tau_e = 0d0
+            patch_icpp(i)%a2 = dflt_real
+            patch_icpp(i)%a3 = dflt_real
+            patch_icpp(i)%a4 = dflt_real
+            patch_icpp(i)%a5 = dflt_real
+            patch_icpp(i)%a6 = dflt_real
+            patch_icpp(i)%a8 = dflt_real
+            patch_icpp(i)%a9 = dflt_real
+            patch_icpp(i)%a10 = dflt_real
+            patch_icpp(i)%a11 = dflt_real
+            patch_icpp(i)%a12 = dflt_real
+            patch_icpp(i)%non_axis_sym = .false.
+
             !should get all of r0's and v0's
             patch_icpp(i)%r0 = dflt_real
             patch_icpp(i)%v0 = dflt_real
@@ -574,13 +596,24 @@ contains
                 end if
             end if
 
-            if (hypoelasticity) then
+            if (hypoelasticity .or. hyperelasticity) then
+                elasticity = .true.
                 stress_idx%beg = sys_size + 1
                 stress_idx%end = sys_size + (num_dims*(num_dims + 1))/2
                 ! number of stresses is 1 in 1D, 3 in 2D, 6 in 3D
                 sys_size = stress_idx%end
             end if
 
+            if (hyperelasticity) then
+                ! number of entries in the symmetric btensor plus the jacobian
+                b_size = (num_dims*(num_dims + 1))/2 + 1
+                tensor_size = num_dims**2 + 1
+                xi_idx%beg = sys_size + 1
+                xi_idx%end = sys_size + num_dims
+                ! adding three more equations for the \xi field and the elastic energy
+                sys_size = xi_idx%end + 1
+            end if
+
             if (.not. f_is_default(sigma)) then
                 c_idx = sys_size + 1
                 sys_size = c_idx
@@ -605,6 +638,24 @@ contains
             internalEnergies_idx%end = adv_idx%end + num_fluids
             sys_size = internalEnergies_idx%end
 
+            if (hypoelasticity .or. hyperelasticity) then
+                elasticity = .true.
+                stress_idx%beg = sys_size + 1
+                stress_idx%end = sys_size + (num_dims*(num_dims + 1))/2
+                ! number of stresses is 1 in 1D, 3 in 2D, 6 in 3D
+                sys_size = stress_idx%end
+            end if
+
+            if (hyperelasticity) then
+                ! number of entries in the symmetric btensor plus the jacobian
+                b_size = (num_dims*(num_dims + 1))/2 + 1
+                tensor_size = num_dims**2 + 1
+                xi_idx%beg = sys_size + 1
+                xi_idx%end = sys_size + num_dims
+                ! adding three more equations for the \xi field and the elastic energy
+                sys_size = xi_idx%end + 1
+            end if
+
             if (.not. f_is_default(sigma)) then
                 c_idx = sys_size + 1
                 sys_size = c_idx
@@ -681,6 +732,8 @@ contains
         strxe = stress_idx%end
         intxb = internalEnergies_idx%beg
         intxe = internalEnergies_idx%end
+        xibeg = xi_idx%beg
+        xiend = xi_idx%end
 
         ! ==================================================================
 
diff --git a/src/pre_process/m_initial_condition.fpp b/src/pre_process/m_initial_condition.fpp
index 5d58d46e..869194b5 100644
--- a/src/pre_process/m_initial_condition.fpp
+++ b/src/pre_process/m_initial_condition.fpp
@@ -238,6 +238,10 @@ contains
                 elseif (patch_icpp(i)%geometry == 7) then
                     call s_2D_analytical(i, patch_id_fp, q_prim_vf)
 
+                    ! Spherical Harmonic Patch
+                elseif (patch_icpp(i)%geometry == 14) then
+                    call s_spherical_harmonic(i, patch_id_fp, q_prim_vf)
+
                     ! Spiral patch
                 elseif (patch_icpp(i)%geometry == 17) then
                     call s_spiral(i, patch_id_fp, q_prim_vf)
@@ -311,8 +315,7 @@ contains
         if (instability_wave) call s_superposition_instability_wave()
 
         ! Converting the primitive variables to the conservative ones
-        call s_convert_primitive_to_conservative_variables(q_prim_vf, &
-                                                           q_cons_vf)
+        call s_convert_primitive_to_conservative_variables(q_prim_vf, q_cons_vf)
 
         if (qbmm .and. .not. polytropic) then
             !Initialize pb and mv
diff --git a/src/pre_process/m_mpi_proxy.fpp b/src/pre_process/m_mpi_proxy.fpp
index 257f7fb3..6b04bf0f 100644
--- a/src/pre_process/m_mpi_proxy.fpp
+++ b/src/pre_process/m_mpi_proxy.fpp
@@ -55,7 +55,7 @@ contains
             & 'cyl_coord','mpp_lim','hypoelasticity', 'relax',                 &
             & 'parallel_io', 'perturb_flow', 'vel_profile', 'instability_wave',&
             & 'perturb_sph', 'bubbles', 'polytropic', 'polydisperse', 'qbmm',  &
-            & 'file_per_process', 'adv_n', 'ib' ]
+            & 'file_per_process', 'adv_n', 'ib', 'hyperelasticity','pre_stress']
             call MPI_BCAST(${VAR}$, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
         #:endfor
         call MPI_BCAST(fluid_rho(1), num_fluids_max, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
@@ -76,6 +76,7 @@ contains
             #:endfor
 
             call MPI_BCAST(patch_icpp(i)%smoothen, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
+            call MPI_BCAST(patch_icpp(i)%non_axis_sym, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
             call MPI_BCAST(patch_icpp(i)%alter_patch(0), num_patches_max, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
 
             #:for VAR in [ 'x_centroid', 'y_centroid', 'z_centroid',           &
@@ -86,6 +87,10 @@ contains
                 call MPI_BCAST(patch_icpp(i)%${VAR}$, 1, MPI_DOUBLE_PRECISION, 0, MPI_COMM_WORLD, ierr)
             #:endfor
 
+            #:for VAR in [ 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'a10', 'a11', 'a12']
+                call MPI_BCAST(patch_icpp(i)%${VAR}$, 1, MPI_DOUBLE_PRECISION, 0, MPI_COMM_WORLD, ierr)
+            #:endfor
+
             call MPI_BCAST(patch_icpp(i)%model%filepath, len(patch_icpp(i)%model%filepath), MPI_CHARACTER, 0, MPI_COMM_WORLD, ierr)
 
             #:for VAR in [ 'model%translate', 'model%scale', 'model%rotate', &
diff --git a/src/pre_process/m_patches.fpp b/src/pre_process/m_patches.fpp
index 708ada19..d14d2273 100644
--- a/src/pre_process/m_patches.fpp
+++ b/src/pre_process/m_patches.fpp
@@ -70,7 +70,8 @@ module m_patches
     !! is to act as a pseudo volume fraction to indicate the contribution of each
     !! patch toward the composition of a cell's fluid state.
 
-    real(kind(0d0)) :: cart_y, cart_z
+    real(kind(0d0)) :: r_cyl, theta_cyl, x_cart, y_cart, z_cart
+    real(kind(0d0)) :: cart_x, cart_y, cart_z
     real(kind(0d0)) :: sph_phi !<
     !! Variables to be used to hold cell locations in Cartesian coordinates if
     !! 3D simulation is using cylindrical coordinates
@@ -794,7 +795,7 @@ contains
                                      ((y_cc(j) - y_centroid)/b)**2) &
                                 - 1d0))*(-0.5d0) + 0.5d0
                 end if
-
+                print *, "a :", a, "b :", b
                 if ((((x_cc(i) - x_centroid)/a)**2 + &
                      ((y_cc(j) - y_centroid)/b)**2 <= 1d0 &
                      .and. &
@@ -1421,128 +1422,240 @@ contains
         !! @param q_prim_vf Array of primitive variables
     subroutine s_spherical_harmonic(patch_id, patch_id_fp, q_prim_vf)
 
-        integer, intent(in) :: patch_id
-        integer, dimension(0:m, 0:n, 0:p), intent(inout) :: patch_id_fp
-        type(scalar_field), dimension(1:sys_size), intent(inout) :: q_prim_vf
+        integer, intent(IN) :: patch_id
+        integer, intent(INOUT), dimension(0:m, 0:n, 0:p) :: patch_id_fp
+        type(scalar_field), dimension(1:sys_size) :: q_prim_vf
+
+        real(kind(0d0)) :: r, x_p, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, eps, phi
+        real(kind(0d0)) :: a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12
+        real(kind(0d0)) :: radius, x_centroid, y_centroid, z_centroid, eta, smooth_coeff
+        logical :: non_axis_sym
 
         integer :: i, j, k !< generic loop iterators
-        real(kind(0d0)) :: radius, epsilon, beta
-        complex(kind(0d0)) :: cmplx_i = (0d0, 1d0)
-        complex(kind(0d0)) :: H
 
         ! Transferring the patch's centroid and radius information
         x_centroid = patch_icpp(patch_id)%x_centroid
         y_centroid = patch_icpp(patch_id)%y_centroid
         z_centroid = patch_icpp(patch_id)%z_centroid
+        smooth_patch_id = patch_icpp(patch_id)%smooth_patch_id
+        smooth_coeff = patch_icpp(patch_id)%smooth_coeff
         radius = patch_icpp(patch_id)%radius
-        epsilon = patch_icpp(patch_id)%epsilon
-        beta = patch_icpp(patch_id)%beta
+        a2 = patch_icpp(patch_id)%a2
+        a3 = patch_icpp(patch_id)%a3
+        a4 = patch_icpp(patch_id)%a4
+        a5 = patch_icpp(patch_id)%a5
+        a6 = patch_icpp(patch_id)%a6
+        a7 = patch_icpp(patch_id)%a7
+        a8 = patch_icpp(patch_id)%a8
+        a9 = patch_icpp(patch_id)%a9
+        a10 = patch_icpp(patch_id)%a10
+        a11 = patch_icpp(patch_id)%a11
+        a12 = patch_icpp(patch_id)%a12
+        non_axis_sym = patch_icpp(patch_id)%non_axis_sym
 
         ! Since the analytical patch does not allow for its boundaries to get
         ! smoothed out, the pseudo volume fraction is set to 1 to make sure
         ! that only the current patch contributes to the fluid state in the
         ! cells that this patch covers.
         eta = 1d0
+        eps = 1.d-32
 
         ! Checking whether the patch covers a particular cell in the domain
         ! and verifying whether the current patch has permission to write to
         ! to that cell. If both queries check out, the primitive variables
         ! of the current patch are assigned to this cell.
-        do k = 0, p
+        if (p > 0 .and. .not. non_axis_sym) then
+            do k = 0, p
+                do j = 0, n
+                    do i = 0, m
+                        if (grid_geometry == 3) then
+                            call s_convert_cylindrical_to_cartesian_coord(y_cc(j), z_cc(k))
+                        else
+                            cart_y = y_cc(j)
+                            cart_z = z_cc(k)
+                        end if
+
+                        r = dsqrt((x_cc(i) - x_centroid)**2 + (cart_y - y_centroid)**2 + (cart_z - z_centroid)**2) + eps
+                        if (x_cc(i) - x_centroid <= 0) then
+                            x_p = -dabs(x_cc(i) - x_centroid + eps)/r
+                        else
+                            x_p = dabs(x_cc(i) - x_centroid + eps)/r
+                        end if
+
+                        P2 = unassociated_legendre(x_p, 2)
+                        P3 = unassociated_legendre(x_p, 3)
+                        P4 = unassociated_legendre(x_p, 4)
+                        P5 = unassociated_legendre(x_p, 5)
+                        P6 = unassociated_legendre(x_p, 6)
+                        P7 = unassociated_legendre(x_p, 7)
+                        if ((x_cc(i) - x_centroid >= 0 &
+                             .and. &
+                             r - a2*P2 - a3*P3 - a4*P4 - a5*P5 - a6*P6 - a7*P7 <= radius &
+                             .and. &
+                             patch_icpp(patch_id)%alter_patch(patch_id_fp(i, j, k))) .or. &
+                            (patch_id_fp(i, j, k) == smooth_patch_id)) &
+                            then
+                            if (patch_icpp(patch_id)%smoothen) then
+                                eta = tanh(smooth_coeff/min(dx, dy, dz)* &
+                                           ((r - a2*P2 - a3*P3 - a4*P4 - a5*P5 - a6*P6 - a7*P7) &
+                                            - radius))*(-0.5d0) + 0.5d0
+                            end if
+
+                            call s_assign_patch_primitive_variables(patch_id, i, j, k, &
+                                                                    eta, q_prim_vf, patch_id_fp)
+                        end if
+
+                    end do
+                end do
+            end do
+
+        else if (p == 0) then
             do j = 0, n
                 do i = 0, m
 
-                    if (grid_geometry == 3) then
-                        call s_convert_cylindrical_to_cartesian_coord(y_cc(j), z_cc(k))
+                    if (non_axis_sym) then
+                        phi = atan(((y_cc(j) - y_centroid) + eps)/((x_cc(i) - x_centroid) + eps))
+                        r = dsqrt((x_cc(i) - x_centroid)**2d0 + (y_cc(j) - y_centroid)**2d0) + eps
+                        x_p = (eps)/r
+                        P2 = spherical_harmonic_func(x_p, phi, 2, 2)
+                        P3 = spherical_harmonic_func(x_p, phi, 3, 3)
+                        P4 = spherical_harmonic_func(x_p, phi, 4, 4)
+                        P5 = spherical_harmonic_func(x_p, phi, 5, 5)
+                        P6 = spherical_harmonic_func(x_p, phi, 6, 6)
+                        P7 = spherical_harmonic_func(x_p, phi, 7, 7)
+                        P8 = spherical_harmonic_func(x_p, phi, 8, 8)
+                        P9 = spherical_harmonic_func(x_p, phi, 9, 9)
+                        !  P10 = spherical_harmonic_func(x_p, phi, 10, 10)
+                        !  P11 = spherical_harmonic_func(x_p, phi, 11, 11)
+                        !  P12 = spherical_harmonic_func(x_p, phi, 12, 12)
                     else
-                        cart_y = y_cc(j)
-                        cart_z = z_cc(k)
+                        r = dsqrt((x_cc(i) - x_centroid)**2d0 + (y_cc(j) - y_centroid)**2d0) + eps
+                        x_p = dabs(x_cc(i) - x_centroid + eps)/r
+                        P2 = unassociated_legendre(x_p, 2)
+                        P3 = unassociated_legendre(x_p, 3)
+                        P4 = unassociated_legendre(x_p, 4)
+                        P5 = unassociated_legendre(x_p, 5)
+                        P6 = unassociated_legendre(x_p, 6)
+                        P7 = unassociated_legendre(x_p, 7)
+                        P8 = unassociated_legendre(x_p, 8)
+                        P9 = unassociated_legendre(x_p, 9)
                     end if
 
-                    if (((x_cc(i) - x_centroid)**2 &
-                         + (cart_y - y_centroid)**2 &
-                         + (cart_z - z_centroid)**2 <= radius**2 &
-                         .and. &
-                         patch_icpp(patch_id)%alter_patch(patch_id_fp(i, j, k)))) &
+                    if (x_cc(i) - x_centroid >= 0 &
+                        .and. &
+                        r - a2*P2 - a3*P3 - a4*P4 - a5*P5 - a6*P6 - a7*P7 - a8*P8 - a9*P9 <= radius .and. &
+                        patch_icpp(patch_id)%alter_patch(patch_id_fp(i, j, 0))) &
                         then
+                        call s_assign_patch_primitive_variables(patch_id, i, j, 0, &
+                                                                eta, q_prim_vf, patch_id_fp)
 
-                        call s_convert_cylindrical_to_spherical_coord(x_cc(i), y_cc(j))
-
-                        if (epsilon == 1d0) then
-                            if (beta == 0d0) then
-                                H = 5d-1*sqrt(3d0/pi)*cos(sph_phi)
-                            elseif (beta == 1d0) then
-                                H = -5d-1*sqrt(3d0/(2d0*pi))*exp(cmplx_i*z_cc(k))*sin(sph_phi)
-                            end if
-                        elseif (epsilon == 2d0) then
-                            if (beta == 0d0) then
-                                H = 25d-2*sqrt(5d0/pi)*(3d0*cos(sph_phi)**2 - 1d0)
-                            elseif (beta == 1d0) then
-                                H = -5d-1*sqrt(15d0/(2d0*pi))*exp(cmplx_i*z_cc(k))*sin(sph_phi)*cos(sph_phi)
-                            elseif (beta == 2d0) then
-                                H = 25d-2*sqrt(15d0/(2d0*pi))*exp(2d0*cmplx_i*z_cc(k))*sin(sph_phi)**2
-                            end if
-                        elseif (epsilon == 3d0) then
-                            if (beta == 0d0) then
-                                H = 25d-2*sqrt(7d0/pi)*(5d0*cos(sph_phi)**3d0 - 3d0*cos(sph_phi))
-                            elseif (beta == 1d0) then
-                                H = -125d-3*sqrt(21d0/pi)*exp(cmplx_i*z_cc(k))*sin(sph_phi)* &
-                                    (5d0*cos(sph_phi)**2 - 1d0)
-                            elseif (beta == 2d0) then
-                                H = 25d-2*sqrt(105d0/(2d0*pi))*exp(2d0*cmplx_i*z_cc(k))* &
-                                    sin(sph_phi)**2*cos(sph_phi)
-                            elseif (beta == 3d0) then
-                                H = -125d-3*sqrt(35d0/pi)*exp(3d0*cmplx_i*z_cc(k))*sin(sph_phi)**3d0
-                            end if
-                        elseif (epsilon == 4d0) then
-                            if (beta == 0d0) then
-                                H = 3d0/16d0*sqrt(1d0/pi)*(35d0*cos(sph_phi)**4d0 - &
-                                                           3d1*cos(sph_phi)**2 + 3d0)
-                            elseif (beta == 1d0) then
-                                H = -3d0/8d0*sqrt(5d0/pi)*exp(cmplx_i*z_cc(k))* &
-                                    sin(sph_phi)*(7d0*cos(sph_phi)**3d0 - 3d0*cos(sph_phi))
-                            elseif (beta == 2d0) then
-                                H = 3d0/8d0*sqrt(5d0/(2d0*pi))*exp(2d0*cmplx_i*z_cc(k))* &
-                                    sin(sph_phi)**2*(7d0*cos(sph_phi)**2 - 1d0)
-                            elseif (beta == 3d0) then
-                                H = -3d0/8d0*sqrt(35d0/pi)*exp(3d0*cmplx_i*z_cc(k))* &
-                                    sin(sph_phi)**3d0*cos(sph_phi)
-                            elseif (beta == 4d0) then
-                                H = 3d0/16d0*sqrt(35d0/(2d0*pi))*exp(4d0*cmplx_i*z_cc(k))* &
-                                    sin(sph_phi)**4d0
-                            end if
-                        elseif (epsilon == 5d0) then
-                            if (beta == 0d0) then
-                                H = 1d0/16d0*sqrt(11d0/pi)*(63d0*cos(sph_phi)**5d0 - &
-                                                            7d1*cos(sph_phi)**3d0 + 15d0*cos(sph_phi))
-                            elseif (beta == 1d0) then
-                                H = -1d0/16d0*sqrt(165d0/(2d0*pi))*exp(cmplx_i*z_cc(k))* &
-                                    sin(sph_phi)*(21d0*cos(sph_phi)**4d0 - 14d0*cos(sph_phi)**2 + 1d0)
-                            elseif (beta == 2d0) then
-                                H = 125d-3*sqrt(1155d0/(2d0*pi))*exp(2d0*cmplx_i*z_cc(k))* &
-                                    sin(sph_phi)**2*(3d0*cos(sph_phi)**3d0 - cos(sph_phi))
-                            elseif (beta == 3d0) then
-                                H = -1d0/32d0*sqrt(385d0/pi)*exp(3d0*cmplx_i*z_cc(k))* &
-                                    sin(sph_phi)**3d0*(9d0*cos(sph_phi)**2 - 1d0)
-                            elseif (beta == 4d0) then
-                                H = 3d0/16d0*sqrt(385d0/(2d0*pi))*exp(4d0*cmplx_i*z_cc(k))* &
-                                    sin(sph_phi)**4d0*cos(sph_phi)
-                            elseif (beta == 5d0) then
-                                H = -3d0/32d0*sqrt(77d0/pi)*exp(5d0*cmplx_i*z_cc(k))* &
-                                    sin(sph_phi)**5d0
-                            end if
-                        end if
-
-                        q_prim_vf(adv_idx%beg)%sf(i, j, k) = 1d0 - abs(real(H, kind(0d0)))
+                    elseif (x_cc(i) - x_centroid < 0 &
+                            .and. &
+                            r - a2*P2 + a3*P3 - a4*P4 + a5*P5 - a6*P6 + a7*P7 - a8*P8 + a9*P9 <= radius &
+                            .and. &
+                            patch_icpp(patch_id)%alter_patch(patch_id_fp(i, j, 0))) &
+                        then
+                        call s_assign_patch_primitive_variables(patch_id, i, j, 0, &
+                                                                eta, q_prim_vf, patch_id_fp)
 
                     end if
-
                 end do
             end do
-        end do
+        end if
 
     end subroutine s_spherical_harmonic
 
+        !! This function generates the unassociated legendre poynomials with input
+    ! mode number and evaluates them at input x
+
+    recursive function unassociated_legendre(x, l) result(P)
+        integer, intent(in) :: l
+        real(kind(0d0)), intent(in) :: x
+        real(kind(0d0)) :: P
+
+        if (l == 0) then
+            P = 1d0
+        else if (l == 1) then
+            P = x
+        else
+            P = ((2*l - 1)*x*unassociated_legendre(x, l - 1) - (l - 1)*unassociated_legendre(x, l - 2))/l
+        end if
+
+    end function unassociated_legendre
+
+        !! This function generated the spherical harmonic function valu, Y,
+    !based on inputs of x, phi, l and m
+
+    recursive function spherical_harmonic_func(x, phi, l, m) result(Y)
+        integer, intent(in) :: l, m
+        real(kind(0d0)), intent(in) :: x, phi
+        real(kind(0d0)) :: Y, prefactor, pi
+
+        pi = acos(-1d0)
+        prefactor = sqrt((2*l + 1)/(4*pi)*factorial(l - m)/factorial(l + m)); 
+        if (m == 0) then
+            Y = prefactor*associated_legendre(x, l, m); 
+        elseif (m > 0) then
+            Y = (-1d0)**m*sqrt(2d0)*prefactor*associated_legendre(x, l, m)*cos(m*phi); 
+        end if
+    end function spherical_harmonic_func
+
+        !! This function generates the associated legendre polynomials evaluated
+    !at x with inputs l and m
+
+    recursive function associated_legendre(x, l, m) result(P)
+        integer, intent(in) :: l, m
+        real(kind(0d0)), intent(in) :: x
+        real(kind(0d0)) :: P
+
+        if (m <= 0 .and. l <= 0) then
+            P = 1; 
+        elseif (l == 1 .and. m <= 0) then
+            P = x; 
+        elseif (l == 1 .and. m == 1) then
+            P = -(1 - x**2)**(1/2); 
+        elseif (m == l) then
+            P = (-1)**l*double_factorial(2*l - 1)*(1 - x**2)**(l/2); 
+        elseif (m == l - 1) then
+            P = x*(2*l - 1)*associated_legendre(x, l - 1, l - 1); 
+        else
+            P = ((2*l - 1)*x*associated_legendre(x, l - 1, m) - (l + m - 1)*associated_legendre(x, l - 2, m))/(l - m); 
+        end if
+
+    end function associated_legendre
+
+        !! This function calculates the double factorial value of an integer
+
+    recursive function double_factorial(n) result(R)
+        integer, intent(in) :: n
+        integer, parameter :: int64_kind = selected_int_kind(18) ! 18 bytes for 64-bit integer
+        integer(kind=int64_kind) :: R
+
+        if (n <= 0) then
+            R = 1
+        else if (n == 1) then
+            R = 1
+        else
+            R = n*double_factorial(n - 2)
+        end if
+
+    end function double_factorial
+
+        !! The following function calculates the factorial value of an integer
+
+    recursive function factorial(n) result(R)
+        integer, intent(in) :: n
+        integer, parameter :: int64_kind = selected_int_kind(18) ! 18 bytes for 64-bit integer
+        integer(kind=int64_kind) :: R
+
+        if (n == 0) then
+            R = 1
+        else
+            R = n*factorial(n - 1)
+        end if
+
+    end function factorial
+
     !>          The spherical patch is a 3D geometry that may be used,
         !!              for example, in creating a bubble or a droplet. The patch
         !!              geometry is well-defined when its centroid and radius are
@@ -2110,7 +2223,7 @@ contains
 
     end subroutine s_convert_cylindrical_to_spherical_coord
 
-    !> Archimedes spiral function
+    !> Archimedes spiral funcreal(kind(0d0)) :: theta_cc, r, x_p, P2, P3, P4, P5, P6, P7tion
     !! @param myth Angle
     !! @param offset Thickness
     !! @param a Starting position
diff --git a/src/pre_process/m_start_up.fpp b/src/pre_process/m_start_up.fpp
index 546de9c5..6db827ca 100644
--- a/src/pre_process/m_start_up.fpp
+++ b/src/pre_process/m_start_up.fpp
@@ -140,7 +140,7 @@ contains
             sigR, sigV, dist_type, rhoRV, R0_type, &
             file_per_process, relax, relax_model, &
             palpha_eps, ptgalpha_eps, ib, num_ibs, patch_ib, &
-            sigma, adv_n
+            sigma, adv_n, hyperelasticity, pre_stress
 
         ! Inquiring the status of the pre_process.inp file
         file_loc = 'pre_process.inp'
diff --git a/src/simulation/m_boundary_conditions.fpp b/src/simulation/m_boundary_conditions.fpp
index ca77632d..2b9eee16 100644
--- a/src/simulation/m_boundary_conditions.fpp
+++ b/src/simulation/m_boundary_conditions.fpp
@@ -357,6 +357,12 @@ contains
                                 q_prim_vf(i)%sf(-j, k, l) = &
                                     q_prim_vf(i)%sf(j - 1, k, l)
                             end do
+ 
+                            if(hyperelasticity) then
+                              q_prim_vf(xibeg)%sf(-j, k, l) = &
+                                 -q_prim_vf(xibeg)%sf(j - 1, k, l)
+                            end if
+
                         end do
                     end do
                 end do
@@ -401,6 +407,11 @@ contains
                                     q_prim_vf(i)%sf(m - (j - 1), k, l)
                             end do
 
+                            if(hyperelasticity) then 
+                              q_prim_vf(xibeg)%sf(m + j, k, l) = &
+                                -q_prim_vf(xibeg)%sf(m - (j - 1), k, l)
+                            end if
+
                         end do
                     end do
                 end do
@@ -448,6 +459,11 @@ contains
                                 q_prim_vf(i)%sf(l, -j, k) = &
                                     q_prim_vf(i)%sf(l, j - 1, k)
                             end do
+
+                            if(hyperelasticity) then 
+                              q_prim_vf(xibeg + 1)%sf(l, -j, k) = &
+                                -q_prim_vf(xibeg + 1)%sf(l, j - 1, k)
+                            end if
                         end do
                     end do
                 end do
@@ -490,6 +506,11 @@ contains
                                 q_prim_vf(i)%sf(l, n + j, k) = &
                                     q_prim_vf(i)%sf(l, n - (j - 1), k)
                             end do
+
+                            if(hyperelasticity) then 
+                              q_prim_vf(xibeg + 1)%sf(l, n + j, k) = &
+                                -q_prim_vf(xibeg + 1)%sf(l, n - (j - 1), k)
+                            end if
                         end do
                     end do
                 end do
@@ -537,6 +558,11 @@ contains
                                 q_prim_vf(i)%sf(k, l, -j) = &
                                     q_prim_vf(i)%sf(k, l, j - 1)
                             end do
+
+                            if(hyperelasticity) then 
+                              q_prim_vf(xiend)%sf(k, l, -j) = &
+                                -q_prim_vf(xiend)%sf(k, l, j - 1)
+                            end if 
                         end do
                     end do
                 end do
@@ -579,6 +605,11 @@ contains
                                 q_prim_vf(i)%sf(k, l, p + j) = &
                                     q_prim_vf(i)%sf(k, l, p - (j - 1))
                             end do
+
+                            if(hyperelasticity) then 
+                              q_prim_vf(xiend)%sf(k, l, p + j) = &
+                                -q_prim_vf(xiend)%sf(k, l, p - (j - 1))
+                            end if
                         end do
                     end do
                 end do
diff --git a/src/simulation/m_checker.fpp b/src/simulation/m_checker.fpp
index d9513675..c3523ec9 100644
--- a/src/simulation/m_checker.fpp
+++ b/src/simulation/m_checker.fpp
@@ -31,6 +31,7 @@ contains
         call s_check_inputs_model_eqns
         if (acoustic_source) call s_check_inputs_acoustic_src
         if (hypoelasticity) call s_check_inputs_hypoelasticity
+        if (hyperelasticity) call s_check_inputs_hyperelasticity
         if (bubbles) call s_check_inputs_bubbles
         if (adap_dt) call s_check_inputs_adapt_dt
         if (alt_soundspeed) call s_check_inputs_alt_soundspeed
@@ -369,10 +370,20 @@ contains
     !> Checks constraints on hypoelasticity parameters
     subroutine s_check_inputs_hypoelasticity
         if (riemann_solver /= 1) then
-            call s_mpi_abort('hypoelasticity requires HLL Riemann solver '// &
-                             '(riemann_solver = 1). Exiting ...')
+            call s_mpi_abort('hypoelasticity requires HLL '// &
+                             '(riemann_solver = 1) Riemann solver. '// &
+                             'Exiting ...')
+        end if
+    end subroutine s_check_inputs_hypoelasticity
+        
+    !> Checks constraints on hyperelasticity parameters
+    subroutine s_check_inputs_hyperelasticity
+        if (riemann_solver /= 2) then
+           call s_mpi_abort('hyperelasticity requires HLLC '// &
+                            '(riemann_solver = 2) Riemann solver. '// &
+                            'Exiting ...')
         end if
-    end subroutine
+    end subroutine s_check_inputs_hyperelasticity
 
     !> Checks constraints on bubble parameters
     subroutine s_check_inputs_bubbles
diff --git a/src/simulation/m_data_output.fpp b/src/simulation/m_data_output.fpp
index 875f0a90..93637a1b 100644
--- a/src/simulation/m_data_output.fpp
+++ b/src/simulation/m_data_output.fpp
@@ -1,4 +1,4 @@
-!>
+
 !! @file m_data_output.f90
 !! @brief Contains module m_data_output
 
@@ -37,13 +37,16 @@ module m_data_output
     private; 
     public :: s_initialize_data_output_module, &
               s_open_run_time_information_file, &
+              s_open_com_files, &
               s_open_probe_files, &
               s_write_run_time_information, &
               s_write_data_files, &
               s_write_serial_data_files, &
               s_write_parallel_data_files, &
+              s_write_com_files, &
               s_write_probe_files, &
               s_close_run_time_information_file, &
+              s_close_com_files, &
               s_close_probe_files, &
               s_finalize_data_output_module
 
@@ -63,11 +66,12 @@ module m_data_output
 
             type(scalar_field), &
                 dimension(sys_size), &
-                intent(inout) :: q_prim_vf
+                intent(inOUT) :: q_prim_vf
 
             integer, intent(in) :: t_step
 
-        end subroutine s_write_abstract_data_files
+        end subroutine s_write_abstract_data_files ! -------------------
+
     end interface ! ========================================================
 #ifdef CRAY_ACC_WAR
     @:CRAY_DECLARE_GLOBAL(real(kind(0d0)), dimension(:, :, :), icfl_sf)
@@ -80,6 +84,8 @@ module m_data_output
     real(kind(0d0)), allocatable, dimension(:, :, :) :: vcfl_sf  !< VCFL stability criterion
     real(kind(0d0)), allocatable, dimension(:, :, :) :: ccfl_sf  !< CCFL stability criterion
     real(kind(0d0)), allocatable, dimension(:, :, :) :: Rc_sf  !< Rc stability criterion
+    real(kind(0d0)), public, allocatable, dimension(:, :) :: c_mass
+
     !$acc declare create(icfl_sf, vcfl_sf, ccfl_sf, Rc_sf)
 #endif
 
@@ -169,6 +175,44 @@ contains
 
     end subroutine s_open_run_time_information_file
 
+    !>  This opens a formatted data file where the root processor
+        !!      can write out the CoM information
+    subroutine s_open_com_files() ! ----------------------------------------
+        character(len=path_len + 3*name_len) :: file_path !<
+            !! Relative path to the CoM file in the case directory
+        integer :: i !< Generic loop iterator
+        do i = 1, num_fluids
+            ! Generating the relative path to the CoM data file
+            write (file_path, '(A,I0,A)') '/fluid', i, '_com.dat'
+            file_path = trim(case_dir)//trim(file_path)
+            ! Creating the formatted data file and setting up its
+            ! structure
+            open (i + 120, file=trim(file_path), &
+                  form='formatted', &
+                  position='append', &
+                  status='unknown')
+            if (n == 0) then
+                write (i + 120, '(A)') '=== Non-Dimensional Time '// &
+                    '=== Total Mass '// &
+                    '=== x-loc '// &
+                    '=== Total Volume ==='
+            elseif (p == 0) then
+                write (i + 120, '(A)') '=== Non-Dimensional Time '// &
+                    '=== Total Mass '// &
+                    '=== x-loc '// &
+                    '=== y-loc '// &
+                    '=== Total Volume ==='
+            else
+                write (i + 120, '(A)') '=== Non-Dimensional Time '// &
+                    '=== Total Mass '// &
+                    '=== x-loc '// &
+                    '=== y-loc '// &
+                    '=== z-loc '// &
+                    '=== Total Volume ==='
+            end if
+        end do
+    end subroutine s_open_com_files ! --------------------------------------
+
     !>  This opens a formatted data file where the root processor
         !!      can write out flow probe information
     subroutine s_open_probe_files
@@ -189,12 +233,12 @@ contains
                   FORM='formatted', &
                   STATUS='unknown')
             ! POSITION = 'append', &
-            !WRITE(i+30,'(A,I0,A)') 'Probe ',i, ' located at:'
-            !WRITE(i+30,'(A,F10.6)') 'x = ',probe(i)%x
-            !WRITE(i+30,'(A,F10.6)') 'y = ',probe(i)%y
-            !WRITE(i+30,'(A,F10.6)') 'z = ',probe(i)%z
-            !WRITE(i+30, *)
-            !WRITE(i+30,'(A)') '=== Non-Dimensional Time ' // &
+            !write(i+30,'(A,I0,A)') 'Probe ',i, ' located at:'
+            !write(i+30,'(A,F10.6)') 'x = ',probe(i)%x
+            !write(i+30,'(A,F10.6)') 'y = ',probe(i)%y
+            !write(i+30,'(A,F10.6)') 'z = ',probe(i)%z
+            !write(i+30, *)
+            !write(i+30,'(A)') '=== Non-Dimensional Time ' // &
             !                '=== Density ' // &
             !                '=== Velocity ' // &
             !                '=== Pressure ' // &
@@ -227,8 +271,8 @@ contains
         !!  @param t_step Current time step
     subroutine s_write_run_time_information(q_prim_vf, t_step)
 
-        type(scalar_field), dimension(sys_size), intent(IN) :: q_prim_vf
-        integer, intent(IN) :: t_step
+        type(scalar_field), dimension(sys_size), intent(in) :: q_prim_vf
+        integer, intent(in) :: t_step
 
         real(kind(0d0)), dimension(num_fluids) :: alpha_rho  !< Cell-avg. partial density
         real(kind(0d0)) :: rho        !< Cell-avg. density
@@ -250,7 +294,6 @@ contains
 
         real(kind(0d0)) :: blkmod1, blkmod2 !<
             !! Fluid bulk modulus for Woods mixture sound speed
-
         integer :: i, j, k, l, q !< Generic loop iterators
 
         integer :: Nfq
@@ -262,7 +305,6 @@ contains
         do l = 0, p
             do k = 0, n
                 do j = 0, m
-
                     do i = 1, num_fluids
                         alpha_rho(i) = q_prim_vf(i)%sf(j, k, l)
                         alpha(i) = q_prim_vf(E_idx + i)%sf(j, k, l)
@@ -292,6 +334,14 @@ contains
                     ! Compute mixture sound speed
                     call s_compute_speed_of_sound(pres, rho, gamma, pi_inf, H, alpha, vel_sum, c)
 
+                    if (c /= c) then
+                        print *, 'crashed at processor: ', proc_rank, ', at j :: ', j, ', k :: ', k, ' l :: ', l
+                        print *, 'alpha1 ::', alpha(1), 'and alpha2 ::', alpha(2), ' alpha3 :: ', alpha(3)
+                        print *, 'alpha_rho1 ::', alpha_rho(1), ', alpha_rho2 ::', alpha_rho(2), ' alpha_rho3 :: ', alpha_rho(3)
+                        print *, 'E :: ', E, ', pres :: ', pres, ', rho :: ', rho
+                        call s_mpi_abort('Exiting ...')
+                    end if
+
                     if (grid_geometry == 3) then
                         if (k == 0) then
                             fltr_dtheta = 2d0*pi*y_cb(0)/3d0
@@ -369,7 +419,7 @@ contains
                 end do
             end do
         end do
-        ! END: Computing Stability Criteria at Current Time-step ===========
+        ! end: Computing Stability Criteria at Current Time-step ===========
 
         ! Determining local stability criteria extrema at current time-step
 
@@ -430,6 +480,7 @@ contains
                     t_step, t_step*dt, icfl_max_glb, &
                     vcfl_max_glb, &
                     Rc_min_glb
+
             else
                 write (1, '(13X,I8,14X,F10.6,13X,F9.6)') &
                     t_step, t_step*dt, icfl_max_glb
@@ -840,11 +891,11 @@ contains
 
         integer :: ifile, ierr, data_size
         integer, dimension(MPI_STATUS_SIZE) :: status
-        integer(KIND=MPI_OFFSET_KIND) :: disp
-        integer(KIND=MPI_OFFSET_KIND) :: m_MOK, n_MOK, p_MOK
-        integer(KIND=MPI_OFFSET_KIND) :: WP_MOK, var_MOK, str_MOK
-        integer(KIND=MPI_OFFSET_KIND) :: NVARS_MOK
-        integer(KIND=MPI_OFFSET_KIND) :: MOK
+        integer(kind=MPI_OFFSET_kind) :: disp
+        integer(kind=MPI_OFFSET_kind) :: m_MOK, n_MOK, p_MOK
+        integer(kind=MPI_OFFSET_kind) :: WP_MOK, var_MOK, str_MOK
+        integer(kind=MPI_OFFSET_kind) :: NVARS_MOK
+        integer(kind=MPI_OFFSET_kind) :: MOK
 
         character(LEN=path_len + 2*name_len) :: file_loc
         logical :: file_exist, dir_check
@@ -876,7 +927,6 @@ contains
             call DelayFileAccess(proc_rank)
 
             ! Initialize MPI data I/O
-
             call s_initialize_mpi_data(q_cons_vf)
 
             ! Open the file to write all flow variables
@@ -1009,6 +1059,57 @@ contains
 
     end subroutine s_write_parallel_data_files
 
+    !>  This writes a formatted data file where the root processor
+    !!      can write out the CoM information
+    !!  @param t_step Current time-step
+    !!  @param q_com Center of mass information
+    !!  @param moments Higher moment information
+    subroutine s_write_com_files(t_step, c_mass) ! -------------------
+
+        integer, intent(in) :: t_step
+        real(kind(0d0)), dimension(num_fluids, 5), intent(in) :: c_mass
+        integer :: i, j !< Generic loop iterator
+        real(kind(0d0)) :: nondim_time !< Non-dimensional time
+
+        ! Non-dimensional time calculation
+        if (t_step_old /= dflt_int) then
+            nondim_time = real(t_step + t_step_old, kind(0d0))*dt
+        else
+            nondim_time = real(t_step, kind(0d0))*dt
+        end if
+
+        if (proc_rank == 0) then
+            if (n == 0) then ! 1D simulation
+                do i = 1, num_fluids ! Loop through fluids
+                    write (i + 120, '(6X,4F24.12)') &
+                        nondim_time, &
+                        c_mass(i, 1), &
+                        c_mass(i, 2), &
+                        c_mass(i, 5)
+                end do
+            elseif (p == 0) then ! 2D simulation
+                do i = 1, num_fluids ! Loop through fluids
+                    write (i + 120, '(6X,5F24.12)') &
+                        nondim_time, &
+                        c_mass(i, 1), &
+                        c_mass(i, 2), &
+                        c_mass(i, 3), &
+                        c_mass(i, 5)
+                end do
+            else ! 3D simulation
+                do i = 1, num_fluids ! Loop through fluids
+                    write (i + 120, '(6X,6F24.12)') &
+                        nondim_time, &
+                        c_mass(i, 1), &
+                        c_mass(i, 2), &
+                        c_mass(i, 3), &
+                        c_mass(i, 4), &
+                        c_mass(i, 5)
+                end do
+            end if
+        end if
+    end subroutine s_write_com_files ! -------------------------------------
+
     !>  This writes a formatted data file for the flow probe information
         !!  @param t_step Current time-step
         !!  @param q_cons_vf Conservative variables
@@ -1057,7 +1158,7 @@ contains
         real(kind(0d0)) :: nondim_time !< Non-dimensional time
 
         real(kind(0d0)) :: tmp !<
-            !! Temporary variable to store quantity for mpi_allreduce
+            !! Temporary                         variable to store quantity for mpi_allreduce
 
         real(kind(0d0)) :: blkmod1, blkmod2 !<
             !! Fluid bulk modulus for Woods mixture sound speed
@@ -1118,7 +1219,7 @@ contains
                     l = 0
 
                     ! Computing/Sharing necessary state variables
-                    if (hypoelasticity) then
+                    if (elasticity) then
                         call s_convert_to_mixture_variables(q_cons_vf, j - 2, k, l, &
                                                             rho, gamma, pi_inf, qv, &
                                                             Re, G, fluid_pp(:)%G)
@@ -1132,7 +1233,8 @@ contains
 
                     dyn_p = 0.5d0*rho*dot_product(vel, vel)
 
-                    if (hypoelasticity) then
+                    if (elasticity) then
+
                         call s_compute_pressure( &
                             q_cons_vf(1)%sf(j - 2, k, l), &
                             q_cons_vf(alf_idx)%sf(j - 2, k, l), &
@@ -1148,7 +1250,7 @@ contains
 
                     if (model_eqns == 4) then
                         lit_gamma = 1d0/fluid_pp(1)%gamma + 1d0
-                    else if (hypoelasticity) then
+                    else if (elasticity) then
                         tau_e(1) = q_cons_vf(stress_idx%end)%sf(j - 2, k, l)/rho
                     end if
 
@@ -1232,7 +1334,7 @@ contains
 
                         dyn_p = 0.5d0*rho*dot_product(vel, vel)
 
-                        if (hypoelasticity) then
+                        if (elasticity) then
                             call s_compute_pressure( &
                                 q_cons_vf(1)%sf(j - 2, k - 2, l), &
                                 q_cons_vf(alf_idx)%sf(j - 2, k - 2, l), &
@@ -1247,7 +1349,7 @@ contains
 
                         if (model_eqns == 4) then
                             lit_gamma = 1d0/fluid_pp(1)%gamma + 1d0
-                        else if (hypoelasticity) then
+                        else if (elasticity) then
                             do s = 1, 3
                                 tau_e(s) = q_cons_vf(s)%sf(j - 2, k - 2, l)/rho
                             end do
@@ -1274,15 +1376,13 @@ contains
                             R(:) = nR(:)/nbub
                             Rdot(:) = nRdot(:)/nbub
                         end if
-
                         ! Compute mixture sound speed
                         call s_compute_speed_of_sound(pres, rho, gamma, pi_inf, &
                                                       ((gamma + 1d0)*pres + pi_inf)/rho, alpha, 0d0, c)
 
-                        accel = accel_mag(j - 2, k - 2, l)
                     end if
                 end if
-            else ! 3D simulation
+            else ! 3D 
                 if ((probe(i)%x >= x_cb(-1)) .and. (probe(i)%x <= x_cb(m))) then
                     if ((probe(i)%y >= y_cb(-1)) .and. (probe(i)%y <= y_cb(n))) then
                         if ((probe(i)%z >= z_cb(-1)) .and. (probe(i)%z <= z_cb(p))) then
@@ -1315,7 +1415,7 @@ contains
 
                             dyn_p = 0.5d0*rho*dot_product(vel, vel)
 
-                            if (hypoelasticity) then
+                            if (elasticity) then
                                 call s_compute_pressure( &
                                     q_cons_vf(1)%sf(j - 2, k - 2, l - 2), &
                                     q_cons_vf(alf_idx)%sf(j - 2, k - 2, l - 2), &
@@ -1337,7 +1437,6 @@ contains
                     end if
                 end if
             end if
-
             if (num_procs > 1) then
                 #:for VAR in ['rho','pres','gamma','pi_inf','qv','c','accel']
                     tmp = ${VAR}$
@@ -1363,14 +1462,13 @@ contains
                     end if
                 end if
 
-                if (hypoelasticity) then
+                if (elasticity) then
                     do s = 1, (num_dims*(num_dims + 1))/2
                         tmp = tau_e(s)
                         call s_mpi_allreduce_sum(tmp, tau_e(s))
                     end do
                 end if
             end if
-
             if (proc_rank == 0) then
                 if (n == 0) then
                     if (bubbles .and. (num_fluids <= 2)) then
@@ -1457,7 +1555,7 @@ contains
                             nRdot(1), &
                             R(1), &
                             Rdot(1)
-                    else if (hypoelasticity) then
+                    else if (elasticity) then
                         write (i + 30, '(6X,F12.6,F24.8,F24.8,F24.8,F24.8,'// &
                                'F24.8,F24.8,F24.8)') &
                             nondim_time, &
@@ -1474,6 +1572,7 @@ contains
                             rho, &
                             vel(1), &
                             pres
+                        print *, 'time =', nondim_time, 'rho =', rho, 'pres =', pres
                     end if
                 else
                     write (i + 30, '(6X,F12.6,F24.8,F24.8,F24.8,F24.8,'// &
@@ -1659,6 +1758,16 @@ contains
 
     end subroutine s_close_run_time_information_file
 
+    !> Closes communication files
+    subroutine s_close_com_files() ! ---------------------------------------
+
+        integer :: i !< Generic loop iterator
+        do i = 1, num_fluids
+            close (i + 120)
+        end do
+
+    end subroutine s_close_com_files ! -------------------------------------
+
     !> Closes probe files
     subroutine s_close_probe_files
 
@@ -1679,6 +1788,8 @@ contains
 
         integer :: i !< Generic loop iterator
 
+        allocate (c_mass(1:num_fluids, 1:5))
+
         ! Allocating/initializing ICFL, VCFL, CCFL and Rc stability criteria
         @:ALLOCATE_GLOBAL(icfl_sf(0:m, 0:n, 0:p))
         icfl_max = 0d0
@@ -1718,6 +1829,8 @@ contains
 
         integer :: i !< Generic loop iterator
 
+        deallocate (c_mass)
+
         ! Deallocating the ICFL, VCFL, CCFL, and Rc stability criteria
         @:DEALLOCATE_GLOBAL(icfl_sf)
         if (any(Re_size > 0)) then
diff --git a/src/simulation/m_derived_variables.f90 b/src/simulation/m_derived_variables.f90
index 4cbe11ab..8f01d478 100644
--- a/src/simulation/m_derived_variables.f90
+++ b/src/simulation/m_derived_variables.f90
@@ -20,6 +20,8 @@ module m_derived_variables
 
     use m_time_steppers         !< Time-stepping algorithms
 
+    use m_compile_specific
+
     use m_helper
     ! ==========================================================================
 
@@ -90,8 +92,8 @@ contains
             ! Opening and writing header of flow probe files
             if (proc_rank == 0) then
                 call s_open_probe_files()
+                call s_open_com_files()
             end if
-
             ! Computing centered finite difference coefficients
             call s_compute_finite_difference_coefficients(m, x_cc, fd_coeff_x, buff_size, &
                                                           fd_number, fd_order)
@@ -100,12 +102,10 @@ contains
                 call s_compute_finite_difference_coefficients(n, y_cc, fd_coeff_y, buff_size, &
                                                               fd_number, fd_order)
             end if
-
             if (p > 0) then
                 call s_compute_finite_difference_coefficients(p, z_cc, fd_coeff_z, buff_size, &
                                                               fd_number, fd_order)
             end if
-
         end if
 
     end subroutine s_initialize_derived_variables
@@ -115,7 +115,6 @@ contains
     subroutine s_compute_derived_variables(t_step)
 
         integer, intent(in) :: t_step
-
         integer :: i, j, k !< Generic loop iterators
 
         if (probe_wrt) then
@@ -124,7 +123,6 @@ contains
                                                  q_prim_ts(2)%vf, &
                                                  q_prim_ts(3)%vf, &
                                                  x_accel)
-
             if (n > 0) then
                 call s_derive_acceleration_component(2, q_prim_ts(0)%vf, &
                                                      q_prim_ts(1)%vf, &
@@ -132,7 +130,6 @@ contains
                                                      q_prim_ts(3)%vf, &
                                                      y_accel)
             end if
-
             if (p > 0) then
                 call s_derive_acceleration_component(3, q_prim_ts(0)%vf, &
                                                      q_prim_ts(1)%vf, &
@@ -140,7 +137,6 @@ contains
                                                      q_prim_ts(3)%vf, &
                                                      z_accel)
             end if
-
             do k = 0, p
                 do j = 0, n
                     do i = 0, m
@@ -157,8 +153,10 @@ contains
                     end do
                 end do
             end do
+            call s_derive_center_of_mass(q_prim_ts(3)%vf, c_mass)
 
             call s_write_probe_files(t_step, q_cons_ts(1)%vf, accel_mag)
+            call s_write_com_files(t_step, c_mass)
         end if
 
     end subroutine s_compute_derived_variables
@@ -194,7 +192,6 @@ contains
             do l = 0, p
                 do k = 0, n
                     do j = 0, m
-
                         q_sf(j, k, l) = (11d0*q_prim_vf0(mom_idx%beg)%sf(j, k, l) &
                                          - 18d0*q_prim_vf1(mom_idx%beg)%sf(j, k, l) &
                                          + 9d0*q_prim_vf2(mom_idx%beg)%sf(j, k, l) &
@@ -234,18 +231,15 @@ contains
                     end do
                 end do
             end do
-
             ! Computing the acceleration component in the y-coordinate direction
         elseif (i == 2) then
             do l = 0, p
                 do k = 0, n
                     do j = 0, m
-
                         q_sf(j, k, l) = (11d0*q_prim_vf0(mom_idx%beg + 1)%sf(j, k, l) &
                                          - 18d0*q_prim_vf1(mom_idx%beg + 1)%sf(j, k, l) &
                                          + 9d0*q_prim_vf2(mom_idx%beg + 1)%sf(j, k, l) &
                                          - 2d0*q_prim_vf3(mom_idx%beg + 1)%sf(j, k, l))/(6d0*dt)
-
                         do r = -fd_number, fd_number
                             if (p == 0) then ! 2D simulation
                                 q_sf(j, k, l) = q_sf(j, k, l) &
@@ -316,11 +310,154 @@ contains
 
     end subroutine s_derive_acceleration_component
 
+    !> This subroutine is used together with the volume fraction
+    !!      model and when called upon, it computes the location of
+    !!      of the center of mass for each fluid from the inputted
+    !!      primitive variables, q_prim_vf. The computed location
+    !!      is then written to a formatted data file by the root process.
+    !!  @param q_prim_vf Primitive variables
+    !!  @param c_m Mass,x-location,y-location,z-location
+    subroutine s_derive_center_of_mass(q_vf, c_m)
+        type(scalar_field), dimension(sys_size), intent(IN) :: q_vf
+        real(kind(0d0)), dimension(1:num_fluids, 1:5), intent(INOUT) :: c_m
+        integer :: i, j, k, l !< Generic loop iterators
+        real(kind(0d0)) :: tmp, tmp_out !< Temporary variable to store quantity for mpi_allreduce
+        real(kind(0d0)) :: dV !< Discrete cell volume
+
+        do i = 1, num_fluids
+            do j = 1, 5
+                c_m(i, j) = 0.0d0
+            end do
+        end do
+
+        if (n == 0) then !1D simulation
+            do i = 1, num_fluids !Loop over individual fluids
+                do l = 0, p !Loop over grid
+                    do k = 0, n
+                        do j = 0, m
+                            dV = dx(j)
+                            ! Mass
+                            c_m(i, 1) = c_m(i, 1) + q_vf(i)%sf(j, k, l)*dV
+                            ! x-location weighted
+                            c_m(i, 2) = c_m(i, 2) + q_vf(i)%sf(j, k, l)*dV*x_cc(j)
+                            ! Volume fraction
+                            c_m(i, 5) = c_m(i, 5) + q_vf(i + adv_idx%beg - 1)%sf(j, k, l)*dV
+                        end do
+                    end do
+                end do
+            end do
+        elseif (p == 0) then !2D simulation
+            do i = 1, num_fluids !Loop over individual fluids
+                do l = 0, p !Loop over grid
+                    do k = 0, n
+                        do j = 0, m
+                            dV = dx(j)*dy(k)
+                            ! Mass
+                            c_m(i, 1) = c_m(i, 1) + q_vf(i)%sf(j, k, l)*dV
+                            ! x-location weighted
+                            c_m(i, 2) = c_m(i, 2) + q_vf(i)%sf(j, k, l)*dV*x_cc(j)
+                            ! y-location weighted
+                            c_m(i, 3) = c_m(i, 3) + q_vf(i)%sf(j, k, l)*dV*y_cc(k)
+                            ! Volume fraction
+                            c_m(i, 5) = c_m(i, 5) + q_vf(i + adv_idx%beg - 1)%sf(j, k, l)*dV
+                        end do
+                    end do
+                end do
+            end do
+        else !3D simulation
+            do i = 1, num_fluids !Loop over individual fluids
+                do l = 0, p !Loop over grid
+                    do k = 0, n
+                        do j = 0, m
+                            dV = dx(j)*dy(k)*dz(l)
+                            ! Mass
+                            c_m(i, 1) = c_m(i, 1) + q_vf(i)%sf(j, k, l)*dV
+                            ! x-location weighted
+                            c_m(i, 2) = c_m(i, 2) + q_vf(i)%sf(j, k, l)*dV*x_cc(j)
+                            ! y-location weighted
+                            c_m(i, 3) = c_m(i, 3) + q_vf(i)%sf(j, k, l)*dV*y_cc(k)
+                            ! z-location weighted
+                            c_m(i, 4) = c_m(i, 4) + q_vf(i)%sf(j, k, l)*dV*z_cc(l)
+                            ! Volume fraction
+                            c_m(i, 5) = c_m(i, 5) + q_vf(i + adv_idx%beg - 1)%sf(j, k, l)*dV
+                        end do
+                    end do
+                end do
+            end do
+        end if
+        if (n == 0) then !1D simulation
+            do i = 1, num_fluids !Loop over individual fluids
+                ! Sum all components across all processors using MPI_ALLREDUCE
+                if (num_procs > 1) then
+                    tmp = c_m(i, 1)
+                    call s_mpi_allreduce_sum(tmp, tmp_out)
+                    c_m(i, 1) = tmp_out
+                    tmp = c_m(i, 2)
+                    call s_mpi_allreduce_sum(tmp, tmp_out)
+                    c_m(i, 2) = tmp_out
+                    tmp = c_m(i, 5)
+                    call s_mpi_allreduce_sum(tmp, tmp_out)
+                    c_m(i, 5) = tmp_out
+                end if
+                ! Compute quotients
+                c_m(i, 2) = c_m(i, 2)/c_m(i, 1)
+            end do
+        elseif (p == 0) then !2D simulation
+            do i = 1, num_fluids !Loop over individual fluids
+                ! Sum all components across all processors using MPI_ALLREDUCE
+                if (num_procs > 1) then
+                    tmp = c_m(i, 1)
+                    call s_mpi_allreduce_sum(tmp, tmp_out)
+                    c_m(i, 1) = tmp_out
+                    tmp = c_m(i, 2)
+                    call s_mpi_allreduce_sum(tmp, tmp_out)
+                    c_m(i, 2) = tmp_out
+                    tmp = c_m(i, 3)
+                    call s_mpi_allreduce_sum(tmp, tmp_out)
+                    c_m(i, 3) = tmp_out
+                    tmp = c_m(i, 5)
+                    call s_mpi_allreduce_sum(tmp, tmp_out)
+                    c_m(i, 5) = tmp_out
+                end if
+                ! Compute quotients
+                c_m(i, 2) = c_m(i, 2)/c_m(i, 1)
+                c_m(i, 3) = c_m(i, 3)/c_m(i, 1)
+            end do
+        else !3D simulation
+            do i = 1, num_fluids !Loop over individual fluids
+                ! Sum all components across all processors using MPI_ALLREDUCE
+                if (num_procs > 1) then
+                    tmp = c_m(i, 1)
+                    call s_mpi_allreduce_sum(tmp, tmp_out)
+                    c_m(i, 1) = tmp_out
+                    tmp = c_m(i, 2)
+                    call s_mpi_allreduce_sum(tmp, tmp_out)
+                    c_m(i, 2) = tmp_out
+                    tmp = c_m(i, 3)
+                    call s_mpi_allreduce_sum(tmp, tmp_out)
+                    c_m(i, 3) = tmp_out
+                    tmp = c_m(i, 4)
+                    call s_mpi_allreduce_sum(tmp, tmp_out)
+                    c_m(i, 4) = tmp_out
+                    tmp = c_m(i, 5)
+                    call s_mpi_allreduce_sum(tmp, tmp_out)
+                    c_m(i, 5) = tmp_out
+                end if
+                ! Compute quotients
+                c_m(i, 2) = c_m(i, 2)/c_m(i, 1)
+                c_m(i, 3) = c_m(i, 3)/c_m(i, 1)
+                c_m(i, 4) = c_m(i, 4)/c_m(i, 1)
+            end do
+        end if
+
+    end subroutine s_derive_center_of_mass ! ----------------------------------
+
     !> Deallocation procedures for the module
     subroutine s_finalize_derived_variables_module
 
         ! Closing CoM and flow probe files
         if (proc_rank == 0) then
+            call s_close_com_files()
             if (probe_wrt) then
                 call s_close_probe_files()
             end if
diff --git a/src/simulation/m_global_parameters.fpp b/src/simulation/m_global_parameters.fpp
index a703eb5c..539d3b56 100644
--- a/src/simulation/m_global_parameters.fpp
+++ b/src/simulation/m_global_parameters.fpp
@@ -144,9 +144,12 @@ module m_global_parameters
     integer :: wave_speeds    !< Wave speeds estimation method
     integer :: avg_state      !< Average state evaluation method
     logical :: alt_soundspeed !< Alternate mixture sound speed
-    logical :: null_weights   !< Null undesired WENO weights
-    logical :: mixture_err    !< Mixture properties correction
-    logical :: hypoelasticity !< hypoelasticity modeling
+    logical :: null_weights    !< Null undesired WENO weights
+    logical :: mixture_err     !< Mixture properties correction
+    logical :: hypoelasticity  !< hypoelasticity modeling
+    logical :: hyperelasticity !< hyperelasticity modeling
+    integer :: hyper_model     !< hyperelasticity solver algorithm
+    logical :: elasticity      !< elasticity modeling, true for hyper or hypo
     logical :: cu_tensor
 
     logical :: bodyForces
@@ -166,7 +169,7 @@ module m_global_parameters
         !$acc declare create(num_dims, weno_polyn, weno_order, num_fluids, wenojs, mapped_weno, wenoz, teno)
     #:endif
 
-    !$acc declare create(mpp_lim, model_eqns, mixture_err, alt_soundspeed, avg_state, mp_weno, weno_eps, teno_CT, hypoelasticity, low_Mach)
+    !$acc declare create(mpp_lim, model_eqns, mixture_err, alt_soundspeed, avg_state, mp_weno, weno_eps, teno_CT, hypoelasticity, hyperelasticity, elasticity, low_Mach)
 
     logical :: relax          !< activate phase change
     integer :: relax_model    !< Relaxation model
@@ -182,6 +185,8 @@ module m_global_parameters
     type(int_bounds_info) :: bc_x, bc_y, bc_z
     !> @}
     type(bounds_info) :: x_domain, y_domain, z_domain
+    real(kind(0d0)) :: x_a, y_a, z_a
+    real(kind(0d0)) :: x_b, y_b, z_b
 
     logical :: parallel_io !< Format of the data files
     logical :: file_per_process !< shared file or not when using parallel io
@@ -208,19 +213,22 @@ module m_global_parameters
     !> @name Annotations of the structure of the state and flux vectors in terms of the
     !! size and the configuration of the system of equations to which they belong
     !> @{
-    integer :: sys_size                  !< Number of unknowns in system of eqns.
+    integer :: sys_size                                !< Number of unknowns in system of eqns.
     type(int_bounds_info) :: cont_idx                  !< Indexes of first & last continuity eqns.
     type(int_bounds_info) :: mom_idx                   !< Indexes of first & last momentum eqns.
-    integer :: E_idx                     !< Index of energy equation
-    integer :: n_idx                     !< Index of number density
+    integer :: E_idx                                   !< Index of energy equation
+    integer :: n_idx                                   !< Index of number density
     type(int_bounds_info) :: adv_idx                   !< Indexes of first & last advection eqns.
     type(int_bounds_info) :: internalEnergies_idx      !< Indexes of first & last internal energy eqns.
-    type(bub_bounds_info) :: bub_idx               !< Indexes of first & last bubble variable eqns.
-    integer :: alf_idx               !< Index of void fraction
-    integer :: gamma_idx                 !< Index of specific heat ratio func. eqn.
-    integer :: pi_inf_idx                !< Index of liquid stiffness func. eqn.
+    type(bub_bounds_info) :: bub_idx                   !< Indexes of first & last bubble variable eqns.
+    integer :: alf_idx                                 !< Index of void fraction
+    integer :: gamma_idx                               !< Index of specific heat ratio func. eqn.
+    integer :: pi_inf_idx                              !< Index of liquid stiffness func. eqn.
     type(int_bounds_info) :: stress_idx                !< Indexes of first and last shear stress eqns.
-    integer :: c_idx         ! Index of the color function
+    type(int_bounds_info) :: xi_idx                    !< Indexes of first and last reference map eqns.
+    integer :: b_size                                  !< Number of elements in the symmetric b tensor, plus one
+    integer :: tensor_size                             !< Number of elements in the full tensor plus one
+    integer :: c_idx                                   !< Index of the color function
     !> @}
 
     !$acc declare create(bub_idx)
@@ -273,7 +281,7 @@ module m_global_parameters
 
     integer :: startx, starty, startz
 
-    !$acc declare create(sys_size, buff_size, startx, starty, startz, E_idx, gamma_idx, pi_inf_idx, alf_idx, n_idx, stress_idx)
+    !$acc declare create(sys_size, buff_size, startx, starty, startz, E_idx, gamma_idx, pi_inf_idx, alf_idx, n_idx, stress_idx,b_size, tensor_size, xi_idx)
 
     ! END: Simulation Algorithm Parameters =====================================
 
@@ -299,6 +307,7 @@ module m_global_parameters
     !! The finite-difference number is given by MAX(1, fd_order/2). Essentially,
     !! it is a measure of the half-size of the finite-difference stencil for the
     !! selected order of accuracy.
+    !$acc declare create(fd_order,fd_number)
 
     logical :: probe_wrt
     logical :: integral_wrt
@@ -435,7 +444,9 @@ module m_global_parameters
     integer :: intxb, intxe
     integer :: bubxb, bubxe
     integer :: strxb, strxe
+    integer :: xibeg, xiend
 !$acc declare create(momxb, momxe, advxb, advxe, contxb, contxe, intxb, intxe, bubxb, bubxe, strxb, strxe)
+!$acc declare create(xibeg,xiend)
 
 #ifdef CRAY_ACC_WAR
     @:CRAY_DECLARE_GLOBAL(real(kind(0d0)), dimension(:), gammas, gs_min, pi_infs, ps_inf, cvs, qvs, qvps)
@@ -515,6 +526,9 @@ contains
         palpha_eps = dflt_real
         ptgalpha_eps = dflt_real
         hypoelasticity = .false.
+        hyperelasticity = .false.
+        elasticity = .false.
+        hyper_model = dflt_int
         weno_flat = .true.
         riemann_flat = .true.
         rdma_mpi = .false.
@@ -828,13 +842,26 @@ contains
                     end if
                 end if
 
-                if (hypoelasticity) then
+                if (hypoelasticity .or. hyperelasticity) then
+                    elasticity = .true.
                     stress_idx%beg = sys_size + 1
                     stress_idx%end = sys_size + (num_dims*(num_dims + 1))/2
                     ! number of distinct stresses is 1 in 1D, 3 in 2D, 6 in 3D
                     sys_size = stress_idx%end
                 end if
 
+                if (hyperelasticity) then
+                    ! number of entries in the symmetric btensor plus the jacobian
+                    b_size = (num_dims*(num_dims + 1))/2 + 1
+                    ! storing the jacobian in the last entry
+                    tensor_size = num_dims**2 + 1
+                    xi_idx%beg = sys_size + 1
+                    xi_idx%end = sys_size + num_dims
+                    ! adding three more equations for the \xi field and the elastic energy
+                    sys_size = xi_idx%end + 1
+                    hyper_model = 1
+                end if
+
                 if (.not. f_is_default(sigma)) then
                     c_idx = sys_size + 1
                     sys_size = c_idx
@@ -853,6 +880,25 @@ contains
                 internalEnergies_idx%end = adv_idx%end + num_fluids
                 sys_size = internalEnergies_idx%end
 
+                if (hypoelasticity .or. hyperelasticity) then
+                  elasticity = .true.
+                  stress_idx%beg = sys_size + 1
+                  stress_idx%end = sys_size + (num_dims*(num_dims + 1))/2
+                  ! number of stresses is 1 in 1D, 3 in 2D, 6 in 3D
+                  sys_size = stress_idx%end
+                end if
+
+                if (hyperelasticity) then
+                    ! number of entries in the symmetric btensor plus the jacobian
+                    b_size = (num_dims*(num_dims + 1))/2 + 1
+                    ! storing the jacobian in the last entry
+                    tensor_size = num_dims**2 + 1
+                    xi_idx%beg = sys_size + 1
+                    xi_idx%end = sys_size + num_dims
+                    ! adding three more equations for the \xi field and the elastic energy
+                    sys_size = xi_idx%end + 1
+                end if
+
                 if (.not. f_is_default(sigma)) then
                     c_idx = sys_size + 1
                     sys_size = c_idx
@@ -989,12 +1035,18 @@ contains
         ! the next one
         if (any(Re_size > 0)) then
             buff_size = 2*weno_polyn + 2
-!        else if (hypoelasticity) then !TODO: check if necessary
+!        else if (elasticity) then !TODO: check if necessary
 !            buff_size = 2*weno_polyn + 2
         else
             buff_size = weno_polyn + 2
         end if
 
+        if (elasticity) then 
+          fd_order = 4
+          fd_number = max(1, fd_order/2)
+          !buff_size = buff_size + fd_number
+        end if 
+
         ! Configuring Coordinate Direction Indexes =========================
         if (bubbles) then
             ix%beg = -buff_size; iy%beg = 0; iz%beg = 0
@@ -1024,7 +1076,8 @@ contains
         if (p > 0) then
             startz = -buff_size
         end if
-
+ 
+        !$acc update device(fd_order,fd_number)
         !$acc update device(startx, starty, startz)
 
         if (cyl_coord .neqv. .true.) then ! Cartesian grid
@@ -1047,19 +1100,23 @@ contains
         strxe = stress_idx%end
         intxb = internalEnergies_idx%beg
         intxe = internalEnergies_idx%end
+        xibeg = xi_idx%beg
+        xiend = xi_idx%end
 
-        !$acc update device(momxb, momxe, advxb, advxe, contxb, contxe, bubxb, bubxe, intxb, intxe, sys_size, buff_size, E_idx, alf_idx, n_idx, adv_n, adap_dt, pi_fac, strxb, strxe)
+        !$acc update device(momxb, momxe, advxb, advxe, contxb, contxe, bubxb, bubxe, intxb, intxe, sys_size, buff_size, E_idx, alf_idx, n_idx, adv_n, adap_dt, pi_fac, strxb, strxe, b_size, xibeg, xiend, tensor_size)
         !$acc update device(m, n, p)
 
         !$acc update device(alt_soundspeed, acoustic_source, num_source)
-        !$acc update device(dt, sys_size, buff_size, pref, rhoref, gamma_idx, pi_inf_idx, E_idx, alf_idx, stress_idx, mpp_lim, bubbles, hypoelasticity, alt_soundspeed, avg_state, num_fluids, model_eqns, num_dims, mixture_err, grid_geometry, cyl_coord, mp_weno, weno_eps, teno_CT, low_Mach)
+        !$acc update device(dt, sys_size, buff_size, pref, rhoref, gamma_idx, pi_inf_idx, E_idx, alf_idx, stress_idx, mpp_lim, bubbles, hypoelasticity, alt_soundspeed, avg_state, num_fluids, model_eqns, num_dims, mixture_err, grid_geometry, cyl_coord, mp_weno, weno_eps, teno_CT, hyperelasticity, elasticity, xi_idx, low_Mach)
 
         #:if not MFC_CASE_OPTIMIZATION
             !$acc update device(wenojs, mapped_weno, wenoz, teno)
         #:endif
 
         !$acc enter data copyin(nb, R0ref, Ca, Web, Re_inv, weight, R0, V0, bubbles, polytropic, polydisperse, qbmm, R0_type, ptil, bubble_model, thermal, poly_sigma)
-        !$acc enter data copyin(R_n, R_v, phi_vn, phi_nv, Pe_c, Tw, pv, M_n, M_v, k_n, k_v, pb0, mass_n0, mass_v0, Pe_T, Re_trans_T, Re_trans_c, Im_trans_T, Im_trans_c, omegaN , mul0, ss, gamma_v, mu_v, gamma_m, gamma_n, mu_n, gam)
+
+        !$acc enter data copyin(R_n, R_v, phi_vn, phi_nv, Pe_c, Tw, pv, M_n, M_v, k_n, k_v, pb0, mass_n0, mass_v0, Pe_T, Re_trans_T, Re_trans_c, Im_trans_T, Im_trans_c, omegaN, mul0, ss, gamma_v, mu_v, gamma_m, gamma_n, mu_n, gam)
+
         !$acc enter data copyin(dir_idx, dir_flg, dir_idx_tau)
 
         !$acc enter data copyin(relax, relax_model, palpha_eps,ptgalpha_eps)
diff --git a/src/simulation/m_hyperelastic.fpp b/src/simulation/m_hyperelastic.fpp
new file mode 100644
index 00000000..9d8b6a4f
--- /dev/null
+++ b/src/simulation/m_hyperelastic.fpp
@@ -0,0 +1,364 @@
+!>
+!! @file m_hyperelastic.f90
+!! @brief Contains module m_hyperelastic
+
+#:include 'macros.fpp'
+
+!> @brief This module consists of subroutines used in the calculation 
+!!              of the cauchy tensor
+
+module m_hyperelastic
+
+    ! Dependencies =============================================================
+
+    use m_derived_types        !< Definitions of the derived types
+
+    use m_global_parameters    !< Definitions of the global parameters
+
+    use m_variables_conversion !< State variables type conversion procedures
+
+    use m_helper
+
+    ! ==========================================================================
+
+    implicit none
+
+    private; public ::  s_hyperelastic_rmt_stress_update, &
+ s_initialize_hyperelastic_module, &
+ s_finalize_hyperelastic_module
+
+    !> @name Abstract interface for creating function pointers
+    !> @{
+    abstract interface
+
+        !> @name Abstract subroutine for the infinite relaxation solver
+        !> @{
+        subroutine s_abstract_hyperelastic_solver(btensor, q_prim_vf, G, j, k, l)
+            !$acc routine seq
+            import :: scalar_field, sys_size, b_size
+            type(scalar_field), dimension(sys_size), intent(inout) :: q_prim_vf
+            type(scalar_field), dimension(b_size), intent(inout) :: btensor
+            real(kind(0d0)), intent(in) :: G
+            integer, intent(in) :: j, k, l
+             
+        end subroutine s_abstract_hyperelastic_solver
+        !> @}
+
+    end interface
+    !> @}
+
+    procedure(s_abstract_hyperelastic_solver), & 
+      pointer :: s_compute_cauchy_solver => null()
+
+    !! The btensor at the cell-interior Gaussian quadrature points.
+    !! These tensor is needed to be calculated once and make the code DRY.
+    type(vector_field) :: btensor !<
+    !$acc declare create(btensor)
+
+#ifdef CRAY_ACC_WAR
+    @:CRAY_DECLARE_GLOBAL(real(kind(0d0)), allocatable, dimension(:, :), fd_coeff_x, fd_coeff_y, fd_coeff_z)
+    !$acc declare link(fd_coeff_x,fd_coeff_y,fd_coeff_z)
+
+#else
+
+    real(kind(0d0)), allocatable, dimension(:, :) :: fd_coeff_x
+    real(kind(0d0)), allocatable, dimension(:, :) :: fd_coeff_y
+    real(kind(0d0)), allocatable, dimension(:, :) :: fd_coeff_z
+    !$acc declare create(fd_coeff_x,fd_coeff_y,fd_coeff_z)
+    real(kind(0d0)), allocatable, dimension(:) :: Gs
+    !$acc declare create(Gs)
+#endif
+
+contains
+
+     !>  The following subroutine handles the calculation of the btensor.
+        !!   The calculation of the btensor takes qprimvf.
+        !! @param q_prim_vf Primitive variables
+        !! @param btensor is the output
+        !! calculate the grad_xi, grad_xi is a nxn tensor
+        !! calculate the inverse of grad_xi to obtain F, F is a nxn tensor
+        !! calculate the FFtranspose to obtain the btensor, btensor is nxn tensor
+        !! btensor is symmetric, save the data space
+     subroutine s_initialize_hyperelastic_module()
+        integer :: i !< generic iterator
+   
+        @:ALLOCATE(btensor%vf(1:b_size))
+        do i = 1, b_size
+          @:ALLOCATE(btensor%vf(i)%sf(0:m, 0:n, 0:p))
+        end do
+        @:ACC_SETUP_VFs(btensor)
+
+        @:ALLOCATE(Gs(1:num_fluids))
+        !$acc loop seq
+        do i = 1, num_fluids
+            Gs(i) = fluid_pp(i)%G
+        end do
+        !$acc update device(Gs)
+
+        ! Associating procedural pointer to the subroutine that will be
+        ! utilized to calculate the solution of a given Riemann problem
+        if (hyper_model == 1) then
+            s_compute_cauchy_solver => s_neoHookean_cauchy_solver
+        elseif (riemann_solver == 2) then
+            s_compute_cauchy_solver => s_Mooney_Rivlin_cauchy_solver
+        end if
+
+        @:ALLOCATE_GLOBAL(fd_coeff_x(-fd_number:fd_number, 0:m))
+        if (n > 0) then
+           @:ALLOCATE_GLOBAL(fd_coeff_y(-fd_number:fd_number, 0:n))
+        end if
+        if (p > 0) then
+           @:ALLOCATE_GLOBAL(fd_coeff_z(-fd_number:fd_number, 0:p))
+        end if
+
+        ! Computing centered finite difference coefficients
+        call s_compute_finite_difference_coefficients(m, x_cc, fd_coeff_x, buff_size, &
+                                                        fd_number, fd_order)
+        !$acc update device(fd_coeff_x)
+        if (n > 0) then
+          call s_compute_finite_difference_coefficients(n, y_cc, fd_coeff_y, buff_size, &
+                                                           fd_number, fd_order)
+        !$acc update device(fd_coeff_y)
+        end if
+        if (p > 0) then
+            call s_compute_finite_difference_coefficients(p, z_cc, fd_coeff_z, buff_size, &
+                                                          fd_number, fd_order)
+        !$acc update device(fd_coeff_z)
+        end if
+
+     end subroutine s_initialize_hyperelastic_module
+
+     !>  The following subroutine handles the calculation of the btensor.
+        !!   The calculation of the btensor takes qprimvf.
+        !! @param q_prim_vf Primitive variables
+        !! @param btensor is the output
+        !! calculate the grad_xi, grad_xi is a nxn tensor
+        !! calculate the inverse of grad_xi to obtain F, F is a nxn tensor
+        !! calculate the FFtranspose to obtain the btensor, btensor is nxn tensor
+        !! btensor is symmetric, save the data space
+     subroutine s_hyperelastic_rmt_stress_update(q_cons_vf,q_prim_vf)
+
+        type(scalar_field), dimension(sys_size), intent(inout) :: q_cons_vf
+        type(scalar_field), dimension(sys_size), intent(inout) :: q_prim_vf
+
+        real(kind(0d0)), dimension(tensor_size) :: tensora, tensorb
+        real(kind(0d0)), dimension(num_fluids) :: alpha_K, alpha_rho_K
+        real(kind(0d0)), dimension(2) :: Re_K
+        real(kind(0d0)) :: rho_K, gamma_K, pi_inf_K, qv_K
+        real(kind(0d0)) :: G_K 
+        integer :: j, k, l, i, r
+
+        !$acc parallel loop collapse(3) gang vector default(present) private(alpha_K,alpha_rho_K,rho_K,gamma_K,pi_inf_K,qv_K,G_K,Re_K, tensora, tensorb)
+        do l = 0, p-2
+           do k = 0, n-2
+              do j = 2, m-2       
+                !$acc loop seq
+                do i = 1, num_fluids
+                   alpha_rho_K(i) = q_cons_vf(i)%sf(j, k, l)
+                   alpha_K(i) = q_cons_vf(advxb + i - 1)%sf(j, k, l)
+                end do
+                ! If in simulation, use acc mixture subroutines
+                call s_convert_species_to_mixture_variables_acc(rho_K, gamma_K, pi_inf_K, qv_K, alpha_K, &
+                              alpha_rho_K, Re_K, j, k, l, G_K, Gs)
+                rho_K = max(rho_K, sgm_eps)
+                if ( G_K .le. verysmall ) G_K = 0d0
+
+                if ( G_K .gt. 20d0 ) then
+                  !$acc loop seq 
+                  do i = 1, tensor_size
+                    tensora(i) = 0d0
+                  end do
+                  ! STEP 1: computing the grad_xi tensor using finite differences
+                  ! grad_xi definition / organization
+                  ! number for the tensor 1-3:  dxix_dx, dxiy_dx, dxiz_dx
+                  ! 4-6 :                       dxix_dy, dxiy_dy, dxiz_dy
+                  ! 7-9 :                       dxix_dz, dxiy_dz, dxiz_dz
+                  !$acc loop seq 
+                  do r = -fd_number, fd_number        
+                    ! derivatives in the x-direction
+                    tensora(1) = tensora(1) + q_prim_vf(xibeg)%sf(j + r, k, l)*fd_coeff_x(r, j)
+                    tensora(2) = tensora(2) + q_prim_vf(xibeg+1)%sf(j + r, k, l)*fd_coeff_x(r, j)
+                    tensora(3) = tensora(3) + q_prim_vf(xiend)%sf(j + r, k, l)*fd_coeff_x(r, j)
+                    ! derivatives in the y-direction
+                    tensora(4) = tensora(4) + q_prim_vf(xibeg)%sf(j, k + r, l)*fd_coeff_y(r, k)
+                    tensora(5) = tensora(5) + q_prim_vf(xibeg+1)%sf(j, k + r, l)*fd_coeff_y(r, k)
+                    tensora(6) = tensora(6) + q_prim_vf(xiend)%sf(j, k + r, l)*fd_coeff_y(r, k)
+                    ! derivatives in the z-direction
+                    tensora(7) = tensora(7) + q_prim_vf(xibeg)%sf(j, k, l + r)*fd_coeff_z(r, l)
+                    tensora(8) = tensora(8) + q_prim_vf(xibeg+1)%sf(j, k, l + r)*fd_coeff_z(r, l)
+                    tensora(9) = tensora(9) + q_prim_vf(xiend)%sf(j, k, l + r)*fd_coeff_z(r, l)
+                  end do 
+                  ! STEP 2a: computing the adjoint of the grad_xi tensor for the inverse
+                  tensorb(1) = tensora(5)*tensora(9) - tensora(6)*tensora(8)
+                  tensorb(2) = -(tensora(2)*tensora(9) - tensora(3)*tensora(8))
+                  tensorb(3) = tensora(2)*tensora(6) - tensora(3)*tensora(5)
+                  tensorb(4) = -(tensora(4)*tensora(9) - tensora(6)*tensora(7))
+                  tensorb(5) = tensora(1)*tensora(9) - tensora(3)*tensora(7)
+                  tensorb(6) = -(tensora(1)*tensora(6) - tensora(4)*tensora(3))
+                  tensorb(7) = tensora(4)*tensora(8) - tensora(5)*tensora(7)
+                  tensorb(8) = -(tensora(1)*tensora(8) - tensora(2)*tensora(7))
+                  tensorb(9) = tensora(1)*tensora(5) - tensora(2)*tensora(4)
+
+                  ! STEP 2b: computing the determinant of the grad_xi tensor
+                  tensorb(tensor_size) = tensora(1)*(tensora(5)*tensora(9) - tensora(6)*tensora(8)) &
+                                    - tensora(2)*(tensora(4)*tensora(9) - tensora(6)*tensora(7)) &
+                                    + tensora(3)*(tensora(4)*tensora(8) - tensora(5)*tensora(7))
+
+                  if (tensorb(tensor_size) > 0d0) then 
+                    ! STEP 2c: computing the inverse of grad_xi tensor = F
+                    ! tensorb is the adjoint, tensora becomes F
+                    !$acc loop seq
+                    do i = 1, tensor_size - 1
+                      tensora(i) = tensorb(i)/tensorb(tensor_size)
+                    end do
+ 
+                    ! STEP 2d: computing the J = det(F) = 1/det(\grad{\xi})
+                    tensorb(tensor_size) = 1d0/tensorb(tensor_size)
+
+                    ! STEP 3: computing F tranpose F
+                    tensorb(1) = tensora(1)**2 + tensora(2)**2 + tensora(3)**2
+                    tensorb(5) = tensora(4)**2 + tensora(5)**2 + tensora(6)**2
+                    tensorb(9) = tensora(7)**2 + tensora(8)**2 + tensora(9)**2
+                    tensorb(2) = tensora(1)*tensora(4) + tensora(2)*tensora(5) + tensora(3)*tensora(6)
+                    tensorb(3) = tensora(1)*tensora(7) + tensora(2)*tensora(8) + tensora(3)*tensora(9)
+                    tensorb(6) = tensora(4)*tensora(7) + tensora(5)*tensora(8) + tensora(6)*tensora(9)
+                    ! STEP 4: update the btensor, this is consistent with Riemann solvers
+                    ! \tau_xx
+                    btensor%vf(1)%sf(j, k, l) = tensorb(1) 
+                    ! \tau_xy
+                    btensor%vf(2)%sf(j, k, l) = tensorb(2)
+                    ! \tau_yy
+                    btensor%vf(3)%sf(j, k, l) = tensorb(5)
+                    ! \tau_xz
+                    btensor%vf(4)%sf(j, k, l) = tensorb(3)
+                    ! \tau_yz
+                    btensor%vf(5)%sf(j, k, l) = tensorb(6)
+                    ! \tau_zz
+                    btensor%vf(6)%sf(j, k, l) = tensorb(9)
+                    ! store the determinant at the last entry of the btensor 
+                    btensor%vf(b_size)%sf(j, k, l) = tensorb(tensor_size)   
+                    ! STEP 5a: updating the Cauchy stress primitive scalar field
+                    call s_compute_cauchy_solver(btensor%vf, q_prim_vf, G_K, j, k, l)
+                    ! STEP 5b: updating the pressure field
+                    q_prim_vf(E_idx)%sf(j, k, l) = q_prim_vf(E_idx)%sf(j, k, l) - &
+                        G_K*q_prim_vf(xiend + 1)%sf(j, k, l)/gamma_K
+                    ! STEP 5c: updating the Cauchy stress conservative scalar field
+                    !$acc loop seq
+                    do i = 1, b_size - 1
+                      q_cons_vf(strxb + i - 1)%sf(j, k, l) =  & 
+                        rho_K*q_prim_vf(strxb + i - 1)%sf(j, k, l)
+                    end do
+                end if
+              end if
+            end do
+          end do
+        end do
+        !$acc end parallel loop
+     end subroutine s_hyperelastic_rmt_stress_update
+
+     !>  The following subroutine handles the calculation of the btensor.
+        !!   The calculation of the btensor takes qprimvf.
+        !! @param q_prim_vf Primitive variables
+        !! @param btensor is the output
+        !! calculate the grad_xi, grad_xi is a nxn tensor
+        !! calculate the inverse of grad_xi to obtain F, F is a nxn tensor
+        !! calculate the FFtranspose to obtain the btensor, btensor is nxn tensor
+        !! btensor is symmetric, save the data space
+     subroutine s_neoHookean_cauchy_solver(btensor, q_prim_vf, G, j, k, l)
+        !$acc routine seq
+        type(scalar_field), dimension(sys_size), intent(inout) :: q_prim_vf
+        type(scalar_field), dimension(b_size), intent(inout) :: btensor
+        real(kind(0d0)), intent(in) :: G
+        integer, intent(in) :: j, k, l
+
+        real(kind(0d0)) :: trace
+        real(kind(0d0)) :: f13 = 1d0/3d0
+        integer :: i !< Generic loop iterators
+
+        !TODO Make this 1D and 2D capable
+        ! tensor is the symmetric tensor & calculate the trace of the tensor
+        trace = btensor(1)%sf(j, k, l) + btensor(3)%sf(j, k, l) + btensor(6)%sf(j, k, l)
+
+        ! calculate the deviatoric of the tensor
+        btensor(1)%sf(j, k, l) = btensor(1)%sf(j, k, l) - f13*trace
+        btensor(3)%sf(j, k, l) = btensor(3)%sf(j, k, l) - f13*trace
+        btensor(6)%sf(j, k, l) = btensor(6)%sf(j, k, l) - f13*trace
+
+        ! dividing by the jacobian for neo-Hookean model
+        ! setting the tensor to the stresses for riemann solver
+        !$acc loop seq
+        do i = 1, b_size - 1
+          q_prim_vf(strxb + i - 1)%sf(j, k, l) =  & 
+            G*btensor(i)%sf(j, k, l)/btensor(b_size)%sf(j, k, l)
+        end do
+        ! compute the invariant without the elastic modulus
+        q_prim_vf(xiend + 1)%sf(j, k, l) =  & 
+           0.5d0*(trace - 3.0d0)/btensor(b_size)%sf(j, k, l)
+
+     end subroutine s_neoHookean_cauchy_solver
+
+     !>  The following subroutine handles the calculation of the btensor.
+        !!   The calculation of the btensor takes qprimvf.
+        !! @param q_prim_vf Primitive variables
+        !! @param btensor is the output
+        !! calculate the grad_xi, grad_xi is a nxn tensor
+        !! calculate the inverse of grad_xi to obtain F, F is a nxn tensor
+        !! calculate the FFtranspose to obtain the btensor, btensor is nxn tensor
+        !! btensor is symmetric, save the data space
+     subroutine s_Mooney_Rivlin_cauchy_solver(btensor, q_prim_vf, G, j, k, l)
+        !$acc routine seq
+        type(scalar_field), dimension(sys_size), intent(inout) :: q_prim_vf
+        type(scalar_field), dimension(b_size), intent(inout) :: btensor
+        real(kind(0d0)), intent(in) :: G
+        integer, intent(in) :: j, k, l
+
+        real(kind(0d0)) :: trace
+        real(kind(0d0)) :: f13 = 1d0/3d0
+        integer :: i !< Generic loop iterators
+
+        !TODO Make this 1D and 2D capable
+        ! tensor is the symmetric tensor & calculate the trace of the tensor
+        trace = btensor(1)%sf(j, k, l) + btensor(3)%sf(j, k, l) + btensor(6)%sf(j, k, l)
+
+        ! calculate the deviatoric of the tensor
+        btensor(1)%sf(j, k, l) = btensor(1)%sf(j, k, l) - f13*trace
+        btensor(3)%sf(j, k, l) = btensor(3)%sf(j, k, l) - f13*trace
+        btensor(6)%sf(j, k, l) = btensor(6)%sf(j, k, l) - f13*trace
+
+        ! dividing by the jacobian for neo-Hookean model
+        ! setting the tensor to the stresses for riemann solver
+        !$acc loop seq
+        do i = 1, b_size - 1
+          q_prim_vf(strxb + i - 1)%sf(j, k, l) =  & 
+            G*btensor(i)%sf(j, k, l)/btensor(b_size)%sf(j, k, l)
+        end do
+        ! compute the invariant without the elastic modulus
+        q_prim_vf(xiend + 1)%sf(j, k, l) =  & 
+           0.5d0*(trace - 3.0d0)/btensor(b_size)%sf(j, k, l)
+
+     end subroutine s_Mooney_Rivlin_cauchy_solver
+
+
+    subroutine  s_finalize_hyperelastic_module()
+
+      integer :: i !< iterator
+
+      ! Disassociating procedural pointer to the subroutine which was
+      ! utilized to calculate the solution of a given Riemann problem
+      s_compute_cauchy_solver => null()
+
+      ! Deallocating memory
+      do i = 1, b_size
+           @:DEALLOCATE_GLOBAL(btensor%vf(i)%sf)
+      end do
+      @:DEALLOCATE_GLOBAL(fd_coeff_x)
+      if (n > 0) then
+         @:DEALLOCATE_GLOBAL(fd_coeff_y)
+         if (p > 0) then
+            @:DEALLOCATE_GLOBAL(fd_coeff_z)
+         end if
+      end if
+
+    end subroutine s_finalize_hyperelastic_module
+
+end module m_hyperelastic
diff --git a/src/simulation/m_hypoelastic.fpp b/src/simulation/m_hypoelastic.fpp
index e3bb7ec0..7f3d54c3 100644
--- a/src/simulation/m_hypoelastic.fpp
+++ b/src/simulation/m_hypoelastic.fpp
@@ -13,13 +13,16 @@ module m_hypoelastic
 
     use m_global_parameters    !< Definitions of the global parameters
 
-    use m_mpi_proxy            !< Message passing interface (MPI) module proxy
+!    use m_mpi_proxy            !< Message passing interface (MPI) module proxy
+
+    use m_helper
 
     ! ==========================================================================
 
     implicit none
 
     private; public :: s_initialize_hypoelastic_module, &
+ s_finalize_hypoelastic_module, &
  s_compute_hypoelastic_rhs
 
 #ifdef CRAY_ACC_WAR
@@ -33,6 +36,10 @@ module m_hypoelastic
 
     @:CRAY_DECLARE_GLOBAL(real(kind(0d0)), dimension(:, :, :), rho_K_field, G_K_field)
     !$acc declare link(rho_K_field, G_K_field)
+
+    @:CRAY_DECLARE_GLOBAL(real(kind(0d0)), allocatable, dimension(:, :), fd_coeff_x, fd_coeff_y, fd_coeff_z)
+    !$acc declare link(fd_coeff_x,fd_coeff_y,fd_coeff_z)
+
 #else
     real(kind(0d0)), allocatable, dimension(:) :: Gs
     !$acc declare create(Gs)
@@ -45,13 +52,17 @@ module m_hypoelastic
     real(kind(0d0)), allocatable, dimension(:, :, :) :: rho_K_field, G_K_field
     !$acc declare create(rho_K_field, G_K_field)
 
+    real(kind(0d0)), allocatable, dimension(:, :) :: fd_coeff_x
+    real(kind(0d0)), allocatable, dimension(:, :) :: fd_coeff_y
+    real(kind(0d0)), allocatable, dimension(:, :) :: fd_coeff_z
+    !$acc declare create(fd_coeff_x,fd_coeff_y,fd_coeff_z)
 #endif
 
 contains
 
     subroutine s_initialize_hypoelastic_module
 
-        integer :: i
+        integer :: i, k, r
 
         @:ALLOCATE_GLOBAL(Gs(1:num_fluids))
         @:ALLOCATE_GLOBAL(rho_K_field(0:m,0:n,0:p), G_K_field(0:m,0:n,0:p))
@@ -69,6 +80,29 @@ contains
         end do
         !$acc update device(Gs)
 
+        @:ALLOCATE_GLOBAL(fd_coeff_x(-fd_number:fd_number, 0:m))
+        if (n > 0) then
+           @:ALLOCATE_GLOBAL(fd_coeff_y(-fd_number:fd_number, 0:n))
+        end if
+        if (p > 0) then
+           @:ALLOCATE_GLOBAL(fd_coeff_z(-fd_number:fd_number, 0:p))
+        end if
+
+        ! Computing centered finite difference coefficients
+        call s_compute_finite_difference_coefficients(m, x_cc, fd_coeff_x, buff_size, &
+                                                        fd_number, fd_order)
+        !$acc update device(fd_coeff_x)
+        if (n > 0) then
+          call s_compute_finite_difference_coefficients(n, y_cc, fd_coeff_y, buff_size, &
+                                                           fd_number, fd_order)
+        !$acc update device(fd_coeff_y)
+        end if
+        if (p > 0) then
+            call s_compute_finite_difference_coefficients(p, z_cc, fd_coeff_z, buff_size, &
+                                                          fd_number, fd_order)
+        !$acc update device(fd_coeff_z)
+        end if
+
     end subroutine s_initialize_hypoelastic_module
 
     !>  The purpose of this procedure is to compute the source terms
@@ -84,7 +118,7 @@ contains
 
         real(kind(0d0)) :: rho_K, G_K
 
-        integer :: i, k, l, q !< Loop variables
+        integer :: i, k, l, q, r !< Loop variables
         integer :: ndirs  !< Number of coordinate directions
 
         ndirs = 1; if (n > 0) ndirs = 2; if (p > 0) ndirs = 3
@@ -97,82 +131,91 @@ contains
             do q = 0, p
                 do l = 0, n
                     do k = 0, m
-                        du_dx(k, l, q) = &
-                            (q_prim_vf(momxb)%sf(k - 2, l, q) &
-                             - 8d0*q_prim_vf(momxb)%sf(k - 1, l, q) &
-                             + 8d0*q_prim_vf(momxb)%sf(k + 1, l, q) &
-                             - q_prim_vf(momxb)%sf(k + 2, l, q)) &
-                            /(12d0*dx(k))
+                        du_dx(k, l, q) = 0d0;
                     end do
                 end do
             end do
+            !$acc end parallel loop
+ 
+            !$acc parallel loop collapse(3) gang vector default(present) 
+              do q = 0, p
+                do l = 0, n
+                    do k = 0, m
+                      !$acc loop seq
+                      do r = -fd_number, fd_number        
+                       du_dx(k, l, q) = du_dx(k, l, q) &
+                        + q_prim_vf(momxb)%sf(k + r, l, q)*fd_coeff_x(r, k)
+                      end do
+
+                    end do
+                end do
+              end do
+            !$acc end parallel loop
 
             if (ndirs > 1) then
                 !$acc parallel loop collapse(3) gang vector default(present)
                 do q = 0, p
-                    do l = 0, n
-                        do k = 0, m
-                            du_dy(k, l, q) = &
-                                (q_prim_vf(momxb)%sf(k, l - 2, q) &
-                                 - 8d0*q_prim_vf(momxb)%sf(k, l - 1, q) &
-                                 + 8d0*q_prim_vf(momxb)%sf(k, l + 1, q) &
-                                 - q_prim_vf(momxb)%sf(k, l + 2, q)) &
-                                /(12d0*dy(l))
-                            dv_dx(k, l, q) = &
-                                (q_prim_vf(momxb + 1)%sf(k - 2, l, q) &
-                                 - 8d0*q_prim_vf(momxb + 1)%sf(k - 1, l, q) &
-                                 + 8d0*q_prim_vf(momxb + 1)%sf(k + 1, l, q) &
-                                 - q_prim_vf(momxb + 1)%sf(k + 2, l, q)) &
-                                /(12d0*dx(k))
-                            dv_dy(k, l, q) = &
-                                (q_prim_vf(momxb + 1)%sf(k, l - 2, q) &
-                                 - 8d0*q_prim_vf(momxb + 1)%sf(k, l - 1, q) &
-                                 + 8d0*q_prim_vf(momxb + 1)%sf(k, l + 1, q) &
-                                 - q_prim_vf(momxb + 1)%sf(k, l + 2, q)) &
-                                /(12d0*dy(l))
-                        end do
+                  do l = 0, n
+                    do k = 0, m
+                        du_dy(k, l, q) = 0d0; dv_dx(k, l, q) = 0d0; dv_dy(k, l, q) = 0d0;
                     end do
+                  end do
+                end do
+                !$acc end parallel loop
+
+                !$acc parallel loop collapse(3) gang vector default(present)
+                do q = 0, p
+                  do l = 0, n
+                     do k = 0, m
+                        !$acc loop seq
+                        do r = -fd_number, fd_number
+                            du_dy(k, l, q) = du_dy(k, l, q) &
+                              + q_prim_vf(momxb)%sf(k, l + r, q)*fd_coeff_y(r, l)
+                            dv_dx(k, l, q) = dv_dx(k, l, q) &
+                              + q_prim_vf(momxb + 1)%sf(k + r, l, q)*fd_coeff_x(r, k)
+                            dv_dy(k, l, q) = dv_dy(k, l, q) &
+                              + q_prim_vf(momxb + 1)%sf(k, l + r, q)*fd_coeff_y(r, l)
+                         end do
+                      end do
+                   end do
                 end do
+                !$acc end parallel loop
 
                 ! 3D
                 if (ndirs == 3) then
+
                     !$acc parallel loop collapse(3) gang vector default(present)
                     do q = 0, p
-                        do l = 0, n
-                            do k = 0, m
-                                du_dz(k, l, q) = &
-                                    (q_prim_vf(momxb)%sf(k, l, q - 2) &
-                                     - 8d0*q_prim_vf(momxb)%sf(k, l, q - 1) &
-                                     + 8d0*q_prim_vf(momxb)%sf(k, l, q + 1) &
-                                     - q_prim_vf(momxb)%sf(k, l, q + 2)) &
-                                    /(12d0*dz(q))
-                                dv_dz(k, l, q) = &
-                                    (q_prim_vf(momxb + 1)%sf(k, l, q - 2) &
-                                     - 8d0*q_prim_vf(momxb + 1)%sf(k, l, q - 1) &
-                                     + 8d0*q_prim_vf(momxb + 1)%sf(k, l, q + 1) &
-                                     - q_prim_vf(momxb + 1)%sf(k, l, q + 2)) &
-                                    /(12d0*dz(q))
-                                dw_dx(k, l, q) = &
-                                    (q_prim_vf(momxe)%sf(k - 2, l, q) &
-                                     - 8d0*q_prim_vf(momxe)%sf(k - 1, l, q) &
-                                     + 8d0*q_prim_vf(momxe)%sf(k + 1, l, q) &
-                                     - q_prim_vf(momxe)%sf(k + 2, l, q)) &
-                                    /(12d0*dx(k))
-                                dw_dy(k, l, q) = &
-                                    (q_prim_vf(momxe)%sf(k, l - 2, q) &
-                                     - 8d0*q_prim_vf(momxe)%sf(k, l - 1, q) &
-                                     + 8d0*q_prim_vf(momxe)%sf(k, l + 1, q) &
-                                     - q_prim_vf(momxe)%sf(k, l + 2, q)) &
-                                    /(12d0*dy(l))
-                                dw_dz(k, l, q) = &
-                                    (q_prim_vf(momxe)%sf(k, l, q - 2) &
-                                     - 8d0*q_prim_vf(momxe)%sf(k, l, q - 1) &
-                                     + 8d0*q_prim_vf(momxe)%sf(k, l, q + 1) &
-                                     - q_prim_vf(momxe)%sf(k, l, q + 2)) &
-                                    /(12d0*dz(q))
-                            end do
+                      do l = 0, n
+                        do k = 0, m
+                          du_dz(k, l, q) = 0d0; dv_dz(k, l, q) = 0d0; dw_dx(k, l, q) = 0d0;
+                          dw_dy(k, l, q) = 0d0; dw_dz(k, l, q) = 0d0; 
                         end do
+                      end do
+                    end do
+                    !$acc end parallel loop
+
+                    !$acc parallel loop collapse(3) gang vector default(present)
+                    do q = 0, p
+                       do l = 0, n
+                          do k = 0, m
+                             !$acc loop seq
+                             do r = -fd_number, fd_number
+                                du_dz(k, l, q) = du_dz(k, l, q) &
+                                + q_prim_vf(momxb)%sf(k, l, q + r)*fd_coeff_z(r, q)
+                                dv_dz(k, l, q) = dv_dz(k, l, q) &
+                                + q_prim_vf(momxb + 1)%sf(k, l, q + r)*fd_coeff_z(r, q)
+                                dw_dx(k, l, q) = dw_dx(k, l, q) &
+                                + q_prim_vf(momxe)%sf(k + r, l, q)*fd_coeff_x(r, k)
+                                dw_dy(k, l, q) = dw_dy(k, l, q) &
+                                + q_prim_vf(momxe)%sf(k, l + r, q)*fd_coeff_y(r, l)
+                                dw_dz(k, l, q) = dw_dz(k, l, q) &
+                                + q_prim_vf(momxe)%sf(k, l, q + r)*fd_coeff_z(r, q)
+                             end do
+                          end do
+                       end do
                     end do
+                    !$acc end parallel loop
                 end if
             end if
 
@@ -189,7 +232,7 @@ contains
                         G_K_field(k, l, q) = G_K
 
                         !TODO: take this out if not needed
-                        if (G_K < 1000) then
+                        if (G_K < verysmall) then
                             G_K_field(k, l, q) = 0
                         end if
                     end do
@@ -314,4 +357,21 @@ contains
 
     end subroutine s_compute_hypoelastic_rhs
 
+    subroutine s_finalize_hypoelastic_module() ! --------------------
+
+        @:DEALLOCATE_GLOBAL(Gs)
+        @:DEALLOCATE_GLOBAL(rho_K_field, G_K_field)
+        @:DEALLOCATE_GLOBAL(du_dx)
+        @:DEALLOCATE_GLOBAL(fd_coeff_x)
+        if (n > 0) then
+            @:DEALLOCATE_GLOBAL(du_dy,dv_dx,dv_dy)
+            @:DEALLOCATE_GLOBAL(fd_coeff_y)
+            if (p > 0) then
+                @:DEALLOCATE_GLOBAL(du_dz, dv_dz, dw_dx, dw_dy, dw_dz)
+                @:DEALLOCATE_GLOBAL(fd_coeff_z)
+            end if
+        end if
+
+    end subroutine s_finalize_hypoelastic_module
+
 end module m_hypoelastic
diff --git a/src/simulation/m_ibm.fpp b/src/simulation/m_ibm.fpp
index a0fa5972..01c34581 100644
--- a/src/simulation/m_ibm.fpp
+++ b/src/simulation/m_ibm.fpp
@@ -208,7 +208,7 @@ contains
 
             if (model_eqns /= 4) then
                 ! If in simulation, use acc mixture subroutines
-                if (hypoelasticity) then
+                if (elasticity) then
                     call s_convert_species_to_mixture_variables_acc(rho, gamma, pi_inf, qv_K, alpha_IP, &
                                                                     alpha_rho_IP, Re_K, j, k, l, G_K, Gs)
                 else if (bubbles) then
diff --git a/src/simulation/m_mpi_proxy.fpp b/src/simulation/m_mpi_proxy.fpp
index 26700d16..513d5bec 100644
--- a/src/simulation/m_mpi_proxy.fpp
+++ b/src/simulation/m_mpi_proxy.fpp
@@ -173,7 +173,40 @@ contains
         !!      available to the other processors. Then, the purpose of
         !!      this subroutine is to distribute the user inputs to the
         !!      remaining processors in the communicator.
-    subroutine s_mpi_bcast_user_inputs
+
+    subroutine s_mpi_gather_data(my_vector, counts, gathered_vector, root)
+
+#ifdef MFC_MPI
+
+        implicit none
+        integer, intent(in) :: counts          ! Array of vector lengths for each process
+        real(kind(0d0)), intent(in), dimension(counts) :: my_vector   ! Input vector on each process
+        integer, intent(in) :: root               ! Rank of the root process
+        real(kind(0d0)), allocatable, intent(out) :: gathered_vector(:) ! Gathered vector on the root process
+
+        integer :: i, offset, ierr
+        integer, allocatable :: recounts(:), displs(:)
+
+        allocate (recounts(num_procs))
+
+        call MPI_GATHER(counts, 1, MPI_INTEGER, recounts, 1, MPI_INTEGER, root, &
+                        MPI_COMM_WORLD, ierr)
+
+        allocate (displs(size(recounts)))
+
+        displs(1) = 0
+
+        do i = 2, size(recounts)
+            displs(i) = displs(i - 1) + recounts(i - 1)
+        end do
+
+        allocate (gathered_vector(sum(recounts)))
+        call MPI_GATHERV(my_vector, counts, MPI_DOUBLE_PRECISION, gathered_vector, recounts, displs, MPI_DOUBLE_PRECISION, &
+                         root, MPI_COMM_WORLD, ierr)
+#endif
+    end subroutine s_mpi_gather_data
+
+    subroutine s_mpi_bcast_user_inputs() ! ---------------------------------
 
 #ifdef MFC_MPI
 
@@ -202,7 +235,8 @@ contains
             & 'parallel_io', 'hypoelasticity', 'bubbles', 'polytropic',          &
             & 'polydisperse', 'qbmm', 'acoustic_source', 'probe_wrt', 'integral_wrt',   &
             & 'prim_vars_wrt', 'weno_avg', 'file_per_process', 'relax',          &
-            & 'adv_n', 'adap_dt', 'ib', 'bodyForces', 'bf_x', 'bf_y', 'bf_z' ]
+            & 'adv_n', 'adap_dt', 'ib', 'bodyForces', 'bf_x', 'bf_y', 'bf_z',    &
+            & 'hyperelasticity' ]
             call MPI_BCAST(${VAR}$, 1, MPI_LOGICAL, 0, MPI_COMM_WORLD, ierr)
         #:endfor
 
@@ -212,7 +246,8 @@ contains
             & 'bc_y%vb1','bc_y%vb2','bc_y%vb3','bc_y%ve1','bc_y%ve2','bc_y%ve3', &
             & 'bc_z%vb1','bc_z%vb2','bc_z%vb3','bc_z%ve1','bc_z%ve2','bc_z%ve3', &
             & 'x_domain%beg', 'x_domain%end', 'y_domain%beg', 'y_domain%end',    &
-            & 'z_domain%beg', 'z_domain%end']
+            & 'z_domain%beg', 'z_domain%end', 'x_a', 'x_b', 'y_a', 'y_b', 'z_a', &
+            & 'z_b']
             call MPI_BCAST(${VAR}$, 1, MPI_DOUBLE_PRECISION, 0, MPI_COMM_WORLD, ierr)
         #:endfor
 
diff --git a/src/simulation/m_rhs.fpp b/src/simulation/m_rhs.fpp
index c2056b42..72bb1c87 100644
--- a/src/simulation/m_rhs.fpp
+++ b/src/simulation/m_rhs.fpp
@@ -39,6 +39,8 @@ module m_rhs
 
     use m_hypoelastic
 
+    use m_hyperelastic
+
     use m_acoustic_src
 
     use m_viscous
@@ -615,7 +617,6 @@ contains
                 if (riemann_solver /= 1) then
                     do l = adv_idx%beg + 1, adv_idx%end
                         flux_src_n(i)%vf(l)%sf => flux_src_n(i)%vf(adv_idx%beg)%sf
-
                         !$acc enter data attach(flux_src_n(i)%vf(l)%sf)
                     end do
                 end if
@@ -623,7 +624,6 @@ contains
                 do l = 1, sys_size
                     flux_n(i)%vf(l)%sf => flux_n(1)%vf(l)%sf
                     flux_src_n(i)%vf(l)%sf => flux_src_n(1)%vf(l)%sf
-
                     !$acc enter data attach(flux_n(i)%vf(l)%sf,flux_src_n(i)%vf(l)%sf)
                 end do
             end if
@@ -778,7 +778,7 @@ contains
                 end do
             end do
         end if
-
+        !print *, "I got here A"
         call nvtxStartRange("RHS-CONVERT")
         call s_convert_conservative_to_primitive_variables( &
             q_cons_qp%vf, &
@@ -786,10 +786,16 @@ contains
             gm_alpha_qp%vf, &
             ix, iy, iz)
         call nvtxEndRange
+        !print *, "I got here B"
 
         call nvtxStartRange("RHS-MPI")
         call s_populate_primitive_variables_buffers(q_prim_qp%vf, pb, mv)
         call nvtxEndRange
+        !print *, "I got here c"
+
+        call nvtxStartRange("RHS-ELASTIC")
+          if (hyperelasticity) call s_hyperelastic_rmt_stress_update(q_cons_qp%vf,q_prim_qp%vf)
+        call nvtxEndRange
 
         if (t_step == t_step_stop) return
         ! ==================================================================
@@ -897,10 +903,8 @@ contains
             end if
             ix%end = m; iy%end = n; iz%end = p
             ! ===============================================================
-            call nvtxStartRange("RHS_riemann_solver")
-
             ! Computing Riemann Solver Flux and Source Flux =================
-
+            call nvtxStartRange("RHS_riemann_solver")
             call s_riemann_solver(qR_rsx_vf, qR_rsy_vf, qR_rsz_vf, &
                                   dqR_prim_dx_n(id)%vf, &
                                   dqR_prim_dy_n(id)%vf, &
@@ -917,9 +921,10 @@ contains
                                   flux_gsrc_n(id)%vf, &
                                   id, ix, iy, iz)
             call nvtxEndRange
+            !print *, "I got here e"
 
-            ! Additional physics and source terms ==============================
-
+            ! ===============================================================
+            ! Additional physics and source terms ===========================
             ! RHS addition for advection source
             call nvtxStartRange("RHS_advection_source")
             call s_compute_advection_source_term(id, &
@@ -935,6 +940,7 @@ contains
                                                                q_prim_qp%vf, &
                                                                rhs_vf)
             call nvtxEndRange
+            !print *, "I got here f"
 
             ! RHS additions for viscosity
             call nvtxStartRange("RHS_add_phys")
@@ -1006,6 +1012,7 @@ contains
             rhs_vf)
         call nvtxEndRange
         ! END: Additional pphysics and source terms ============================
+        !print *, "I got here g"
 
         if (run_time_info .or. probe_wrt .or. ib) then
 
@@ -1033,6 +1040,7 @@ contains
             time_avg = 0d0
         end if
         ! ==================================================================
+        !print *, "I got here h"
 
         call nvtxEndRange
     end subroutine s_compute_rhs
diff --git a/src/simulation/m_riemann_solvers.fpp b/src/simulation/m_riemann_solvers.fpp
index bfca7142..16b20b02 100644
--- a/src/simulation/m_riemann_solvers.fpp
+++ b/src/simulation/m_riemann_solvers.fpp
@@ -162,14 +162,14 @@ module m_riemann_solvers
     @:CRAY_DECLARE_GLOBAL(real(kind(0d0)), dimension(:, :, :, :), flux_rsx_vf, flux_src_rsx_vf)
     @:CRAY_DECLARE_GLOBAL(real(kind(0d0)), dimension(:, :, :, :), flux_rsy_vf, flux_src_rsy_vf)
     @:CRAY_DECLARE_GLOBAL(real(kind(0d0)), dimension(:, :, :, :), flux_rsz_vf, flux_src_rsz_vf)
-    !$acc declare link( flux_rsx_vf, flux_src_rsx_vf, flux_rsy_vf,  &
-    !$acc   flux_src_rsy_vf, flux_rsz_vf, flux_src_rsz_vf )
+    !$acc declare link( flux_rsx_vf, flux_src_rsx_vf, flux_rsy_vf, & 
+    !$acc flux_src_rsy_vf, flux_rsz_vf, flux_src_rsz_vf )
 #else
     real(kind(0d0)), allocatable, dimension(:, :, :, :) :: flux_rsx_vf, flux_src_rsx_vf
     real(kind(0d0)), allocatable, dimension(:, :, :, :) :: flux_rsy_vf, flux_src_rsy_vf
     real(kind(0d0)), allocatable, dimension(:, :, :, :) :: flux_rsz_vf, flux_src_rsz_vf
-    !$acc declare create( flux_rsx_vf, flux_src_rsx_vf, flux_rsy_vf,  &
-    !$acc   flux_src_rsy_vf, flux_rsz_vf, flux_src_rsz_vf )
+    !$acc declare create( flux_rsx_vf, flux_src_rsx_vf, flux_rsy_vf, & 
+    !$acc flux_src_rsy_vf, flux_rsz_vf, flux_src_rsz_vf)
 #endif
     !> @}
 
@@ -313,6 +313,7 @@ contains
         real(kind(0d0)), dimension(6) :: tau_e_L, tau_e_R
         real(kind(0d0)) :: G_L, G_R
         real(kind(0d0)), dimension(2) :: Re_L, Re_R
+        real(kind(0d0)), dimension(3) :: xi_field_L, xi_field_R
 
         real(kind(0d0)) :: rho_avg
         real(kind(0d0)), dimension(num_dims) :: vel_avg
@@ -356,8 +357,7 @@ contains
         #:for NORM_DIR, XYZ in [(1, 'x'), (2, 'y'), (3, 'z')]
 
             if (norm_dir == ${NORM_DIR}$) then
-                !$acc parallel loop collapse(3) gang vector default(present) private(alpha_rho_L, alpha_rho_R, vel_L, vel_R, alpha_L, alpha_R, vel_avg, tau_e_L, tau_e_R, G_L, G_R, Re_L, Re_R, &
-                !$acc rho_avg, h_avg, gamma_avg, s_L, s_R, s_S)
+                !$acc parallel loop collapse(3) gang vector default(present) private(alpha_rho_L, alpha_rho_R, vel_L, vel_R, alpha_L, alpha_R, vel_avg, tau_e_L, tau_e_R, G_L, G_R, Re_L, Re_R, rho_avg, h_avg, gamma_avg, s_L, s_R, s_S, xi_field_L, xi_field_R)
                 do l = is3%beg, is3%end
                     do k = is2%beg, is2%end
                         do j = is1%beg, is1%end
@@ -440,31 +440,24 @@ contains
                                 !$acc loop seq
                                 do i = 1, 2
                                     Re_L(i) = dflt_real
-
                                     if (Re_size(i) > 0) Re_L(i) = 0d0
-
                                     !$acc loop seq
                                     do q = 1, Re_size(i)
                                         Re_L(i) = alpha_L(Re_idx(i, q))/Res(i, q) &
                                                   + Re_L(i)
                                     end do
-
                                     Re_L(i) = 1d0/max(Re_L(i), sgm_eps)
-
                                 end do
 
                                 !$acc loop seq
                                 do i = 1, 2
                                     Re_R(i) = dflt_real
-
                                     if (Re_size(i) > 0) Re_R(i) = 0d0
-
                                     !$acc loop seq
                                     do q = 1, Re_size(i)
                                         Re_R(i) = alpha_R(Re_idx(i, q))/Res(i, q) &
                                                   + Re_R(i)
                                     end do
-
                                     Re_R(i) = 1d0/max(Re_R(i), sgm_eps)
                                 end do
                             end if
@@ -472,26 +465,17 @@ contains
                             E_L = gamma_L*pres_L + pi_inf_L + 5d-1*rho_L*vel_L_rms + qv_L
                             E_R = gamma_R*pres_R + pi_inf_R + 5d-1*rho_R*vel_R_rms + qv_R
 
-                            H_L = (E_L + pres_L)/rho_L
-                            H_R = (E_R + pres_R)/rho_R
-
+                            ! elastic energy update
                             if (hypoelasticity) then
-                                !$acc loop seq
-                                do i = 1, strxe - strxb + 1
-                                    tau_e_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, strxb - 1 + i)
-                                    tau_e_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, strxb - 1 + i)
-                                end do
-
-                                G_L = 0d0
-                                G_R = 0d0
-
+                                G_L = 0d0; G_R = 0d0
                                 !$acc loop seq
                                 do i = 1, num_fluids
                                     G_L = G_L + alpha_L(i)*Gs(i)
                                     G_R = G_R + alpha_R(i)*Gs(i)
                                 end do
-
                                 do i = 1, strxe - strxb + 1
+                                    tau_e_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, strxb - 1 + i)
+                                    tau_e_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, strxb - 1 + i)
                                     ! Elastic contribution to energy if G large enough
                                     !TODO take out if statement if stable without
                                     if ((G_L > 1000) .and. (G_R > 1000)) then
@@ -506,19 +490,57 @@ contains
                                 end do
                             end if
 
+                            ! elastic energy update
+                            !if ( hyperelasticity ) then
+                            !    G_L = 0d0
+                            !    G_R = 0d0
+                            !
+                            !    !$acc loop seq
+                            !    do i = 1, num_fluids
+                            !        G_L = G_L + alpha_L(i)*Gs(i)
+                            !        G_R = G_R + alpha_R(i)*Gs(i)
+                            !    end do
+                            !    ! Elastic contribution to energy if G large enough
+                            !    if ((G_L > 1d-3) .and. (G_R > 1d-3)) then
+                            !    E_L = E_L + G_L*qL_prim_rs${XYZ}$_vf(j, k, l, xiend + 1)
+                            !    E_R = E_R + G_R*qR_prim_rs${XYZ}$_vf(j + 1, k, l, xiend + 1)
+                            !    !$acc loop seq
+                            !    do i = 1, b_size-1
+                            !        tau_e_L(i) = G_L*qL_prim_rs${XYZ}$_vf(j, k, l, strxb - 1 + i)
+                            !        tau_e_R(i) = G_R*qR_prim_rs${XYZ}$_vf(j + 1, k, l, strxb - 1 + i)
+                            !    end do
+                            !    !$acc loop seq
+                            !    do i = 1, b_size-1
+                            !        tau_e_L(i) = 0d0
+                            !        tau_e_R(i) = 0d0
+                            !    end do
+                            !    !$acc loop seq
+                            !    do i = 1, num_dims
+                            !        xi_field_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, xibeg - 1 + i)
+                            !        xi_field_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, xibeg - 1 + i)
+                            !    end do
+                            !    end if
+                            !end if
+
+                            ! Enthalpy with elastic energy
+                            H_L = (E_L + pres_L)/rho_L
+                            H_R = (E_R + pres_R)/rho_R
+
                             @:compute_average_state()
 
                             call s_compute_speed_of_sound(pres_L, rho_L, gamma_L, pi_inf_L, H_L, alpha_L, &
-                                                          vel_L_rms, c_L)
+                                                          vel_L_rms, c_L, Gs)
 
                             call s_compute_speed_of_sound(pres_R, rho_R, gamma_R, pi_inf_R, H_R, alpha_R, &
-                                                          vel_R_rms, c_R)
+                                                          vel_R_rms, c_R, Gs)
 
                             !> The computation of c_avg does not require all the variables, and therefore the non '_avg'
                             ! variables are placeholders to call the subroutine.
 
                             call s_compute_speed_of_sound(pres_R, rho_avg, gamma_avg, pi_inf_R, H_avg, alpha_R, &
-                                                          vel_avg_rms, c_avg)
+                                                          vel_avg_rms, c_avg, Gs)
+
+                            !SGR added Gs to all of the above speed of sound clacs
 
                             if (any(Re_size > 0)) then
                                 !$acc loop seq
@@ -541,6 +563,11 @@ contains
                                               , vel_L(dir_idx(1)) + sqrt(c_L*c_L + &
                                                                          (((4d0*G_L)/3d0) + &
                                                                           tau_e_L(dir_idx_tau(1)))/rho_L))
+                                else if (hyperelasticity) then
+                                    s_L = min(vel_L(dir_idx(1)) - sqrt(c_L*c_L + (4d0*G_L/3d0)/rho_L) &
+                                              , vel_R(dir_idx(1)) - sqrt(c_R*c_R + (4d0*G_R/3d0)/rho_R))
+                                    s_R = max(vel_R(dir_idx(1)) + sqrt(c_R*c_R + (4d0*G_R/3d0)/rho_R) &
+                                              , vel_L(dir_idx(1)) + sqrt(c_L*c_L + (4d0*G_L/3d0)/rho_L))
                                 else
                                     s_L = min(vel_L(dir_idx(1)) - c_L, vel_R(dir_idx(1)) - c_R)
                                     s_R = max(vel_R(dir_idx(1)) + c_R, vel_L(dir_idx(1)) + c_L)
@@ -716,6 +743,18 @@ contains
                                     /(s_M - s_P)
                             end do
 
+                            ! Xi field
+                            !if ( hyperelasticity ) then
+                            !    do i = 1, num_dims
+                            !      flux_rs${XYZ}$_vf(j, k, l, xibeg - 1 + i) = &
+                            !        (s_M*rho_R*vel_R(dir_idx(1))*xi_field_R(i) &
+                            !         - s_P*rho_L*vel_L(dir_idx(1))*xi_field_L(i) &
+                            !         + s_M*s_P*(rho_L*xi_field_L(i) &
+                            !                    - rho_R*xi_field_R(i))) &
+                            !        /(s_M - s_P)
+                            !    end do
+                            !end if
+
                             ! Div(U)?
                             !$acc loop seq
                             do i = 1, num_dims
@@ -822,7 +861,6 @@ contains
 
         real(kind(0d0)), dimension(startx:, starty:, startz:, 1:), intent(inout) :: qL_prim_rsx_vf, qL_prim_rsy_vf, qL_prim_rsz_vf, qR_prim_rsx_vf, qR_prim_rsy_vf, qR_prim_rsz_vf
         type(scalar_field), dimension(sys_size), intent(in) :: q_prim_vf
-
         type(scalar_field), allocatable, dimension(:), intent(inout) :: qL_prim_vf, qR_prim_vf
 
         type(scalar_field), &
@@ -862,6 +900,11 @@ contains
         real(kind(0d0)) :: s_L, s_R, s_M, s_P, s_S
         real(kind(0d0)) :: xi_L, xi_R !< Left and right wave speeds functions
         real(kind(0d0)) :: xi_M, xi_P
+        real(kind(0d0)) :: xi_MP, xi_PP
+
+        real(kind(0d0)), dimension(6) :: tau_e_L, tau_e_R
+        real(kind(0d0)), dimension(num_dims) :: xi_field_L, xi_field_R
+        real(kind(0d0)) :: G_L, G_R
 
         real(kind(0d0)) :: nbub_L, nbub_R
         real(kind(0d0)), dimension(nb) :: R0_L, R0_R
@@ -880,9 +923,10 @@ contains
         real(kind(0d0)) :: vel_L_rms, vel_R_rms, vel_avg_rms
         real(kind(0d0)) :: vel_L_tmp, vel_R_tmp
         real(kind(0d0)) :: blkmod1, blkmod2
-        real(kind(0d0)) :: rho_Star, E_Star, p_Star, p_K_Star
+        real(kind(0d0)) :: rho_Star, E_Star, p_Star, p_K_Star, vel_K_Star
         real(kind(0d0)) :: pres_SL, pres_SR, Ms_L, Ms_R
         real(kind(0d0)) :: start, finish
+        real(kind(0d0)) :: flux_ene_e
         real(kind(0d0)) :: zcoef, pcorr !< low Mach number correction
         integer :: i, j, k, l, q !< Generic loop iterators
         integer :: idx1, idxi
@@ -909,15 +953,16 @@ contains
             flux_gsrc_vf, &
             norm_dir, ix, iy, iz)
 
+        idx1 = 1; if (dir_idx(1) == 2) idx1 = 2; if (dir_idx(1) == 3) idx1 = 3
+
         #:for NORM_DIR, XYZ in [(1, 'x'), (2, 'y'), (3, 'z')]
 
             if (norm_dir == ${NORM_DIR}$) then
+
+                ! 6-EQUATION MODEL WITH HLLC
                 if (model_eqns == 3) then
                     !ME3
-
-                    !$acc parallel loop collapse(3) gang vector default(present) private(vel_L, vel_R, Re_L, Re_R, &
-                    !$acc rho_avg, h_avg, gamma_avg, s_L, s_R, s_S, vel_avg_rms, alpha_L, alpha_R)
-
+                    !$acc parallel loop collapse(3) gang vector default(present) private(vel_L, vel_R, Re_L, Re_R, rho_avg, h_avg, gamma_avg, s_L, s_R, s_S, vel_avg_rms, alpha_L, alpha_R, tau_e_L, tau_e_R, G_L, G_R, flux_ene_e, xi_field_L, xi_field_R)
                     do l = is3%beg, is3%end
                         do k = is2%beg, is2%end
                             do j = is1%beg, is1%end
@@ -994,39 +1039,85 @@ contains
                                     !$acc loop seq
                                     do i = 1, 2
                                         Re_L(i) = dflt_real
-
                                         if (Re_size(i) > 0) Re_L(i) = 0d0
-
                                         !$acc loop seq
                                         do q = 1, Re_size(i)
                                             Re_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, E_idx + Re_idx(i, q))/Res(i, q) &
                                                       + Re_L(i)
                                         end do
-
                                         Re_L(i) = 1d0/max(Re_L(i), sgm_eps)
-
                                     end do
 
                                     !$acc loop seq
                                     do i = 1, 2
                                         Re_R(i) = dflt_real
-
                                         if (Re_size(i) > 0) Re_R(i) = 0d0
-
                                         !$acc loop seq
                                         do q = 1, Re_size(i)
                                             Re_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, E_idx + Re_idx(i, q))/Res(i, q) &
                                                       + Re_R(i)
                                         end do
-
                                         Re_R(i) = 1d0/max(Re_R(i), sgm_eps)
                                     end do
                                 end if
 
                                 E_L = gamma_L*pres_L + pi_inf_L + 5d-1*rho_L*vel_L_rms + qv_L
-
                                 E_R = gamma_R*pres_R + pi_inf_R + 5d-1*rho_R*vel_R_rms + qv_R
 
+                                ! ENERGY ADJUSTMENTS FOR HYPOELASTIC ENERGY
+                                if (hypoelasticity) then
+                                    !$acc loop seq
+                                    do i = 1, strxe - strxb + 1
+                                        tau_e_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, strxb - 1 + i)
+                                        tau_e_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, strxb - 1 + i)
+                                    end do
+                                    G_L = 0d0; G_R = 0d0
+                                    !$acc loop seq
+                                    do i = 1, num_fluids
+                                        G_L = G_L + alpha_L(i)*Gs(i)
+                                        G_R = G_R + alpha_R(i)*Gs(i)
+                                    end do
+                                    !$acc loop seq
+                                    do i = 1, strxe - strxb + 1
+                                        ! Elastic contribution to energy if G large enough
+                                        if ((G_L > verysmall) .and. (G_R > verysmall)) then
+                                            E_L = E_L + (tau_e_L(i)*tau_e_L(i))/(4d0*G_L)
+                                            E_R = E_R + (tau_e_R(i)*tau_e_R(i))/(4d0*G_R)
+                                            ! Additional terms in 2D and 3D
+                                            if ((i == 2) .or. (i == 4) .or. (i == 5)) then
+                                                E_L = E_L + (tau_e_L(i)*tau_e_L(i))/(4d0*G_L)
+                                                E_R = E_R + (tau_e_R(i)*tau_e_R(i))/(4d0*G_R)
+                                            end if
+                                        end if
+                                    end do
+                                end if
+
+                                ! ENERGY ADJUSTMENTS FOR HYPERELASTIC ENERGY
+                                if (hyperelasticity) then
+                                    !$acc loop seq
+                                    do i = 1, num_dims
+                                      xi_field_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, xibeg - 1 + i)
+                                      xi_field_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, xibeg - 1 + i)
+                                    end do
+                                    G_L = 0d0; G_R = 0d0; 
+                                    !$acc loop seq 
+                                    do i = 1, num_fluids
+                                        ! Mixture left and right shear modulus
+                                        G_L = G_L + alpha_L(i)*Gs(i)
+                                        G_R = G_R + alpha_R(i)*Gs(i)
+                                    end do
+                                    ! Elastic contribution to energy if G large enough
+                                    if ( G_L > verysmall .and. G_R > verysmall ) then
+                                      E_L = E_L + G_L*qL_prim_rs${XYZ}$_vf(j, k, l, xiend + 1)
+                                      E_R = E_R + G_R*qR_prim_rs${XYZ}$_vf(j + 1, k, l, xiend + 1)
+                                    end if
+                                    !$acc loop seq
+                                    do i = 1, b_size - 1
+                                      tau_e_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, strxb - 1 + i)
+                                      tau_e_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, strxb - 1 + i)
+                                    end do
+                                end if
+
                                 H_L = (E_L + pres_L)/rho_L
                                 H_R = (E_R + pres_R)/rho_R
 
@@ -1034,13 +1125,10 @@ contains
 
                                 call s_compute_speed_of_sound(pres_L, rho_L, gamma_L, pi_inf_L, H_L, alpha_L, &
                                                               vel_L_rms, c_L)
-
                                 call s_compute_speed_of_sound(pres_R, rho_R, gamma_R, pi_inf_R, H_R, alpha_R, &
                                                               vel_R_rms, c_R)
-
                                 !> The computation of c_avg does not require all the variables, and therefore the non '_avg'
                                 ! variables are placeholders to call the subroutine.
-
                                 call s_compute_speed_of_sound(pres_R, rho_avg, gamma_avg, pi_inf_R, H_avg, alpha_R, &
                                                               vel_avg_rms, c_avg)
 
@@ -1051,222 +1139,226 @@ contains
                                     end do
                                 end if
 
+                                ! COMPUTING THE DIRECT WAVE SPEEDS
                                 if (wave_speeds == 1) then
-                                    s_L = min(vel_L(dir_idx(1)) - c_L, vel_R(dir_idx(1)) - c_R)
-                                    s_R = max(vel_R(dir_idx(1)) + c_R, vel_L(dir_idx(1)) + c_L)
+                                    if (elasticity) then
+                                        s_L = min(vel_L(dir_idx(1)) - sqrt(c_L*c_L + &
+                                        (((4d0*G_L)/3d0) + tau_e_L(dir_idx_tau(1)))/rho_L), vel_R(dir_idx(1)) - sqrt(c_R*c_R + &
+                                        (((4d0*G_R)/3d0) + tau_e_R(dir_idx_tau(1)))/rho_R))
+                                        s_R = max(vel_R(dir_idx(1)) + sqrt(c_R*c_R + &
+                                        (((4d0*G_R)/3d0) + tau_e_R(dir_idx_tau(1)))/rho_R), vel_L(dir_idx(1)) + sqrt(c_L*c_L + &
+                                        (((4d0*G_L)/3d0) + tau_e_L(dir_idx_tau(1)))/rho_L))
+                                        s_S = (pres_R - tau_e_R(dir_idx_tau(1)) - pres_L + &
+                                               tau_e_L(dir_idx_tau(1)) + rho_L*vel_L(idx1)*(s_L - vel_L(idx1)) - &
+                                               rho_R*vel_R(idx1)*(s_R - vel_R(idx1)))/(rho_L*(s_L - vel_L(idx1)) - &
+                                                                                       rho_R*(s_R - vel_R(idx1)))
+                                    else
+                                        s_L = min(vel_L(dir_idx(1)) - c_L, vel_R(dir_idx(1)) - c_R)
+                                        s_R = max(vel_R(dir_idx(1)) + c_R, vel_L(dir_idx(1)) + c_L)
+                                        s_S = (pres_R - pres_L + rho_L*vel_L(dir_idx(1))* &
+                                               (s_L - vel_L(dir_idx(1))) - rho_R*vel_R(dir_idx(1))*(s_R - vel_R(dir_idx(1)))) &
+                                              /(rho_L*(s_L - vel_L(dir_idx(1))) - rho_R*(s_R - vel_R(dir_idx(1))))
 
-                                    s_S = (pres_R - pres_L + rho_L*vel_L(dir_idx(1))* &
-                                           (s_L - vel_L(dir_idx(1))) - &
-                                           rho_R*vel_R(dir_idx(1))* &
-                                           (s_R - vel_R(dir_idx(1)))) &
-                                          /(rho_L*(s_L - vel_L(dir_idx(1))) - &
-                                            rho_R*(s_R - vel_R(dir_idx(1))))
+                                    end if
                                 elseif (wave_speeds == 2) then
                                     pres_SL = 5d-1*(pres_L + pres_R + rho_avg*c_avg* &
                                                     (vel_L(dir_idx(1)) - &
                                                      vel_R(dir_idx(1))))
-
                                     pres_SR = pres_SL
-
                                     Ms_L = max(1d0, sqrt(1d0 + ((5d-1 + gamma_L)/(1d0 + gamma_L))* &
                                                          (pres_SL/pres_L - 1d0)*pres_L/ &
                                                          ((pres_L + pi_inf_L/(1d0 + gamma_L)))))
                                     Ms_R = max(1d0, sqrt(1d0 + ((5d-1 + gamma_R)/(1d0 + gamma_R))* &
                                                          (pres_SR/pres_R - 1d0)*pres_R/ &
                                                          ((pres_R + pi_inf_R/(1d0 + gamma_R)))))
-
                                     s_L = vel_L(dir_idx(1)) - c_L*Ms_L
                                     s_R = vel_R(dir_idx(1)) + c_R*Ms_R
-
                                     s_S = 5d-1*((vel_L(dir_idx(1)) + vel_R(dir_idx(1))) + &
                                                 (pres_L - pres_R)/ &
                                                 (rho_avg*c_avg))
                                 end if
 
-                                if (s_L >= 0d0) then
-                                    p_Star = pres_L ! Only useful to recalculate the radial momentum geometric source flux
-                                    !$acc loop seq
-                                    do i = 1, num_fluids
-                                        flux_rs${XYZ}$_vf(j, k, l, i + advxb - 1) = &
-                                            qL_prim_rs${XYZ}$_vf(j, k, l, i + advxb - 1)*s_S
+                                ! follows Einfeldt et al.
+                                ! s_M/P = min/max(0.,s_L/R)
+                                s_M = min(0d0, s_L); s_P = max(0d0, s_R)
 
-                                        flux_rs${XYZ}$_vf(j, k, l, i + contxb - 1) = &
-                                            qL_prim_rs${XYZ}$_vf(j, k, l, i + contxb - 1)*vel_L(dir_idx(1))
+                                ! goes with q_star_L/R = xi_L/R * (variable)
+                                ! xi_L/R = ( ( s_L/R - u_L/R )/(s_L/R - s_star) )
+                                xi_L = (s_L - vel_L(idx1))/(s_L - s_S)
+                                xi_R = (s_R - vel_R(idx1))/(s_R - s_S)
 
-                                        flux_rs${XYZ}$_vf(j, k, l, i + intxb - 1) = &
-                                            (qL_prim_rs${XYZ}$_vf(j, k, l, i + advxb - 1)* &
-                                             (gammas(i)*pres_L + pi_infs(i)) + &
-                                             qL_prim_rs${XYZ}$_vf(j, k, l, i + contxb - 1)* &
-                                             qvs(i))*vel_L(dir_idx(1))
-                                    end do
-                                    !$acc loop seq
-                                    do i = 1, num_dims
-                                        flux_rs${XYZ}$_vf(j, k, l, momxb - 1 + dir_idx(i)) = &
-                                            rho_L*vel_L(dir_idx(1))*vel_L(dir_idx(i)) + dir_flg(dir_idx(i))*pres_L
+                                ! goes with numerical star velocity in x/y/z directions
+                                ! xi_P/M = 0.5 +/m sgn(0.5,s_star)
+                                xi_M = (5d-1 + sign(5d-1, s_S))
+                                xi_P = (5d-1 - sign(5d-1, s_S))
 
-                                        vel_src_rs${XYZ}$_vf(j, k, l, dir_idx(i)) = vel_L(dir_idx(i)) + &
-                                                                                    dir_flg(dir_idx(i))*(s_S - vel_L(dir_idx(i)))
-                                        ! Compute the star velocities for the non-conservative terms
-                                    end do
-                                    flux_rs${XYZ}$_vf(j, k, l, E_idx) = (E_L + pres_L)*vel_L(dir_idx(1))
+                                ! goes with the numerical velocity in x/y/z directions
+                                ! xi_P/M (pressure) = min/max(0. sgn(1,sL/sR))
+                                xi_MP = -min(0d0, sign(1d0, s_L))
+                                xi_PP = max(0d0, sign(1d0, s_R))
 
-                                    if (.not. f_is_default(sigma)) then
-                                        flux_rs${XYZ}$_vf(j, k, l, c_idx) = &
-                                            qL_prim_rs${XYZ}$_vf(j, k, l, c_idx)*s_S
-                                    end if
+                                ! COMPUTING FLUXES
+                                ! MASS FLUX.
+                                !$acc loop seq
+                                do i = 1, contxe
+                                    flux_rs${XYZ}$_vf(j, k, l, i) = &
+                                        xi_M*qL_prim_rs${XYZ}$_vf(j, k, l, i)*(vel_L(idx1) + s_M*(xi_L - 1d0)) + &
+                                        xi_P*qR_prim_rs${XYZ}$_vf(j + 1, k, l, i)*(vel_R(idx1) + s_P*(xi_R - 1d0))
+                                end do
 
-                                    ! Compute right solution state
-                                else if (s_R <= 0d0) then
-                                    p_Star = pres_R
-                                    ! Only useful to recalculate the radial momentum geometric source flux
-                                    !$acc loop seq
-                                    do i = 1, num_fluids
-                                        flux_rs${XYZ}$_vf(j, k, l, i + advxb - 1) = &
-                                            qR_prim_rs${XYZ}$_vf(j + 1, k, l, i + advxb - 1)*s_S
+                                ! MOMENTUM FLUX.
+                                ! f = \rho u u - \sigma, q = \rho u, q_star = \xi * \rho*(s_star, v, w)
+                                !$acc loop seq 
+                                do i = 1, num_dims
+                                    !idxi = dir_idx(i)
+                                    flux_rs${XYZ}$_vf(j, k, l, contxe + dir_idx(i)) = &
+                                        xi_M*(rho_L*(vel_L(idx1)*vel_L(dir_idx(i)) + s_M*(xi_L*(dir_flg(dir_idx(i))*s_S + &
+             (1d0 - dir_flg(dir_idx(i)))*vel_L(dir_idx(i))) - vel_L(dir_idx(i)))) + dir_flg(dir_idx(i))*(pres_L)) + &
+                                        xi_P*(rho_R*(vel_R(idx1)*vel_R(dir_idx(i)) + s_P*(xi_R*(dir_flg(dir_idx(i))*s_S + &
+             (1d0 - dir_flg(dir_idx(i)))*vel_R(dir_idx(i))) - vel_R(dir_idx(i)))) + dir_flg(dir_idx(i))*(pres_R))
+                                end do
 
-                                        flux_rs${XYZ}$_vf(j, k, l, i + contxb - 1) = &
-                                            qR_prim_rs${XYZ}$_vf(j + 1, k, l, i + contxb - 1)*vel_R(dir_idx(1))
+                                ! ENERGY FLUX.
+                                ! f = u*(E-\sigma), q = E, q_star = \xi*E+(s-u)(\rho s_star - \sigma/(s-u))
+                                flux_rs${XYZ}$_vf(j, k, l, E_idx) = &
+                                    xi_M*(vel_L(idx1)*(E_L + pres_L) + &
+                                          s_M*(xi_L*(E_L + (s_S - vel_L(idx1))*(rho_L*s_S + pres_L/(s_L - vel_L(idx1)))) - E_L)) &
+                                    + xi_P*(vel_R(idx1)*(E_R + pres_R) + &
+                                            s_P*(xi_R*(E_R + (s_S - vel_R(idx1))*(rho_R*s_S + pres_R/(s_R - vel_R(idx1)))) - E_R))
+
+                                ! ELASTICITY. Elastic shear stress additions for the momentum and energy flux
+                                if (elasticity) then
+                                  flux_ene_e = 0d0;
+                                  !$acc loop seq
+                                  do i = 1, num_dims
+                                    ! MOMENTUM ELASTIC FLUX.
+                                    flux_rs${XYZ}$_vf(j, k, l, contxe + dir_idx(i)) = &
+                                      flux_rs${XYZ}$_vf(j, k, l, contxe + dir_idx(i)) &
+                                      - xi_M*tau_e_L(dir_idx_tau(i)) - xi_P*tau_e_R(dir_idx_tau(i))
+                                    ! ENERGY ELASTIC FLUX.
+                                    flux_ene_e = flux_ene_e - &
+                                      xi_M*(vel_L(dir_idx(i))*tau_e_L(dir_idx_tau(i)) + &
+                                      s_M*(xi_L*((s_S - vel_L(i))*(tau_e_L(dir_idx_tau(i))/(s_L - vel_L(i)))))) - &
+                                      xi_P*(vel_R(dir_idx(i))*tau_e_R(dir_idx_tau(i)) + &
+                                      s_P*(xi_R*((s_S - vel_R(i))*(tau_e_R(dir_idx_tau(i))/(s_R - vel_R(i))))))
+                                  end do
+                                  flux_rs${XYZ}$_vf(j, k, l, E_idx) = flux_rs${XYZ}$_vf(j, k, l, E_idx) + flux_ene_e
+                                end if
 
-                                        flux_rs${XYZ}$_vf(j, k, l, i + intxb - 1) = &
-                                            (qR_prim_rs${XYZ}$_vf(j + 1, k, l, i + advxb - 1)* &
-                                             (gammas(i)*pres_R + pi_infs(i)) + &
-                                             qR_prim_rs${XYZ}$_vf(j + 1, k, l, i + contxb - 1)* &
-                                             qvs(i))*vel_R(dir_idx(1))
-                                    end do
-                                    !$acc loop seq
-                                    do i = 1, num_dims
-                                        flux_rs${XYZ}$_vf(j, k, l, momxb - 1 + dir_idx(i)) = &
-                                            rho_R*vel_R(dir_idx(1))*vel_R(dir_idx(i)) + dir_flg(dir_idx(i))*pres_R
+                                ! VOLUME FRACTION FLUX.
+                                !$acc loop seq
+                                do i = advxb, advxe
+                                    flux_rs${XYZ}$_vf(j, k, l, i) = &
+                                        xi_M*qL_prim_rs${XYZ}$_vf(j, k, l, i)*s_S + &
+                                        xi_P*qR_prim_rs${XYZ}$_vf(j + 1, k, l, i)*s_S
+                                end do
 
-                                        vel_src_rs${XYZ}$_vf(j, k, l, dir_idx(i)) = vel_R(dir_idx(i)) + &
-                                                                                    dir_flg(dir_idx(i))*(s_S - vel_R(dir_idx(i)))
-                                        ! Compute the star velocities for the non-conservative terms
-                                    end do
-                                    flux_rs${XYZ}$_vf(j, k, l, E_idx) = (E_R + pres_R)*vel_R(dir_idx(1))
+                                ! SOURCE TERM FOR VOLUME FRACTION ADVECTION FLUX.
+                                !$acc loop seq 
+                                do i = 1, num_dims
+                                    !idxi = dir_idx(i)
+                                    vel_src_rs${XYZ}$_vf(j, k, l, dir_idx(i)) = &
+                              xi_M*(vel_L(dir_idx(i)) + dir_flg(dir_idx(i))*(s_S*(xi_MP*(xi_L - 1) + 1) - vel_L(dir_idx(i)))) + &
+                              xi_P*(vel_R(dir_idx(i)) + dir_flg(dir_idx(i))*(s_S*(xi_PP*(xi_R - 1) + 1) - vel_R(dir_idx(i))))
+                                end do
 
-                                    if (.not. f_is_default(sigma)) then
-                                        flux_rs${XYZ}$_vf(j, k, l, c_idx) = &
-                                            qR_prim_rs${XYZ}$_vf(j + 1, k, l, c_idx)*s_S
-                                    end if
+                                ! INTERNAL ENERGIES ADVECTION FLUX.
+                                ! K-th pressure and velocity in preparation for the internal energy flux
+                                vel_K_Star = vel_L(idx1)*(1d0 - xi_MP) + xi_MP*vel_R(idx1) + &
+                                             xi_MP*xi_PP*(s_S - vel_R(idx1))
+                                !$acc loop seq
+                                do i = 1, num_fluids
+                                    p_K_Star = xi_M*(xi_MP*((pres_L + pi_infs(i)/(1d0 + gammas(i)))* &
+                                                            xi_L**(1d0/gammas(i) + 1d0) - pi_infs(i)/(1d0 + gammas(i)) - pres_L) + pres_L) + &
+                                               xi_P*(xi_PP*((pres_R + pi_infs(i)/(1d0 + gammas(i)))* &
+                                                            xi_R**(1d0/gammas(i) + 1d0) - pi_infs(i)/(1d0 + gammas(i)) - pres_R) + pres_R)
+
+                                    flux_rs${XYZ}$_vf(j, k, l, i + intxb - 1) = &
+                                        (qL_prim_rs${XYZ}$_vf(j, k, l, i + advxb - 1)* &
+                                         (gammas(i)*p_K_Star + pi_infs(i)) + &
+                                         qL_prim_rs${XYZ}$_vf(j, k, l, i + contxb - 1)* &
+                                         qvs(i))*vel_K_Star
+                                end do
 
-                                    ! Compute left star solution state
-                                else if (s_S >= 0d0) then
-                                    xi_L = (s_L - vel_L(dir_idx(1)))/(s_L - s_S)
-                                    rho_Star = rho_L*xi_L
-                                    E_Star = xi_L*(E_L + (s_S - vel_L(dir_idx(1)))* &
-                                                   (rho_L*s_S + pres_L/(s_L - vel_L(dir_idx(1)))))
-                                    p_Star = rho_L*(s_L - vel_L(dir_idx(1)))*(s_S - vel_L(dir_idx(1))) + pres_L
-                                    !$acc loop seq
-                                    do i = 1, num_fluids
-                                        p_K_Star = (pres_L + pi_infs(i)/(1d0 + gammas(i)))* &
-                                                   xi_L**(1d0/gammas(i) + 1d0) - pi_infs(i)/(1d0 + gammas(i))
+                                flux_src_rs${XYZ}$_vf(j, k, l, advxb) = vel_src_rs${XYZ}$_vf(j, k, l, idx1)
 
-                                        flux_rs${XYZ}$_vf(j, k, l, i + advxb - 1) = &
-                                            qL_prim_rs${XYZ}$_vf(j, k, l, i + advxb - 1)*s_S
+                                ! HYPOELASTIC STRESS EVOLUTION FLUX.
+                                if (hypoelasticity) then
+                                  !$acc loop seq
+                                  do i = 1, strxe - strxb + 1
+                                    flux_rs${XYZ}$_vf(j, k, l, strxb - 1 + i) = &
+                                      xi_M*(s_S/(s_L - s_S))*(s_L*rho_L*tau_e_L(i) - rho_L*vel_L(idx1)*tau_e_L(i)) + &
+                                      xi_P*(s_S/(s_R - s_S))*(s_R*rho_R*tau_e_R(i) - rho_R*vel_R(idx1)*tau_e_R(i))
+                                  end do
+                                end if
 
-                                        flux_rs${XYZ}$_vf(j, k, l, i + contxb - 1) = &
-                                            qL_prim_rs${XYZ}$_vf(j, k, l, i + contxb - 1)*xi_L*s_S
+                                ! REFERENCE MAP FLUX.
+                                if (hyperelasticity) then
+                                  !$acc loop seq
+                                  do i = 1, num_dims
+                                    flux_rs${XYZ}$_vf(j, k, l, xibeg - 1 + i) = &
+                                      xi_M*(s_S/(s_L - s_S))*(s_L*rho_L*xi_field_L(i) & 
+                                         - rho_L*vel_L(idx1)*xi_field_L(i)) + &
+                                      xi_P*(s_S/(s_R - s_S))*(s_R*rho_R*xi_field_R(i) & 
+                                         - rho_R*vel_R(idx1)*xi_field_R(i))
+                                  end do
+                                end if
 
-                                        flux_rs${XYZ}$_vf(j, k, l, i + intxb - 1) = &
-                                            (qL_prim_rs${XYZ}$_vf(j, k, l, i + advxb - 1)* &
-                                             (gammas(i)*p_K_Star + pi_infs(i)) + &
-                                             qL_prim_rs${XYZ}$_vf(j, k, l, i + contxb - 1)* &
-                                             qvs(i))*s_S
-                                    end do
-                                    !$acc loop seq
-                                    do i = 1, num_dims
-                                        flux_rs${XYZ}$_vf(j, k, l, momxb - 1 + dir_idx(i)) = &
-                                            rho_Star*s_S*(s_S*dir_flg(dir_idx(i)) + vel_L(dir_idx(i))* &
-                                                          (1d0 - dir_flg(dir_idx(i)))) + dir_flg(dir_idx(i))*p_Star
+                                ! SURFACE TENSION FLUX. need to check
+                                if (.not. f_is_default(sigma)) then
+                                    flux_rs${XYZ}$_vf(j, k, l, c_idx) = &
+                                        (xi_M*qL_prim_rs${XYZ}$_vf(j, k, l, c_idx) + &
+                                         xi_P*qR_prim_rs${XYZ}$_vf(j + 1, k, l, c_idx))*s_S
+                                end if
 
-                                        vel_src_rs${XYZ}$_vf(j, k, l, dir_idx(i)) = vel_L(dir_idx(i)) + &
-                                                                                    dir_flg(dir_idx(i))*(s_S*xi_L - vel_L(dir_idx(i)))
-                                        ! Compute the star velocities for the non-conservative terms
-                                    end do
-                                    flux_rs${XYZ}$_vf(j, k, l, E_idx) = (E_Star + p_Star)*s_S
+                                ! correction pressure for the cylindrical terms
+                                p_Star = xi_M*(pres_L + xi_MP*rho_L*(s_L - &
+                                  vel_L(dir_idx(1)))*(s_S - vel_L(dir_idx(1)))) + &
+                                  xi_P*(pres_R + xi_PP*rho_R*(s_R - &
+                                  vel_R(dir_idx(1)))*(s_S - vel_R(dir_idx(1))))
 
-                                    if (.not. f_is_default(sigma)) then
-                                        flux_rs${XYZ}$_vf(j, k, l, c_idx) = &
-                                            qL_prim_rs${XYZ}$_vf(j, k, l, c_idx)*s_S
+                                ! Geometrical source flux for cylindrical coordinates
+                                #:if (NORM_DIR == 2)
+                                    if (cyl_coord) then
+                                        !Substituting the advective flux into the inviscid geometrical source flux
+                                        !$acc loop seq
+                                        do i = 1, E_idx
+                                            flux_gsrc_rs${XYZ}$_vf(j, k, l, i) = flux_rs${XYZ}$_vf(j, k, l, i)
+                                        end do
+                                        !$acc loop seq
+                                        do i = intxb, intxe
+                                            flux_gsrc_rs${XYZ}$_vf(j, k, l, i) = flux_rs${XYZ}$_vf(j, k, l, i)
+                                        end do
+                                        ! Recalculating the radial momentum geometric source flux
+                                        flux_gsrc_rs${XYZ}$_vf(j, k, l, momxb - 1 + dir_idx(1)) = &
+                                            flux_gsrc_rs${XYZ}$_vf(j, k, l, momxb - 1 + dir_idx(1)) - p_Star
+                                        ! Geometrical source of the void fraction(s) is zero
+                                        !$acc loop seq
+                                        do i = advxb, advxe
+                                            flux_gsrc_rs${XYZ}$_vf(j, k, l, i) = 0d0
+                                        end do
                                     end if
+                                #:endif
+                                #:if (NORM_DIR == 3)
+                                    if (grid_geometry == 3) then
+                                        !$acc loop seq
+                                        do i = 1, sys_size
+                                            flux_gsrc_rs${XYZ}$_vf(j, k, l, i) = 0d0
+                                        end do
+                                        flux_gsrc_rs${XYZ}$_vf(j, k, l, momxb - 1 + dir_idx(1)) = &
+                                            flux_gsrc_rs${XYZ}$_vf(j, k, l, momxb - 1 + dir_idx(1)) - p_Star
 
-                                    ! Compute right star solution state
-                                else
-                                    xi_R = (s_R - vel_R(dir_idx(1)))/(s_R - s_S)
-
-                                    rho_Star = rho_R*xi_R
-
-                                    E_Star = xi_R*(E_R + (s_S - vel_R(dir_idx(1)))* &
-                                                   (rho_R*s_S + pres_R/(s_R - vel_R(dir_idx(1)))))
-
-                                    p_Star = rho_R*(s_R - vel_R(dir_idx(1)))*(s_S - vel_R(dir_idx(1))) + pres_R
-                                    !$acc loop seq
-                                    do i = 1, num_fluids
-                                        p_K_Star = (pres_R + pi_infs(i)/(1d0 + gammas(i)))* &
-                                                   xi_R**(1d0/gammas(i) + 1d0) - pi_infs(i)/(1d0 + gammas(i))
-
-                                        flux_rs${XYZ}$_vf(j, k, l, i + advxb - 1) = &
-                                            qR_prim_rs${XYZ}$_vf(j + 1, k, l, i + advxb - 1)*s_S
-
-                                        flux_rs${XYZ}$_vf(j, k, l, i + contxb - 1) = &
-                                            qR_prim_rs${XYZ}$_vf(j + 1, k, l, i + contxb - 1)*xi_R*s_S
-
-                                        flux_rs${XYZ}$_vf(j, k, l, i + intxb - 1) = &
-                                            (qR_prim_rs${XYZ}$_vf(j + 1, k, l, i + advxb - 1)* &
-                                             (gammas(i)*p_K_Star + pi_infs(i)) + &
-                                             qR_prim_rs${XYZ}$_vf(j + 1, k, l, i + contxb - 1)* &
-                                             qvs(i))*s_S
-                                    end do
-                                    !$acc loop seq
-                                    do i = 1, num_dims
-                                        flux_rs${XYZ}$_vf(j, k, l, momxb - 1 + dir_idx(i)) = rho_Star*s_S* &
-                                                                                             (s_S*dir_flg(dir_idx(i)) + vel_R(dir_idx(i))*(1d0 - dir_flg(dir_idx(i)))) + &
-                                                                                             dir_flg(dir_idx(i))*p_Star
-
-                                        vel_src_rs${XYZ}$_vf(j, k, l, dir_idx(i)) = vel_R(dir_idx(i)) + &
-                                                                                    dir_flg(dir_idx(i))*(s_S*xi_R - vel_R(dir_idx(i)))
-                                        ! Compute the star velocities for the non-conservative terms
-                                    end do
-
-                                    if (.not. f_is_default(sigma)) then
-                                        flux_rs${XYZ}$_vf(j, k, l, c_idx) = &
-                                            qR_prim_rs${XYZ}$_vf(j + 1, k, l, c_idx)*s_S
+                                        flux_gsrc_rs${XYZ}$_vf(j, k, l, momxe) = flux_rs${XYZ}$_vf(j, k, l, momxb + 1)
                                     end if
-
-                                    flux_rs${XYZ}$_vf(j, k, l, E_idx) = (E_Star + p_Star)*s_S
-
-                                end if
-
-                                flux_src_rs${XYZ}$_vf(j, k, l, advxb) = vel_src_rs${XYZ}$_vf(j, k, l, dir_idx(1))
-
-                                ! Geometrical source flux for cylindrical coordinates
-                                if (cyl_coord .and. norm_dir == 2) then
-                                    ! Substituting the advective flux into the inviscid geometrical source flux
-                                    !$acc loop seq
-                                    do i = 1, E_idx
-                                        flux_gsrc_rs${XYZ}$_vf(j, k, l, i) = flux_rs${XYZ}$_vf(j, k, l, i)
-                                    end do
-                                    !$acc loop seq
-                                    do i = intxb, intxe
-                                        flux_gsrc_rs${XYZ}$_vf(j, k, l, i) = flux_rs${XYZ}$_vf(j, k, l, i)
-                                    end do
-                                    ! Recalculating the radial momentum geometric source flux (subtracting the pressure part)
-                                    flux_gsrc_rs${XYZ}$_vf(j, k, l, momxb - 1 + dir_idx(1)) = &
-                                        flux_gsrc_rs${XYZ}$_vf(j, k, l, momxb - 1 + dir_idx(1)) - p_Star
-                                    ! Geometrical source of the void fraction(s) is zero
-                                    !$acc loop seq
-                                    do i = advxb, advxe
-                                        flux_gsrc_rs${XYZ}$_vf(j, k, l, i) = 0d0
-                                    end do
-                                end if
+                                #:endif
 
                             end do
                         end do
                     end do
+
                 elseif (model_eqns == 4) then
                     !ME4
-                    !$acc parallel loop collapse(3) gang vector default(present) private(alpha_rho_L, alpha_rho_R, vel_L, vel_R, alpha_L, alpha_R, vel_avg, &
-                    !$acc rho_avg, h_avg, gamma_avg, s_L, s_R, s_S, vel_avg_rms, nbub_L, nbub_R, ptilde_L, ptilde_R)
+                    !$acc parallel loop collapse(3) gang vector default(present) private(alpha_rho_L, alpha_rho_R, vel_L, vel_R, alpha_L, alpha_R, vel_avg, rho_avg, h_avg, gamma_avg, s_L, s_R, s_S, vel_avg_rms, nbub_L, nbub_R, ptilde_L, ptilde_R)
                     do l = is3%beg, is3%end
                         do k = is2%beg, is2%end
                             do j = is1%beg, is1%end
@@ -1632,11 +1724,11 @@ contains
                                 end if
 
                                 E_L = gamma_L*pres_L + pi_inf_L + 5d-1*rho_L*vel_L_rms
-
                                 E_R = gamma_R*pres_R + pi_inf_R + 5d-1*rho_R*vel_R_rms
 
                                 H_L = (E_L + pres_L)/rho_L
                                 H_R = (E_R + pres_R)/rho_R
+
                                 if (avg_state == 2) then
                                     !$acc loop seq
                                     do i = 1, nb
@@ -1749,13 +1841,11 @@ contains
 
                                 call s_compute_speed_of_sound(pres_L, rho_L, gamma_L, pi_inf_L, H_L, alpha_L, &
                                                               vel_L_rms, c_L)
-
                                 call s_compute_speed_of_sound(pres_R, rho_R, gamma_R, pi_inf_R, H_R, alpha_R, &
                                                               vel_R_rms, c_R)
 
                                 !> The computation of c_avg does not require all the variables, and therefore the non '_avg'
                                 ! variables are placeholders to call the subroutine.
-
                                 call s_compute_speed_of_sound(pres_R, rho_avg, gamma_avg, pi_inf_R, H_avg, alpha_R, &
                                                               vel_avg_rms, c_avg)
 
@@ -1861,7 +1951,6 @@ contains
 
                                 ! Energy flux.
                                 ! f = u*(E+p), q = E, q_star = \xi*E+(s-u)(\rho s_star + p/(s-u))
-
                                 flux_rs${XYZ}$_vf(j, k, l, E_idx) = &
                                     xi_M*(vel_L(dir_idx(1))*(E_L + pres_L - ptilde_L) + &
                                           s_M*(xi_L*(E_L + (s_S - vel_L(dir_idx(1)))* &
@@ -1874,7 +1963,6 @@ contains
                                     + (s_M/s_L)*(s_P/s_R)*pcorr*s_S
 
                                 ! Volume fraction flux
-
                                 !$acc loop seq
                                 do i = advxb, advxe
                                     flux_rs${XYZ}$_vf(j, k, l, i) = &
@@ -1980,8 +2068,10 @@ contains
                     end do
                     !$acc end parallel loop
                 else
+                    ! 5-EQUATION MODEL WITH HLLC, INTERFACE CAPTURING ONLY
                     !$acc parallel loop collapse(3) gang vector default(present) private(vel_L, vel_R, Re_L, Re_R, &
-                    !$acc rho_avg, h_avg, gamma_avg, alpha_L, alpha_R, s_L, s_R, s_S, vel_avg_rms, pcorr, zcoef, vel_L_tmp, vel_R_tmp) copyin(is1,is2,is3)
+                    !$acc rho_avg, h_avg, gamma_avg, alpha_L, alpha_R, s_L, s_R, s_S, vel_avg_rms, pcorr, zcoef, &
+                    !$acc tau_e_L, tau_e_R, xi_field_L, xi_field_R, vel_L_tmp, vel_R_tmp) copyin(is1,is2,is3)
                     do l = is3%beg, is3%end
                         do k = is2%beg, is2%end
                             do j = is1%beg, is1%end
@@ -2064,39 +2154,85 @@ contains
                                     !$acc loop seq
                                     do i = 1, 2
                                         Re_L(i) = dflt_real
-
                                         if (Re_size(i) > 0) Re_L(i) = 0d0
-
                                         !$acc loop seq
                                         do q = 1, Re_size(i)
                                             Re_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, E_idx + Re_idx(i, q))/Res(i, q) &
                                                       + Re_L(i)
                                         end do
-
                                         Re_L(i) = 1d0/max(Re_L(i), sgm_eps)
-
                                     end do
 
                                     !$acc loop seq
                                     do i = 1, 2
                                         Re_R(i) = dflt_real
-
                                         if (Re_size(i) > 0) Re_R(i) = 0d0
-
                                         !$acc loop seq
                                         do q = 1, Re_size(i)
                                             Re_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, E_idx + Re_idx(i, q))/Res(i, q) &
                                                       + Re_R(i)
                                         end do
-
                                         Re_R(i) = 1d0/max(Re_R(i), sgm_eps)
                                     end do
                                 end if
 
                                 E_L = gamma_L*pres_L + pi_inf_L + 5d-1*rho_L*vel_L_rms + qv_L
-
                                 E_R = gamma_R*pres_R + pi_inf_R + 5d-1*rho_R*vel_R_rms + qv_R
 
+                                ! ENERGY ADJUSTMENTS FOR HYPOELASTIC ENERGY
+                                if (hypoelasticity) then
+                                    !$acc loop seq
+                                    do i = 1, strxe - strxb + 1
+                                        tau_e_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, strxb - 1 + i)
+                                        tau_e_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, strxb - 1 + i)
+                                    end do
+                                    G_L = 0d0; G_R = 0d0
+                                    !$acc loop seq
+                                    do i = 1, num_fluids
+                                        G_L = G_L + alpha_L(i)*Gs(i)
+                                        G_R = G_R + alpha_R(i)*Gs(i)
+                                    end do
+                                    !$acc loop seq
+                                    do i = 1, strxe - strxb + 1
+                                        ! Elastic contribution to energy if G large enough
+                                        if ((G_L > verysmall) .and. (G_R > verysmall)) then
+                                            E_L = E_L + (tau_e_L(i)*tau_e_L(i))/(4d0*G_L)
+                                            E_R = E_R + (tau_e_R(i)*tau_e_R(i))/(4d0*G_R)
+                                            ! Additional terms in 2D and 3D
+                                            if ((i == 2) .or. (i == 4) .or. (i == 5)) then
+                                                E_L = E_L + (tau_e_L(i)*tau_e_L(i))/(4d0*G_L)
+                                                E_R = E_R + (tau_e_R(i)*tau_e_R(i))/(4d0*G_R)
+                                            end if
+                                        end if
+                                    end do
+                                end if
+
+                                ! ENERGY ADJUSTMENTS FOR HYPERELASTIC ENERGY
+                                if (hyperelasticity) then
+                                    !$acc loop seq
+                                    do i = 1, num_dims
+                                      xi_field_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, xibeg - 1 + i)
+                                      xi_field_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, xibeg - 1 + i)
+                                    end do
+                                    G_L = 0d0; G_R = 0d0; 
+                                    !$acc loop seq 
+                                    do i = 1, num_fluids
+                                        ! Mixture left and right shear modulus
+                                        G_L = G_L + alpha_L(i)*Gs(i)
+                                        G_R = G_R + alpha_R(i)*Gs(i)
+                                    end do
+                                    ! Elastic contribution to energy if G large enough
+                                    if ( G_L > verysmall .and. G_R > verysmall ) then
+                                      E_L = E_L + G_L*qL_prim_rs${XYZ}$_vf(j, k, l, xiend + 1)
+                                      E_R = E_R + G_R*qR_prim_rs${XYZ}$_vf(j + 1, k, l, xiend + 1)
+                                    end if
+                                    !$acc loop seq
+                                    do i = 1, b_size - 1
+                                      tau_e_L(i) = qL_prim_rs${XYZ}$_vf(j, k, l, strxb - 1 + i)
+                                      tau_e_R(i) = qR_prim_rs${XYZ}$_vf(j + 1, k, l, strxb - 1 + i)
+                                    end do
+                                end if
+
                                 H_L = (E_L + pres_L)/rho_L
                                 H_R = (E_R + pres_R)/rho_R
 
@@ -2110,7 +2246,6 @@ contains
 
                                 !> The computation of c_avg does not require all the variables, and therefore the non '_avg'
                                 ! variables are placeholders to call the subroutine.
-
                                 call s_compute_speed_of_sound(pres_R, rho_avg, gamma_avg, pi_inf_R, H_avg, alpha_R, &
                                                               vel_avg_rms, c_avg)
 
@@ -2126,16 +2261,25 @@ contains
                                 end if
 
                                 if (wave_speeds == 1) then
-                                    s_L = min(vel_L(idx1) - c_L, vel_R(idx1) - c_R)
-                                    s_R = max(vel_R(idx1) + c_R, vel_L(idx1) + c_L)
-
-                                    s_S = (pres_R - pres_L + rho_L*vel_L(idx1)* &
-                                           (s_L - vel_L(idx1)) - &
-                                           rho_R*vel_R(idx1)* &
-                                           (s_R - vel_R(idx1))) &
-                                          /(rho_L*(s_L - vel_L(idx1)) - &
-                                            rho_R*(s_R - vel_R(idx1)))
+                                    if (elasticity) then
+                                        s_L = min(vel_L(dir_idx(1)) - sqrt(c_L*c_L + &
+                                        (((4d0*G_L)/3d0) + tau_e_L(dir_idx_tau(1)))/rho_L), vel_R(dir_idx(1)) - sqrt(c_R*c_R + &
+                                        (((4d0*G_R)/3d0) + tau_e_R(dir_idx_tau(1)))/rho_R))
+                                        s_R = max(vel_R(dir_idx(1)) + sqrt(c_R*c_R + &
+                                        (((4d0*G_R)/3d0) + tau_e_R(dir_idx_tau(1)))/rho_R), vel_L(dir_idx(1)) + sqrt(c_L*c_L + &
+                                        (((4d0*G_L)/3d0) + tau_e_L(dir_idx_tau(1)))/rho_L))
+                                        s_S = (pres_R - tau_e_R(dir_idx_tau(1)) - pres_L + &
+                                               tau_e_L(dir_idx_tau(1)) + rho_L*vel_L(idx1)*(s_L - vel_L(idx1)) - &
+                                               rho_R*vel_R(idx1)*(s_R - vel_R(idx1)))/(rho_L*(s_L - vel_L(idx1)) - &
+                                                                                       rho_R*(s_R - vel_R(idx1)))
+                                    else
+                                        s_L = min(vel_L(dir_idx(1)) - c_L, vel_R(dir_idx(1)) - c_R)
+                                        s_R = max(vel_R(dir_idx(1)) + c_R, vel_L(dir_idx(1)) + c_L)
+                                        s_S = (pres_R - pres_L + rho_L*vel_L(dir_idx(1))* &
+                                               (s_L - vel_L(dir_idx(1))) - rho_R*vel_R(dir_idx(1))*(s_R - vel_R(dir_idx(1)))) &
+                                              /(rho_L*(s_L - vel_L(dir_idx(1))) - rho_R*(s_R - vel_R(dir_idx(1))))
 
+                                    end if
                                 elseif (wave_speeds == 2) then
                                     pres_SL = 5d-1*(pres_L + pres_R + rho_avg*c_avg* &
                                                     (vel_L(idx1) - &
@@ -2172,6 +2316,8 @@ contains
                                 xi_M = (5d-1 + sign(5d-1, s_S))
                                 xi_P = (5d-1 - sign(5d-1, s_S))
 
+                                ! COMPUTING THE HLLC FLUXES
+                                ! MASS FLUX.
                                 if (low_Mach == 1) then
                                     @:compute_low_Mach_correction()
                                 else
@@ -2181,15 +2327,13 @@ contains
                                 !$acc loop seq
                                 do i = 1, contxe
                                     flux_rs${XYZ}$_vf(j, k, l, i) = &
-                                        xi_M*qL_prim_rs${XYZ}$_vf(j, k, l, i) &
-                                        *(vel_L(idx1) + s_M*(xi_L - 1d0)) &
-                                        + xi_P*qR_prim_rs${XYZ}$_vf(j + 1, k, l, i) &
-                                        *(vel_R(idx1) + s_P*(xi_R - 1d0))
+                                        xi_M*qL_prim_rs${XYZ}$_vf(j, k, l, i)*(vel_L(idx1) + s_M*(xi_L - 1d0)) + &
+                                        xi_P*qR_prim_rs${XYZ}$_vf(j + 1, k, l, i)*(vel_R(idx1) + s_P*(xi_R - 1d0))
                                 end do
 
-                                ! Momentum flux.
-                                ! f = \rho u u + p I, q = \rho u, q_star = \xi * \rho*(s_star, v, w)
-                                !$acc loop seq
+                                ! MOMENTUM FLUX.
+                                ! f = \rho u u - \sigma, q = \rho u, q_star = \xi * \rho*(s_star, v, w)
+                                !$acc loop seq 
                                 do i = 1, num_dims
                                     idxi = dir_idx(i)
                                     flux_rs${XYZ}$_vf(j, k, l, contxe + idxi) = &
@@ -2206,32 +2350,68 @@ contains
                                                                   vel_R(idxi)) - vel_R(idxi))) + &
                                                 dir_flg(idxi)*(pres_R)) &
                                         + (s_M/s_L)*(s_P/s_R)*dir_flg(idxi)*pcorr
+
+                                    !idxi = dir_idx(i)
+                                    !flux_rs${XYZ}$_vf(j, k, l, contxe + dir_idx(i)) = &
+                                    !    xi_M*(rho_L*(vel_L(idx1)*vel_L(dir_idx(i)) + s_M*(xi_L*(dir_flg(dir_idx(i))*s_S + &
+             !(1d0 - dir_flg(dir_idx(i)))*vel_L(dir_idx(i))) - vel_L(dir_idx(i)))) + dir_flg(dir_idx(i))*(pres_L)) + &
+             !                           xi_P*(rho_R*(vel_R(idx1)*vel_R(dir_idx(i)) + s_P*(xi_R*(dir_flg(dir_idx(i))*s_S + &
+             !(1d0 - dir_flg(dir_idx(i)))*vel_R(dir_idx(i))) - vel_R(dir_idx(i)))) + dir_flg(dir_idx(i))*(pres_R)) &
+             !                           + (s_M/s_L)*(s_P/s_R)*dir_flg(dir_idx(i))*pcorr
                                 end do
 
-                                ! Energy flux.
-                                ! f = u*(E+p), q = E, q_star = \xi*E+(s-u)(\rho s_star + p/(s-u))
+                                ! ENERGY FLUX.
+                                ! f = u*(E-\sigma), q = E, q_star = \xi*E+(s-u)(\rho s_star - \sigma/(s-u))
                                 flux_rs${XYZ}$_vf(j, k, l, E_idx) = &
                                     xi_M*(vel_L(idx1)*(E_L + pres_L) + &
-                                          s_M*(xi_L*(E_L + (s_S - vel_L(idx1))* &
-                                                     (rho_L*s_S + pres_L/ &
-                                                      (s_L - vel_L(idx1)))) - E_L)) &
+                                          s_M*(xi_L*(E_L + (s_S - vel_L(idx1))*(rho_L*s_S + pres_L/(s_L - vel_L(idx1)))) - E_L)) &
                                     + xi_P*(vel_R(idx1)*(E_R + pres_R) + &
-                                            s_P*(xi_R*(E_R + (s_S - vel_R(idx1))* &
-                                                       (rho_R*s_S + pres_R/ &
-                                                        (s_R - vel_R(idx1)))) - E_R)) &
+                                            s_P*(xi_R*(E_R + (s_S - vel_R(idx1))*(rho_R*s_S + pres_R/(s_R - vel_R(idx1)))) - E_R)) & 
                                     + (s_M/s_L)*(s_P/s_R)*pcorr*s_S
 
-                                ! Volume fraction flux
+                                ! ELASTICITY. Elastic shear stress additions for the momentum and energy flux
+                                if (elasticity) then
+                                  flux_ene_e = 0d0;
+                                  !$acc loop seq
+                                  do i = 1, num_dims
+                                    ! MOMENTUM ELASTIC FLUX.
+                                    flux_rs${XYZ}$_vf(j, k, l, contxe + dir_idx(i)) = &
+                                      flux_rs${XYZ}$_vf(j, k, l, contxe + dir_idx(i)) &
+                                      - xi_M*tau_e_L(dir_idx_tau(i)) - xi_P*tau_e_R(dir_idx_tau(i))
+                                    ! ENERGY ELASTIC FLUX.
+                                    flux_ene_e = flux_ene_e - &
+                                      xi_M*(vel_L(dir_idx(i))*tau_e_L(dir_idx_tau(i)) + &
+                                      s_M*(xi_L*((s_S - vel_L(i))*(tau_e_L(dir_idx_tau(i))/(s_L - vel_L(i)))))) - &
+                                      xi_P*(vel_R(dir_idx(i))*tau_e_R(dir_idx_tau(i)) + &
+                                      s_P*(xi_R*((s_S - vel_R(i))*(tau_e_R(dir_idx_tau(i))/(s_R - vel_R(i))))))
+                                  end do
+                                  flux_rs${XYZ}$_vf(j, k, l, E_idx) = flux_rs${XYZ}$_vf(j, k, l, E_idx) + flux_ene_e
+                                end if
+
+                                ! HYPOELASTIC STRESS EVOLUTION FLUX.
+                                if (hypoelasticity) then
+                                    !$acc loop seq
+                                    do i = 1, strxe - strxb + 1
+                                      flux_rs${XYZ}$_vf(j, k, l, strxb - 1 + i) = &
+                                        xi_M*(s_S/(s_L - s_S))*(s_L*rho_L*tau_e_L(i) - rho_L*vel_L(idx1)*tau_e_L(i)) + &
+                                        xi_P*(s_S/(s_R - s_S))*(s_R*rho_R*tau_e_R(i) - rho_R*vel_R(idx1)*tau_e_R(i))
+                                    end do
+                                end if
+
+                                ! VOLUME FRACTION FLUX.
                                 !$acc loop seq
                                 do i = advxb, advxe
-                                    flux_rs${XYZ}$_vf(j, k, l, i) = &
-                                        xi_M*qL_prim_rs${XYZ}$_vf(j, k, l, i) &
-                                        *(vel_L(idx1) + s_M*(xi_L - 1d0)) &
-                                        + xi_P*qR_prim_rs${XYZ}$_vf(j + 1, k, l, i) &
-                                        *(vel_R(idx1) + s_P*(xi_R - 1d0))
+                                   flux_rs${XYZ}$_vf(j, k, l, i) = &
+                                     xi_M*qL_prim_rs${XYZ}$_vf(j, k, l, i) &
+                                     *(vel_L(idx1) + s_M*(xi_L - 1d0)) &
+                                     + xi_P*qR_prim_rs${XYZ}$_vf(j + 1, k, l, i) &
+                                     *(vel_R(idx1) + s_P*(xi_R - 1d0))
+                                  !flux_rs${XYZ}$_vf(j, k, l, i) = &
+                                  !  xi_M*qL_prim_rs${XYZ}$_vf(j, k, l, i)*(vel_L(idx1) + s_M*(xi_L - 1d0)) + &
+                                  !  xi_P*qR_prim_rs${XYZ}$_vf(j + 1, k, l, i)*(vel_R(idx1) + s_P*(xi_R - 1d0))
                                 end do
 
-                                ! Source for volume fraction advection equation
+                                ! VOLUME FRACTION SOURCE FLUX.
                                 !$acc loop seq
                                 do i = 1, num_dims
                                     idxi = dir_idx(i)
@@ -2242,14 +2422,20 @@ contains
                                         + xi_P*(vel_R(idxi) + &
                                                 dir_flg(idxi)* &
                                                 s_P*(xi_R - 1d0))
-
-                                    !if ( (model_eqns == 4) .or. (num_fluids==1) ) vel_src_rs_vf(dir_idx(i))%sf(j,k,l) = 0d0
+                                        !xi_M*(vel_L(idxi) + dir_flg(idxi)*s_M*(xi_L - 1d0)) + &
+                                        !xi_P*(vel_R(idxi) + dir_flg(idxi)*s_P*(xi_R - 1d0))
                                 end do
 
                                 flux_src_rs${XYZ}$_vf(j, k, l, advxb) = vel_src_rs${XYZ}$_vf(j, k, l, idx1)
 
-                                ! Geometrical source flux for cylindrical coordinates
+                                ! SURFACE TENSION FLUX. need to check
+                                !if (.not. f_is_default(sigma)) then
+                                !    flux_rs${XYZ}$_vf(j, k, l, c_idx) = &
+                                !        (xi_M*qL_prim_rs${XYZ}$_vf(j, k, l, c_idx) + &
+                                !         xi_P*qR_prim_rs${XYZ}$_vf(j + 1, k, l, c_idx))*s_S
+                                !end if
 
+                                ! Geometrical source flux for cylindrical coordinates
                                 #:if (NORM_DIR == 2)
                                     if (cyl_coord) then
                                         !Substituting the advective flux into the inviscid geometrical source flux
@@ -2544,7 +2730,7 @@ contains
 
         !$acc update device(is1, is2, is3)
 
-        if (hypoelasticity) then
+        if (elasticity) then
             if (norm_dir == 1) then
                 dir_idx_tau = (/1, 2, 4/)
             else if (norm_dir == 2) then
diff --git a/src/simulation/m_start_up.fpp b/src/simulation/m_start_up.fpp
index 5e1c6f6e..10158e8e 100644
--- a/src/simulation/m_start_up.fpp
+++ b/src/simulation/m_start_up.fpp
@@ -46,9 +46,10 @@ module m_start_up
 
     use m_derived_variables     !< Procedures used to compute quantities derived
                                 !! from the conservative and primitive variables
-
     use m_hypoelastic
 
+    use m_hyperelastic
+
     use m_phase_change          !< Phase-change module
 
     use m_viscous
@@ -139,6 +140,7 @@ contains
             teno_CT, mp_weno, weno_avg, &
             riemann_solver, low_Mach, wave_speeds, avg_state, &
             bc_x, bc_y, bc_z, &
+            x_a, y_a, z_a, x_b, y_b, z_b, &
             x_domain, y_domain, z_domain, &
             hypoelasticity, &
             ib, num_ibs, patch_ib, &
@@ -146,8 +148,8 @@ contains
             fd_order, probe, num_probes, t_step_old, &
             alt_soundspeed, mixture_err, weno_Re_flux, &
             null_weights, precision, parallel_io, cyl_coord, &
-            rhoref, pref, bubbles, bubble_model, &
-            R0ref, &
+            rhoref, pref, bubbles, bubble_model, & 
+ 
 #:if not MFC_CASE_OPTIMIZATION
             nb, mapped_weno, wenoz, teno, weno_order, num_fluids, &
 #:endif
@@ -161,7 +163,7 @@ contains
             R0_type, file_per_process, sigma, &
             pi_fac, adv_n, adap_dt, bf_x, bf_y, bf_z, &
             k_x, k_y, k_z, w_x, w_y, w_z, p_x, p_y, p_z, &
-            g_x, g_y, g_z
+            g_x, g_y, g_z, hyperelasticity, R0ref
 
         ! Checking that an input file has been provided by the user. If it
         ! has, then the input file is read in, otherwise, simulation exits.
@@ -359,7 +361,7 @@ contains
             end if
         end do
 
-        if ((bubbles .eqv. .true.) .or. (hypoelasticity .eqv. .true.)) then
+        if ((bubbles .eqv. .true.) .or. (elasticity .eqv. .true.)) then
             ! Read pb and mv for non-polytropic qbmm
             if (qbmm .and. .not. polytropic) then
                 do i = 1, nb
@@ -589,7 +591,7 @@ contains
                 NVARS_MOK = int(sys_size, MPI_OFFSET_KIND)
 
                 ! Read the data for each variable
-                if (bubbles .or. hypoelasticity) then
+                if ( bubbles .or. elasticity ) then
 
                     do i = 1, sys_size!adv_idx%end
                         var_MOK = int(i, MPI_OFFSET_KIND)
@@ -614,6 +616,7 @@ contains
                                            MPI_DOUBLE_PRECISION, status, ierr)
                     end do
                 end if
+                
 
                 call s_mpi_barrier()
 
@@ -679,9 +682,9 @@ contains
                 NVARS_MOK = int(sys_size, MPI_OFFSET_KIND)
 
                 ! Read the data for each variable
-                if (bubbles .or. hypoelasticity) then
+                if ( bubbles .or. elasticity ) then
 
-                    do i = 1, sys_size!adv_idx%end
+                    do i = 1, sys_size !adv_idx%end
                         var_MOK = int(i, MPI_OFFSET_KIND)
                         ! Initial displacement to skip at beginning of file
                         disp = m_MOK*max(MOK, n_MOK)*max(MOK, p_MOK)*WP_MOK*(var_MOK - 1)
@@ -1120,7 +1123,7 @@ contains
         ! Time-stepping loop controls
         if ((mytime + dt) >= finaltime) dt = finaltime - mytime
         t_step = t_step + 1
-
+        
     end subroutine s_perform_time_step
 
     subroutine s_save_performance_metrics(t_step, time_avg, time_final, io_time_avg, io_time_final, proc_time, io_proc_time, file_exists, start, finish, nt)
@@ -1272,7 +1275,6 @@ contains
         call acc_present_dump()
 #endif
 
-        if (hypoelasticity) call s_initialize_hypoelastic_module()
         if (relax) call s_initialize_phasechange_module()
         call s_initialize_data_output_module()
         call s_initialize_derived_variables_module()
@@ -1312,9 +1314,11 @@ contains
 #endif
 
         call s_initialize_cbc_module()
-
         call s_initialize_derived_variables()
 
+        if (hypoelasticity) call s_initialize_hypoelastic_module()
+        if (hyperelasticity) call s_initialize_hyperelastic_module()
+
     end subroutine s_initialize_modules
 
     subroutine s_initialize_mpi_domain
@@ -1395,6 +1399,7 @@ contains
         do i = 1, sys_size
             !$acc update device(q_cons_ts(1)%vf(i)%sf)
         end do
+
         if (qbmm .and. .not. polytropic) then
             !$acc update device(pb_ts(1)%sf, mv_ts(1)%sf)
         end if
@@ -1410,7 +1415,6 @@ contains
         !$acc update device(bc_y%vb1, bc_y%vb2, bc_y%vb3, bc_y%ve1, bc_y%ve2, bc_y%ve3)
         !$acc update device(bc_z%vb1, bc_z%vb2, bc_z%vb3, bc_z%ve1, bc_z%ve2, bc_z%ve3)
 
-
         !$acc update device(relax, relax_model)
         if (relax) then
             !$acc update device(palpha_eps, ptgalpha_eps)
@@ -1428,6 +1432,8 @@ contains
         s_write_data_files => null()
 
         call s_finalize_time_steppers_module()
+        if (hypoelasticity) call s_finalize_hypoelastic_module() 
+        if (hyperelasticity) call s_finalize_hyperelastic_module() 
         call s_finalize_derived_variables_module()
         call s_finalize_data_output_module()
         call s_finalize_rhs_module()
diff --git a/src/simulation/m_surface_tension.fpp b/src/simulation/m_surface_tension.fpp
index 2e9ca8fe..b5faba05 100644
--- a/src/simulation/m_surface_tension.fpp
+++ b/src/simulation/m_surface_tension.fpp
@@ -1,7 +1,7 @@
 #:include 'macros.fpp'
 #:include 'inline_capillary.fpp'
 
-!> @brief This module is used to compute source terms for hypoelastic model
+!> @brief This module is used to compute source terms for surface tension model
 module m_surface_tension
 
     ! Dependencies =============================================================
diff --git a/src/simulation/m_time_steppers.fpp b/src/simulation/m_time_steppers.fpp
index d34c1fc0..b940bdc8 100644
--- a/src/simulation/m_time_steppers.fpp
+++ b/src/simulation/m_time_steppers.fpp
@@ -25,6 +25,8 @@ module m_time_steppers
 
     use m_ibm
 
+    use m_hyperelastic
+
     use m_mpi_proxy            !< Message passing interface (MPI) module proxy
 
     use m_boundary_conditions
@@ -181,8 +183,7 @@ contains
             end if
         end if
 
-        if (hypoelasticity) then
-
+        if (elasticity) then
             do i = stress_idx%beg, stress_idx%end
                 @:ALLOCATE(q_prim_vf(i)%sf(ix_t%beg:ix_t%end, &
                     iy_t%beg:iy_t%end, &
@@ -191,6 +192,15 @@ contains
             end do
         end if
 
+        if (hyperelasticity) then
+            do i = xibeg, xiend + 1
+                @:ALLOCATE(q_prim_vf(i)%sf(ix_t%beg:ix_t%end, &
+                    iy_t%beg:iy_t%end, &
+                    iz_t%beg:iz_t%end))
+                @:ACC_SETUP_SFs(q_prim_vf(i))
+            end do
+        end if
+
         if (model_eqns == 3) then
             do i = internalEnergies_idx%beg, internalEnergies_idx%end
                 @:ALLOCATE(q_prim_vf(i)%sf(ix_t%beg:ix_t%end, &
@@ -812,6 +822,10 @@ contains
             call s_pressure_relaxation_procedure(q_cons_ts(1)%vf)
         end if
 
+        call nvtxStartRange("RHS-ELASTIC")
+          if (hyperelasticity) call s_hyperelastic_rmt_stress_update(q_cons_ts(1)%vf, q_prim_vf)
+        call nvtxEndRange
+
         if (adv_n) call s_comp_alpha_from_n(q_cons_ts(1)%vf)
 
         if (ib) then
@@ -829,7 +843,6 @@ contains
             time = time + (finish - start)
         end if
         ! ==================================================================
-
     end subroutine s_3rd_order_tvd_rk
 
     !> Strang splitting scheme with 3rd order TVD RK time-stepping algorithm for
@@ -959,6 +972,7 @@ contains
         end if
 
     end subroutine s_time_step_cycling
+
     !> Module deallocation and/or disassociation procedures
     subroutine s_finalize_time_steppers_module
 
@@ -993,12 +1007,18 @@ contains
             @:DEALLOCATE(q_prim_vf(i)%sf)
         end do
 
-        if (hypoelasticity) then
+        if (elasticity) then
             do i = stress_idx%beg, stress_idx%end
                 @:DEALLOCATE(q_prim_vf(i)%sf)
             end do
         end if
 
+        if (hyperelasticity) then
+            do i = xibeg, xiend + 1
+                @:DEALLOCATE(q_prim_vf(i)%sf)
+            end do
+        end if
+
         if (bubbles) then
             do i = bub_idx%beg, bub_idx%end
                 @:DEALLOCATE(q_prim_vf(i)%sf)
diff --git a/src/simulation/m_viscous.fpp b/src/simulation/m_viscous.fpp
index 0019779e..5bdf4b84 100644
--- a/src/simulation/m_viscous.fpp
+++ b/src/simulation/m_viscous.fpp
@@ -12,8 +12,6 @@ module m_viscous
     use m_global_parameters    !< Definitions of the global parameters
 
     use m_weno
-
-    use m_helper
     ! ==========================================================================
 
     private; public s_get_viscous, &
diff --git a/src/simulation/p_main.fpp b/src/simulation/p_main.fpp
index 3f0e885c..8f24a5fe 100644
--- a/src/simulation/p_main.fpp
+++ b/src/simulation/p_main.fpp
@@ -36,7 +36,6 @@ program p_main
 
     !Initialize MPI
     call s_initialize_mpi_domain()
-
     !Initialize Modules
     call s_initialize_modules()
 
diff --git a/submit_gpu.sh b/submit_gpu.sh
new file mode 100755
index 00000000..2c77cc92
--- /dev/null
+++ b/submit_gpu.sh
@@ -0,0 +1,49 @@
+#!/bin/bash
+
+### A100s
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterex/input.py -e batch -p gpuA100x4 -N 5 -n 4 -g 1 -w 01:00:00 -# bwex_pre -t pre_process -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterim/input.py -e batch -p gpuA100x4 -N 5 -n 4 -g 1 -w 01:00:00 -# bwim_pre -t pre_process -a bciv-delta-gpu -c delta
+
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterex/input.py -e batch -p gpuA100x4 -N 5 -n 4 -g 1 -w 12:00:00 -# bwex_sim -t simulation -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterim/input.py -e batch -p gpuA100x4 -N 5 -n 4 -g 1 -w 12:00:00 -# bwim_sim -t simulation -a bciv-delta-gpu -c delta
+
+### A40s
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterex/input.py -e batch -p gpuA40x4 -N 5 -n 4 -g 1 -w 01:00:00 -# bwex_pre -t pre_process -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterim/input.py -e batch -p gpuA40x4 -N 5 -n 4 -g 1 -w 01:00:00 -# bwim_pre -t pre_process -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/test/input.py -e batch -p gpuA40x4 -N 5 -n 4 -g 1 -w 01:00:00 -# test -t pre_process -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterim2/input.py -e batch -p gpuA40x4 -N 5 -n 4 -g 1 -w 01:00:00 -# bwim_pre -t pre_process -a bciv-delta-gpu -c delta
+
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterex/input.py -e batch -p gpuA100x4 -N 5 -n 4 -g 1 -w 12:00:00 -# bwex_sim -t simulation -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterim/input.py -e batch -p gpuA100x4 -N 5 -n 4 -g 1 -w 12:00:00 -# bwim_sim -t simulation -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterex/input.py -e batch -p gpuA40x4 -N 5 -n 4 -g 1 -w 12:00:00 -# bwex_sim -t simulation -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterim/input.py -e batch -p gpuA40x4 -N 5 -n 4 -g 1 -w 12:00:00 -# bwim_sim -t simulation -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterim2/input.py -e batch -p gpuA40x4 -N 5 -n 4 -g 1 -w 12:00:00 -# bwim_sim -t simulation -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/test/input.py -e batch -p gpuA40x4 -N 5 -n 4 -g 1 -w 03:00:00 -# test_sim -t simulation -a bciv-delta-gpu -c delta
+
+
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterex/input.py -e batch -p gpuA40x4 -N 5 -n 4 -g 1 -w 00:30:00 -# bwex_post -t post_process -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterim/input.py -e batch -p gpuA40x4 -N 5 -n 4 -g 1 -w 00:30:00 -# bwim_post -t post_process -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterim2/input.py -e batch -p gpuA40x4 -N 5 -n 4 -g 1 -w 01:00:00 -# bwim_post -t post_process -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/mancia2024/bubwaterim2/input.py -e batch -p gpuA100x4 -N 5 -n 4 -g 1 -w 01:00:00 -# bwim_post -t post_process -a bciv-delta-gpu -c delta
+
+#./mfc.sh run /scratch/bciv/rodrigu1/test/input.py -e batch -p gpuA40x4 -N 5 -n 4 -g 1 -w 00:30:00 -# test_post -t post_process -a bciv-delta-gpu -c delta
+
+#./mfc.sh run /scratch/bciv/rodrigu1/cav2024/3Dsph_hyper_prestress_input.py -p gpuA40x4 -N 1 -n 1 -g 1 -w 01:00:00 -# test1 -t pre_process -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/cav2024/3Dsph_hyper_prestress_input.py -p gpuA40x4 -N 1 -n 1 -g 1 -w 01:00:00 -# test1 -t simulation -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/cav2024/3Dsph_hyper_prestress_input.py -p gpuA40x4 -N 1 -n 1 -g 1 -w 01:00:00 -# test1 -t post_process -a bciv-delta-gpu -c delta
+
+#./mfc.sh run /scratch/bciv/rodrigu1/cav2024/hyper/hyper_gel.py -p gpuA100x4 -N 1 -n 1 -g 1 -w 01:00:00 -# test1 -t pre_process -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/cav2024/hyper/hyper_gel.py -p gpuA100x4 -N 1 -n 1 -g 1 -w 01:00:00 -# test1 -t simulation -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/cav2024/hyper/hyper_gel.py -p gpuA40x4 -N 1 -n 1 -g 1 -w 01:00:00 -# test1 -t post_process -a bciv-delta-gpu -c delta
+
+#./mfc.sh run /scratch/bciv/rodrigu1/cav2024/hypoe/hypo_gel.py -p gpuA40x4 -N 1 -n 1 -g 1 -w 01:00:00 -# test1 -t pre_process -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/cav2024/hypoe/hypo_gel.py -p gpuA40x4 -N 1 -n 1 -g 1 -w 01:00:00 -# test1 -t simulation -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/cav2024/hypoe/hypo_gel.py -p gpuA40x4 -N 1 -n 1 -g 1 -w 01:00:00 -# test1 -t post_process -a bciv-delta-gpu -c delta
+
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test61/case.py -e batch -p gpuA100x4 -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t pre_process -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test61/case.py -e batch -p gpuA100x4 -N 1 -n 1 -g 0 -w 02:00:00 -# test1 -t simulation -a bciv-delta-gpu -c delta 
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test61/case.py -e batch -p gpuA100x4 -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t post_process -a bciv-delta-gpu -c delta
+
+./mfc.sh run tests/6FC6A809/case.py -p gpuA100x4 -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t pre_process -a bciv-delta-gpu -c delta
+./mfc.sh run tests/6FC6A809/case.py -p gpuA100x4 -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t simulation -a bciv-delta-gpu -c delta
+
diff --git a/submit_hyper.sh b/submit_hyper.sh
new file mode 100755
index 00000000..ba197a99
--- /dev/null
+++ b/submit_hyper.sh
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+./mfc.sh run ./examples/3D_hyperelasticity/hyper_gel.py -p batch -N 1 -n 4 -g 0 -w 01:00:00 -# test1 -t pre_process -c oscar
+./mfc.sh run ./examples/3D_hyperelasticity/hyper_gel.py -p batch -N 1 -n 4 -g 0 -w 01:00:00 -# test1 -t simulation -c oscar
+#./mfc.sh run /scratch/bciv/rodrigu1/cav2024/hyper/hyper_gel.py -p gpuA40x4 -N 1 -n 1 -g 1 -w 01:00:00 -# test1 -t post_process -a bciv-delta-gpu -c delta
+
+
diff --git a/submit_pc.sh b/submit_pc.sh
new file mode 100755
index 00000000..e45b98db
--- /dev/null
+++ b/submit_pc.sh
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+#./mfc.sh run ./examples/3D_hyperelasticity/hyper_gel.py -p batch -N 1 -n 4 -g 0 -w 01:00:00 -# test1 -t pre_process -c oscar
+#./mfc.sh run ./examples/3D_hyperelasticity/hyper_gel.py -p batch -N 1 -n 4 -g 0 -w 01:00:00 -# test1 -t simulation -c oscar
+#./mfc.sh run /scratch/bciv/rodrigu1/cav2024/hyper/hyper_gel.py -p gpuA40x4 -N 1 -n 1 -g 1 -w 01:00:00 -# test1 -t post_process -a bciv-delta-gpu -c delta
+
+./mfc.sh run ./examples/3D_phasechange_bubble/casefile.py -p batch -N 1 -n 4 -g 1 -w 01:00:00 -# test1 -t pre_process -c delta
+./mfc.sh run ./examples/3D_phasechange_bubble/casefile.py -p batch -N 1 -n 4 -g 1 -w 01:00:00 -# test1 -t simulation -c delta
+
diff --git a/submit_test.sh b/submit_test.sh
new file mode 100755
index 00000000..69b80bbe
--- /dev/null
+++ b/submit_test.sh
@@ -0,0 +1,52 @@
+#!/bin/bash
+
+#./mfc.sh run ./examples/3D_phasechange_bubble/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t pre_process -c delta
+#./mfc.sh run ./examples/3D_ctr_test/case.py -p batch -N 1 -n 8 -g 0 -w 01:00:00 -# test1 -t simulation -c delta
+#./mfc.sh run ./examples/3D_phasechange_bubble/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t post_process -c delta
+
+#./mfc.sh run ./examples/3D_ctr_test/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t pre_process -c delta
+#./mfc.sh run ./examples/3D_ctr_test/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t simulation -c delta
+#./mfc.sh run ./examples/3D_ctr_test/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t post_process -c delta
+
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test4/case.py -p batch -N 1 -n 4 -g 0 -w 01:00:00 -# test1 -t pre_process -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test4/case.py -p batch -N 1 -n 4 -g 0 -w 01:00:00 -# test1 -t simulation -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test4/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t post_process -c delta
+
+#./mfc.sh run /scratch/bciv/mcarcanabarbosa/ctr2024/testingpc4f/2speed/3dpc-noel-ptg.py -p batch -N 1 -n 4 -g 0 -w 01:00:00 -# test1 -t pre_process -c delta
+#./mfc.sh run /scratch/bciv/mcarcanabarbosa/ctr2024/testingpc4f/2speed/3dpc-noel-ptg.py -p batch -N 1 -n 4 -g 0 -w 01:00:00 -# test1 -t simulation -c delta
+#./mfc.sh run /scratch/bciv/mcarcanabarbosa/ctr2024/testingpc4f/2speed/3dpc-noel-ptg.py -p batch -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t post_process -c delta
+
+#./mfc.sh run /scratch/bciv/mcarcanabarbosa/ctr2024/testingpc4f/4speed/3dpc-noel-ptg.py -e batch -p gpuA100x4 -N 1 -n 4 -g 1 -w 00:10:00 -# test1 -t pre_process -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/mcarcanabarbosa/ctr2024/testingpc4f/4speed/3dpc-noel-ptg.py -e batch -p gpuA100x4 -N 1 -n 4 -g 1 -w 04:00:00 -# test1 -t simulation -a bciv-delta-gpu -c delta
+#./mfc.sh run /scratch/bciv/mcarcanabarbosa/ctr2024/testingpc4f/4speed/3dpc-noel-ptg.py -e batch -p gpuA100x4 -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t post_process -a bciv-delta-gpu -c delta
+
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test6.4/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t pre_process -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test6.4/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t simulation -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test6.4/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t post_process -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test6.3/case.py -p batch -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t post_process -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test6.4/case.py -e batch -p gpuA100x4 -N 1 -n 4 -g 4 -w 01:00:00 -# pre_bubingel -t pre_process -a bciv-delta-gpu -c delta 
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test6.4/case.py -e batch -p gpuA100x4 -N 1 -n 4 -g 4 -w 06:00:00 -# sim_bubingel -t simulation -a bciv-delta-gpu -c delta 
+
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test6.5/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t pre_process -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test6.5/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t simulation -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test6.5/case.py -p batch -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t post_process -c delta
+
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test4/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t pre_process -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test4/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t simulation -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test4/case.py -p batch -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t post_process -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test4/case.py -e batch -p gpuA100x4 -N 1 -n 4 -g 4 -w 06:00:00 -# pre_bubinwater -t pre_process -a bciv-delta-gpu -c delta 
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test4/case.py -e batch -p gpuA100x4 -N 1 -n 4 -g 4 -w 06:00:00 -# sim_bubinwater -t simulation -a bciv-delta-gpu -c delta 
+
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test4.1/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t pre_process -c delta
+#./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test4.1/case.py -p batch -N 1 -n 2 -g 0 -w 01:00:00 -# test1 -t simulation -c delta
+./mfc.sh run /scratch/bciv/rodrigu1/ctr2024/test4.1/case.py -p batch -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t post_process -c delta
+
+
+#./mfc.sh run /users/mrodri97/scratch/ctr2024/test6/case.py -p batch -N 1 -n 16 -g 0 -w 01:00:00 -# test1 -t pre_process -c oscar
+#./mfc.sh run /users/mrodri97/scratch/ctr2024/test6/case.py -p batch -N 1 -n 16 -g 0 -w 02:00:00 -# test1 -t simulation -c oscar
+#./mfc.sh run /users/mrodri97/scratch/ctr2024/test6/case.py -p batch -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t post_process -c oscar
+
+
+#./mfc.sh run /scratch/bciv/mcarcanabarbosa/ctr2024/finalruns/elcom/bubliq/25wv/case.py -p batch -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t post_process -c delta
+#./mfc.sh run /scratch/bciv/mcarcanabarbosa/ctr2024/finalruns/elcom/bubliq/75wv/case.py -p batch -N 1 -n 1 -g 0 -w 01:00:00 -# test1 -t post_process -c delta
+
diff --git a/toolchain/bootstrap/docker.sh b/toolchain/bootstrap/docker.sh
index 73e61372..60e34d92 100644
--- a/toolchain/bootstrap/docker.sh
+++ b/toolchain/bootstrap/docker.sh
@@ -30,4 +30,4 @@ if (($?)); then
     error "Error running Docker container with $@."
 
     exit 1
-fi
\ No newline at end of file
+fi
diff --git a/toolchain/bootstrap/modules.sh b/toolchain/bootstrap/modules.sh
index 097dca13..b437157f 100644
--- a/toolchain/bootstrap/modules.sh
+++ b/toolchain/bootstrap/modules.sh
@@ -23,8 +23,9 @@ if [ -v $u_c ]; then
     log   "$C""ACCESS$W:  Bridges2   (b) | Expanse (e) | Delta  (d)"
     log   "$Y""Gatech$W:  Phoenix    (p)"
     log   "$R""Caltech$W: Richardson (r)"
+    log   "$BR""Brown$W: Oscar (o)"
     log   "$B""DoD$W:     Carpenter  (c) | Nautilus (n)"
-    log_n "($G""a$W/$G""f$W/$G""s$W/$G""w$W/$C""b$W/$C""e$CR/$C""d$CR/$Y""p$CR/$R""r$CR/$B""c$CR/$B""n$CR): "
+    log_n "($G""a$W/$G""f$W/$G""s$W/$G""w$W/$C""b$W/$C""e$CR/$C""d$CR/$Y""p$CR/$R""r$CR/$B""c$CR/$B""n$CR/$BR""o"$CR"): "
     read u_c
     log
 fi
diff --git a/toolchain/mfc/bench.py b/toolchain/mfc/bench.py
index 52792f26..98e34309 100644
--- a/toolchain/mfc/bench.py
+++ b/toolchain/mfc/bench.py
@@ -16,7 +16,6 @@ class BenchCase:
     path: str
     args: typing.List[str]
 
-
 def bench(targets = None):
     if targets is None:
         targets = ARG("targets")
diff --git a/toolchain/mfc/run/case_dicts.py b/toolchain/mfc/run/case_dicts.py
index b39507d3..4658d6b6 100644
--- a/toolchain/mfc/run/case_dicts.py
+++ b/toolchain/mfc/run/case_dicts.py
@@ -19,6 +19,7 @@ class ParamType(Enum):
 
 COMMON = {
     'hypoelasticity': ParamType.LOG,
+    'hyperelasticity': ParamType.LOG,
     'cyl_coord': ParamType.LOG,
     'pref': ParamType.REAL,
     'p': ParamType.INT,
@@ -47,6 +48,7 @@ COMMON = {
     'relax_model': ParamType.INT,
     'sigma': ParamType.REAL,
     'adv_n': ParamType.LOG,
+    'hyperelasticity': ParamType.LOG,
 }
 
 PRE_PROCESS = COMMON.copy()
@@ -75,6 +77,7 @@ PRE_PROCESS.update({
     'pi_fac': ParamType.REAL,
     'ib': ParamType.LOG,
     'num_ibs': ParamType.INT,
+    'pre_stress': ParamType.LOG,
 })
 
 for ib_id in range(1, 10+1):
@@ -112,9 +115,11 @@ for p_id in range(1, 10+1):
                       ("smooth_patch_id", ParamType.INT), ("hcid", ParamType.INT)]:
         PRE_PROCESS[f"patch_icpp({p_id})%{attribute}"] = ty
 
-    for real_attr in ["radius",  "radii", "epsilon", "beta", "normal", "alpha_rho",
-                      "smooth_coeff", "rho", "vel", "alpha", "gamma",
+    for real_attr in ["radius",  "radii", "epsilon", "beta", "normal", "alpha_rho", "a2",
+                      "a3", "a4", "a5", "a6", "a7","a8", "a9", "a10", "a11", "a12",  'non_axis_sym',
+                      "normal", "smooth_coeff", "rho", "vel", "pres", "alpha", "gamma",
                       "pi_inf", "r0", "v0", "p0", "m0", "cv", "qv", "qvp", "cf_val"]: 
+
         PRE_PROCESS[f"patch_icpp({p_id})%{real_attr}"] = ParamType.REAL
     PRE_PROCESS[f"patch_icpp({p_id})%pres"] = ParamType.REAL.analytic()
 
@@ -279,7 +284,6 @@ for f_id in range(1,10+1):
             SIMULATION[f"integral({int_id})%{cmp}min"] = ParamType.REAL
             SIMULATION[f"integral({int_id})%{cmp}max"] = ParamType.REAL
 
-
 # Removed: 'fourier_modes%beg', 'fourier_modes%end', 'chem_wrt'
 # Feel free to return them if they are needed once more.
 POST_PROCESS = COMMON.copy()
@@ -314,6 +318,7 @@ POST_PROCESS.update({
     'qbmm': ParamType.LOG,
     'qm_wrt': ParamType.LOG,
     'cf_wrt': ParamType.LOG,
+    'sim_data': ParamType.LOG,
     'ib': ParamType.LOG
 })
 
diff --git a/toolchain/modules b/toolchain/modules
index 178d9966..bc0566a3 100644
--- a/toolchain/modules
+++ b/toolchain/modules
@@ -60,6 +60,12 @@ d-cpu gcc/11.4.0 openmpi
 d-gpu nvhpc/22.11 openmpi+cuda/4.1.5+cuda cmake
 d-gpu CC=nvc CXX=nvc++ FC=nvfortran
 
+o     Brown Oscar
+o-all python
+o-cpu hpcx-mpi
+o-gpu nvhpc cuda/12.3.0 cmake/3.26.3
+o-gpu CC=nvc CXX=nvc++ FC=nvfortran
+
 c     DoD Carpenter
 c-all python/3.12.1
 c-cpu compiler-rt/2024.2.0 ifort/2024.2.0 icc/2023.1.0 mpi/latest cmake/3.28.1-intel-2023.0.0
@@ -70,3 +76,4 @@ n-all slurm
 n-cpu penguin/openmpi/4.1.5/gcc-8.5.0
 n-gpu penguin/openmpi/4.1.5/nvhpc-22.3 nvidia/nvhpc/22.3 cuda/cuda-11.6
 n-gpu CC=nvc CXX=nvc++ FC=nvfortran
+
diff --git a/toolchain/templates/oscar.mako b/toolchain/templates/oscar.mako
new file mode 100644
index 00000000..158a217c
--- /dev/null
+++ b/toolchain/templates/oscar.mako
@@ -0,0 +1,56 @@
+#!/usr/bin/env bash
+
+<%namespace name="helpers" file="helpers.mako"/>
+
+% if engine == 'batch':
+#SBATCH --nodes=${nodes}
+#SBATCH --ntasks-per-node=${tasks_per_node}
+#SBATCH --cpus-per-task=1
+#SBATCH --job-name="${name}"
+#SBATCH --time=${walltime}
+% if partition:
+#SBATCH --partition=${partition}
+% endif
+% if account:
+#SBATCH --account="${account}"
+% endif
+% if gpu:
+#SBATCH --gpus-per-node=${tasks_per_node}
+#SBATCH --mem=64G
+#SBATCH --gpu-bind=closest
+% endif
+#SBATCH --output="${name}.out"
+#SBATCH --error="${name}.err"
+#SBATCH --export=ALL
+% if email:
+#SBATCH --mail-user=${email}
+#SBATCH --mail-type="BEGIN, END, FAIL"
+% endif
+% endif
+
+${helpers.template_prologue()}
+
+ok ":) Loading modules:\n"
+cd "${MFC_ROOTDIR}"
+. ./mfc.sh load -c o -m ${'g' if gpu else 'c'}
+cd - > /dev/null
+echo
+
+% for target in targets:
+    ${helpers.run_prologue(target)}
+
+    % if not mpi:
+        (set -x; ${profiler} "${target.get_install_binpath(case)}")
+    % else:
+        (set -x; ${profiler}    \
+            mpirun -np ${nodes*tasks_per_node}                 \
+                   ${' '.join([f"'{x}'" for x in ARG('--') ])} \
+                   "${target.get_install_binpath(case)}")
+    % endif
+
+    ${helpers.run_epilogue(target)}
+
+    echo
+% endfor
+
+${helpers.template_epilogue()}
diff --git a/toolchain/util.sh b/toolchain/util.sh
index c67c9cad..fddbe22a 100644
--- a/toolchain/util.sh
+++ b/toolchain/util.sh
@@ -1,10 +1,10 @@
 #!/bin/bash
 
 if [ -t 1 ]; then
-    RED="\x1B[31m";    CYAN="\x1B[36m";    GREEN="\x1B[32m"
+    RED="\x1B[31m";    CYAN="\x1B[36m";    GREEN="\x1B[32m"; BROWN="\x1B[38;5;58m"
     YELLOW="\x1B[33m"; MAGENTA="\x1B[35m"; BLUE="\x1B[34m"; COLOR_RESET="\033[m"
 
-    R=$RED;    C=$CYAN;    G=$GREEN
+    R=$RED;    C=$CYAN;    G=$GREEN; BR=$BROWN
     Y=$YELLOW; M=$MAGENTA; B=$BLUE; CR=$COLOR_RESET; W=$CR
 fi
 
